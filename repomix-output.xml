This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.claude/
  settings.local.json
cmd/
  add.go
  check.go
  clean.go
  clone.go
  completion.go
  init.go
  list.go
  pull.go
  push.go
  remove.go
  root.go
  shell-integration.go
  status.go
  switch.go
  sync.go
  validate.go
docs/
  libs/
    charmbracelet_lipgloss_readme.md
  info_ascii_mockup.md
  jira_completion_claude_desktop.md
  jira_prompt.md
  spec.md
  todo.md
internal/
  config.go
  git.go
  jira.go
  manager.go
  styles.go
  table.go
tools/
  strip-whitespace.sh
ttemp/
  example_config.toml
.envrc
.envrc.example
CLAUDE.md
go.mod
main.go
README.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".envrc">
# .envrc file for gbm (Git Branch Manager)
# Each environment variable maps to a specific branch

# Environment branches
PREVIEW=production-2025-07-1
MAIN=master
PROD=production-2025-05-1
</file>

<file path=".claude/settings.local.json">
{
  "permissions": {
    "allow": [
      "Bash(go build:*)",
      "Bash(go install:*)"
    ],
    "deny": []
  }
}
</file>

<file path="cmd/remove.go">
package cmd

import (
	"fmt"
	"os"
	"strings"

	"gbm/internal"

	"github.com/spf13/cobra"
)

var (
	force bool
)

var removeCmd = &cobra.Command{
	Use:   "remove <worktree-name>",
	Short: "Remove a worktree",
	Long: `Remove a worktree and clean up its directory.

This command removes the specified worktree and its associated directory.
If the worktree contains uncommitted changes, use --force to remove anyway.

Examples:
  gbm remove FEATURE-123
  gbm remove FEATURE-123 --force`,
	Args: cobra.ExactArgs(1),
	RunE: func(cmd *cobra.Command, args []string) error {
		worktreeName := args[0]

		// Find git repository root
		repoPath, err := internal.FindGitRoot(".")
		if err != nil {
			return fmt.Errorf("not in a git repository: %w", err)
		}

		// Create manager
		manager, err := internal.NewManager(repoPath)
		if err != nil {
			return fmt.Errorf("failed to create manager: %w", err)
		}

		// Check if worktree exists
		worktreePath, err := manager.GetWorktreePath(worktreeName)
		if err != nil {
			return fmt.Errorf("worktree '%s' not found: %w", worktreeName, err)
		}

		// Check if worktree has uncommitted changes (unless force is used)
		if !force {
			gitStatus, err := manager.GetWorktreeStatus(worktreePath)
			if err != nil {
				return fmt.Errorf("failed to check worktree status: %w", err)
			}

			if gitStatus.HasChanges() {
				return fmt.Errorf("worktree '%s' has uncommitted changes. Use --force to remove anyway", worktreeName)
			}
		}

		// Confirm removal (unless force is used)
		if !force {
			fmt.Printf("Are you sure you want to remove worktree '%s'? [y/N]: ", worktreeName)
			var response string
			fmt.Scanln(&response)
			if strings.ToLower(response) != "y" && strings.ToLower(response) != "yes" {
				PrintInfo("Removal cancelled")
				return nil
			}
		}

		// Remove the worktree
		if err := manager.RemoveWorktree(worktreeName); err != nil {
			return fmt.Errorf("failed to remove worktree: %w", err)
		}

		PrintInfo("Worktree '%s' removed successfully", worktreeName)
		return nil
	},
}

func init() {
	rootCmd.AddCommand(removeCmd)

	removeCmd.Flags().BoolVarP(&force, "force", "f", false, "Force removal even if worktree has uncommitted changes")

	// Add completion for worktree names
	removeCmd.ValidArgsFunction = func(cmd *cobra.Command, args []string, toComplete string) ([]string, cobra.ShellCompDirective) {
		if len(args) == 0 {
			// Get current working directory
			wd, err := os.Getwd()
			if err != nil {
				return nil, cobra.ShellCompDirectiveNoFileComp
			}

			// Find git repository root
			repoPath, err := internal.FindGitRoot(wd)
			if err != nil {
				return nil, cobra.ShellCompDirectiveNoFileComp
			}

			// Create manager
			manager, err := internal.NewManager(repoPath)
			if err != nil {
				return nil, cobra.ShellCompDirectiveNoFileComp
			}

			// Get all worktrees
			worktrees, err := manager.GetAllWorktrees()
			if err != nil {
				return nil, cobra.ShellCompDirectiveNoFileComp
			}

			var completions []string
			for worktreeName := range worktrees {
				completions = append(completions, worktreeName)
			}
			return completions, cobra.ShellCompDirectiveNoFileComp
		}
		return nil, cobra.ShellCompDirectiveNoFileComp
	}
}
</file>

<file path="docs/libs/charmbracelet_lipgloss_readme.md">
# Lip Gloss

<p>
    <picture>
      <source media="(prefers-color-scheme: light)" srcset="https://stuff.charm.sh/lipgloss/lip-gloss-light-2025-06.png" width="340">
      <source media="(prefers-color-scheme: dark)" srcset="https://stuff.charm.sh/lipgloss/lip-gloss-dark-2025-06.png" width="340">
      <img src="https://stuff.charm.sh/lipgloss/lip-gloss-light-2025-06.png" width="340" />
    </picture>
    <br>
    <a href="https://github.com/charmbracelet/lipgloss/releases"><img src="https://img.shields.io/github/release/charmbracelet/lipgloss.svg" alt="Latest Release"></a>
    <a href="https://pkg.go.dev/github.com/charmbracelet/lipgloss?tab=doc"><img src="https://godoc.org/github.com/golang/gddo?status.svg" alt="GoDoc"></a>
    <a href="https://github.com/charmbracelet/lipgloss/actions"><img src="https://github.com/charmbracelet/lipgloss/workflows/build/badge.svg" alt="Build Status"></a>
</p>

Style definitions for nice terminal layouts. Built with TUIs in mind.

![Lip Gloss example](https://github.com/user-attachments/assets/92560e60-d70e-4ce0-b39e-a60bb933356b)

Lip Gloss takes an expressive, declarative approach to terminal rendering.
Users familiar with CSS will feel at home with Lip Gloss.

```go

import "github.com/charmbracelet/lipgloss"

var style = lipgloss.NewStyle().
    Bold(true).
    Foreground(lipgloss.Color("#FAFAFA")).
    Background(lipgloss.Color("#7D56F4")).
    PaddingTop(2).
    PaddingLeft(4).
    Width(22)

fmt.Println(style.Render("Hello, kitty"))
```

## Colors

Lip Gloss supports the following color profiles:

### ANSI 16 colors (4-bit)

```go
lipgloss.Color("5")  // magenta
lipgloss.Color("9")  // red
lipgloss.Color("12") // light blue
```

### ANSI 256 Colors (8-bit)

```go
lipgloss.Color("86")  // aqua
lipgloss.Color("201") // hot pink
lipgloss.Color("202") // orange
```

### True Color (16,777,216 colors; 24-bit)

```go
lipgloss.Color("#0000FF") // good ol' 100% blue
lipgloss.Color("#04B575") // a green
lipgloss.Color("#3C3C3C") // a dark gray
```

...as well as a 1-bit ASCII profile, which is black and white only.

The terminal's color profile will be automatically detected, and colors outside
the gamut of the current palette will be automatically coerced to their closest
available value.

### Adaptive Colors

You can also specify color options for light and dark backgrounds:

```go
lipgloss.AdaptiveColor{Light: "236", Dark: "248"}
```

The terminal's background color will automatically be detected and the
appropriate color will be chosen at runtime.

### Complete Colors

CompleteColor specifies exact values for True Color, ANSI256, and ANSI color
profiles.

```go
lipgloss.CompleteColor{TrueColor: "#0000FF", ANSI256: "86", ANSI: "5"}
```

Automatic color degradation will not be performed in this case and it will be
based on the color specified.

### Complete Adaptive Colors

You can use `CompleteColor` with `AdaptiveColor` to specify the exact values for
light and dark backgrounds without automatic color degradation.

```go
lipgloss.CompleteAdaptiveColor{
    Light: CompleteColor{TrueColor: "#d7ffae", ANSI256: "193", ANSI: "11"},
    Dark:  CompleteColor{TrueColor: "#d75fee", ANSI256: "163", ANSI: "5"},
}
```

## Inline Formatting

Lip Gloss supports the usual ANSI text formatting options:

```go
var style = lipgloss.NewStyle().
    Bold(true).
    Italic(true).
    Faint(true).
    Blink(true).
    Strikethrough(true).
    Underline(true).
    Reverse(true)
```

## Block-Level Formatting

Lip Gloss also supports rules for block-level formatting:

```go
// Padding
var style = lipgloss.NewStyle().
    PaddingTop(2).
    PaddingRight(4).
    PaddingBottom(2).
    PaddingLeft(4)

// Margins
var style = lipgloss.NewStyle().
    MarginTop(2).
    MarginRight(4).
    MarginBottom(2).
    MarginLeft(4)
```

There is also shorthand syntax for margins and padding, which follows the same
format as CSS:

```go
// 2 cells on all sides
lipgloss.NewStyle().Padding(2)

// 2 cells on the top and bottom, 4 cells on the left and right
lipgloss.NewStyle().Margin(2, 4)

// 1 cell on the top, 4 cells on the sides, 2 cells on the bottom
lipgloss.NewStyle().Padding(1, 4, 2)

// Clockwise, starting from the top: 2 cells on the top, 4 on the right, 3 on
// the bottom, and 1 on the left
lipgloss.NewStyle().Margin(2, 4, 3, 1)
```

## Aligning Text

You can align paragraphs of text to the left, right, or center.

```go
var style = lipgloss.NewStyle().
    Width(24).
    Align(lipgloss.Left).  // align it left
    Align(lipgloss.Right). // no wait, align it right
    Align(lipgloss.Center) // just kidding, align it in the center
```

## Width and Height

Setting a minimum width and height is simple and straightforward.

```go
var style = lipgloss.NewStyle().
    SetString("What’s for lunch?").
    Width(24).
    Height(32).
    Foreground(lipgloss.Color("63"))
```

## Borders

Adding borders is easy:

```go
// Add a purple, rectangular border
var style = lipgloss.NewStyle().
    BorderStyle(lipgloss.NormalBorder()).
    BorderForeground(lipgloss.Color("63"))

// Set a rounded, yellow-on-purple border to the top and left
var anotherStyle = lipgloss.NewStyle().
    BorderStyle(lipgloss.RoundedBorder()).
    BorderForeground(lipgloss.Color("228")).
    BorderBackground(lipgloss.Color("63")).
    BorderTop(true).
    BorderLeft(true)

// Make your own border
var myCuteBorder = lipgloss.Border{
    Top:         "._.:*:",
    Bottom:      "._.:*:",
    Left:        "|*",
    Right:       "|*",
    TopLeft:     "*",
    TopRight:    "*",
    BottomLeft:  "*",
    BottomRight: "*",
}
```

There are also shorthand functions for defining borders, which follow a similar
pattern to the margin and padding shorthand functions.

```go
// Add a thick border to the top and bottom
lipgloss.NewStyle().
    Border(lipgloss.ThickBorder(), true, false)

// Add a double border to the top and left sides. Rules are set clockwise
// from top.
lipgloss.NewStyle().
    Border(lipgloss.DoubleBorder(), true, false, false, true)
```

For more on borders see [the docs][docs].

## Copying Styles

Just use assignment:

```go
style := lipgloss.NewStyle().Foreground(lipgloss.Color("219"))

copiedStyle := style // this is a true copy

wildStyle := style.Blink(true) // this is also true copy, with blink added

```

Since `Style` data structures contains only primitive types, assigning a style
to another effectively creates a new copy of the style without mutating the
original.

## Inheritance

Styles can inherit rules from other styles. When inheriting, only unset rules
on the receiver are inherited.

```go
var styleA = lipgloss.NewStyle().
    Foreground(lipgloss.Color("229")).
    Background(lipgloss.Color("63"))

// Only the background color will be inherited here, because the foreground
// color will have been already set:
var styleB = lipgloss.NewStyle().
    Foreground(lipgloss.Color("201")).
    Inherit(styleA)
```

## Unsetting Rules

All rules can be unset:

```go
var style = lipgloss.NewStyle().
    Bold(true).                        // make it bold
    UnsetBold().                       // jk don't make it bold
    Background(lipgloss.Color("227")). // yellow background
    UnsetBackground()                  // never mind
```

When a rule is unset, it won't be inherited or copied.

## Enforcing Rules

Sometimes, such as when developing a component, you want to make sure style
definitions respect their intended purpose in the UI. This is where `Inline`
and `MaxWidth`, and `MaxHeight` come in:

```go
// Force rendering onto a single line, ignoring margins, padding, and borders.
someStyle.Inline(true).Render("yadda yadda")

// Also limit rendering to five cells
someStyle.Inline(true).MaxWidth(5).Render("yadda yadda")

// Limit rendering to a 5x5 cell block
someStyle.MaxWidth(5).MaxHeight(5).Render("yadda yadda")
```

## Tabs

The tab character (`\t`) is rendered differently in different terminals (often
as 8 spaces, sometimes 4). Because of this inconsistency, Lip Gloss converts
tabs to 4 spaces at render time. This behavior can be changed on a per-style
basis, however:

```go
style := lipgloss.NewStyle() // tabs will render as 4 spaces, the default
style = style.TabWidth(2)    // render tabs as 2 spaces
style = style.TabWidth(0)    // remove tabs entirely
style = style.TabWidth(lipgloss.NoTabConversion) // leave tabs intact
```

## Rendering

Generally, you just call the `Render(string...)` method on a `lipgloss.Style`:

```go
style := lipgloss.NewStyle().Bold(true).SetString("Hello,")
fmt.Println(style.Render("kitty.")) // Hello, kitty.
fmt.Println(style.Render("puppy.")) // Hello, puppy.
```

But you could also use the Stringer interface:

```go
var style = lipgloss.NewStyle().SetString("你好，猫咪。").Bold(true)
fmt.Println(style) // 你好，猫咪。
```

### Custom Renderers

Custom renderers allow you to render to a specific outputs. This is
particularly important when you want to render to different outputs and
correctly detect the color profile and dark background status for each, such as
in a server-client situation.

```go
func myLittleHandler(sess ssh.Session) {
    // Create a renderer for the client.
    renderer := lipgloss.NewRenderer(sess)

    // Create a new style on the renderer.
    style := renderer.NewStyle().Background(lipgloss.AdaptiveColor{Light: "63", Dark: "228"})

    // Render. The color profile and dark background state will be correctly detected.
    io.WriteString(sess, style.Render("Heyyyyyyy"))
}
```

For an example on using a custom renderer over SSH with [Wish][wish] see the
[SSH example][ssh-example].

## Utilities

In addition to pure styling, Lip Gloss also ships with some utilities to help
assemble your layouts.

### Joining Paragraphs

Horizontally and vertically joining paragraphs is a cinch.

```go
// Horizontally join three paragraphs along their bottom edges
lipgloss.JoinHorizontal(lipgloss.Bottom, paragraphA, paragraphB, paragraphC)

// Vertically join two paragraphs along their center axes
lipgloss.JoinVertical(lipgloss.Center, paragraphA, paragraphB)

// Horizontally join three paragraphs, with the shorter ones aligning 20%
// from the top of the tallest
lipgloss.JoinHorizontal(0.2, paragraphA, paragraphB, paragraphC)
```

### Measuring Width and Height

Sometimes you’ll want to know the width and height of text blocks when building
your layouts.

```go
// Render a block of text.
var style = lipgloss.NewStyle().
    Width(40).
    Padding(2)
var block string = style.Render(someLongString)

// Get the actual, physical dimensions of the text block.
width := lipgloss.Width(block)
height := lipgloss.Height(block)

// Here's a shorthand function.
w, h := lipgloss.Size(block)
```

### Placing Text in Whitespace

Sometimes you’ll simply want to place a block of text in whitespace.

```go
// Center a paragraph horizontally in a space 80 cells wide. The height of
// the block returned will be as tall as the input paragraph.
block := lipgloss.PlaceHorizontal(80, lipgloss.Center, fancyStyledParagraph)

// Place a paragraph at the bottom of a space 30 cells tall. The width of
// the text block returned will be as wide as the input paragraph.
block := lipgloss.PlaceVertical(30, lipgloss.Bottom, fancyStyledParagraph)

// Place a paragraph in the bottom right corner of a 30x80 cell space.
block := lipgloss.Place(30, 80, lipgloss.Right, lipgloss.Bottom, fancyStyledParagraph)
```

You can also style the whitespace. For details, see [the docs][docs].

## Rendering Tables

Lip Gloss ships with a table rendering sub-package.

```go
import "github.com/charmbracelet/lipgloss/table"
```

Define some rows of data.

```go
rows := [][]string{
    {"Chinese", "您好", "你好"},
    {"Japanese", "こんにちは", "やあ"},
    {"Arabic", "أهلين", "أهلا"},
    {"Russian", "Здравствуйте", "Привет"},
    {"Spanish", "Hola", "¿Qué tal?"},
}
```

Use the table package to style and render the table.

```go
var (
    purple    = lipgloss.Color("99")
    gray      = lipgloss.Color("245")
    lightGray = lipgloss.Color("241")

    headerStyle  = lipgloss.NewStyle().Foreground(purple).Bold(true).Align(lipgloss.Center)
    cellStyle    = lipgloss.NewStyle().Padding(0, 1).Width(14)
    oddRowStyle  = cellStyle.Foreground(gray)
    evenRowStyle = cellStyle.Foreground(lightGray)
)

t := table.New().
    Border(lipgloss.NormalBorder()).
    BorderStyle(lipgloss.NewStyle().Foreground(purple)).
    StyleFunc(func(row, col int) lipgloss.Style {
        switch {
        case row == table.HeaderRow:
            return headerStyle
        case row%2 == 0:
            return evenRowStyle
        default:
            return oddRowStyle
        }
    }).
    Headers("LANGUAGE", "FORMAL", "INFORMAL").
    Rows(rows...)

// You can also add tables row-by-row
t.Row("English", "You look absolutely fabulous.", "How's it going?")
```

Print the table.

```go
fmt.Println(t)
```

![Table Example](https://github.com/charmbracelet/lipgloss/assets/42545625/6e4b70c4-f494-45da-a467-bdd27df30d5d)

> [!WARNING]
> Table `Rows` need to be declared before `Offset` otherwise it does nothing.

### Table Borders

There are helpers to generate tables in markdown or ASCII style:

#### Markdown Table

```go
table.New().Border(lipgloss.MarkdownBorder()).BorderTop(false).BorderBottom(false)
```

```
| LANGUAGE |    FORMAL    | INFORMAL  |
|----------|--------------|-----------|
| Chinese  | Nǐn hǎo      | Nǐ hǎo    |
| French   | Bonjour      | Salut     |
| Russian  | Zdravstvuyte | Privet    |
| Spanish  | Hola         | ¿Qué tal? |
```

#### ASCII Table

```go
table.New().Border(lipgloss.ASCIIBorder())
```

```
+----------+--------------+-----------+
| LANGUAGE |    FORMAL    | INFORMAL  |
+----------+--------------+-----------+
| Chinese  | Nǐn hǎo      | Nǐ hǎo    |
| French   | Bonjour      | Salut     |
| Russian  | Zdravstvuyte | Privet    |
| Spanish  | Hola         | ¿Qué tal? |
+----------+--------------+-----------+
```

For more on tables see [the docs](https://pkg.go.dev/github.com/charmbracelet/lipgloss?tab=doc) and [examples](https://github.com/charmbracelet/lipgloss/tree/master/examples/table).

## Rendering Lists

Lip Gloss ships with a list rendering sub-package.

```go
import "github.com/charmbracelet/lipgloss/list"
```

Define a new list.

```go
l := list.New("A", "B", "C")
```

Print the list.

```go
fmt.Println(l)

// • A
// • B
// • C
```

Lists have the ability to nest.

```go
l := list.New(
    "A", list.New("Artichoke"),
    "B", list.New("Baking Flour", "Bananas", "Barley", "Bean Sprouts"),
    "C", list.New("Cashew Apple", "Cashews", "Coconut Milk", "Curry Paste", "Currywurst"),
    "D", list.New("Dill", "Dragonfruit", "Dried Shrimp"),
    "E", list.New("Eggs"),
    "F", list.New("Fish Cake", "Furikake"),
    "J", list.New("Jicama"),
    "K", list.New("Kohlrabi"),
    "L", list.New("Leeks", "Lentils", "Licorice Root"),
)
```

Print the list.

```go
fmt.Println(l)
```

<p align="center">
<img width="600" alt="image" src="https://github.com/charmbracelet/lipgloss/assets/42545625/0dc9f440-0748-4151-a3b0-7dcf29dfcdb0">
</p>

Lists can be customized via their enumeration function as well as using
`lipgloss.Style`s.

```go
enumeratorStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("99")).MarginRight(1)
itemStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("212")).MarginRight(1)

l := list.New(
    "Glossier",
    "Claire’s Boutique",
    "Nyx",
    "Mac",
    "Milk",
    ).
    Enumerator(list.Roman).
    EnumeratorStyle(enumeratorStyle).
    ItemStyle(itemStyle)
```

Print the list.

<p align="center">
<img width="600" alt="List example" src="https://github.com/charmbracelet/lipgloss/assets/42545625/360494f1-57fb-4e13-bc19-0006efe01561">
</p>

In addition to the predefined enumerators (`Arabic`, `Alphabet`, `Roman`, `Bullet`, `Tree`),
you may also define your own custom enumerator:

```go
l := list.New("Duck", "Duck", "Duck", "Duck", "Goose", "Duck", "Duck")

func DuckDuckGooseEnumerator(l list.Items, i int) string {
    if l.At(i).Value() == "Goose" {
        return "Honk →"
    }
    return ""
}

l = l.Enumerator(DuckDuckGooseEnumerator)
```

Print the list:

<p align="center">
<img width="600" alt="image" src="https://github.com/charmbracelet/lipgloss/assets/42545625/157aaf30-140d-4948-9bb4-dfba46e5b87e">
</p>

If you need, you can also build lists incrementally:

```go
l := list.New()

for i := 0; i < repeat; i++ {
    l.Item("Lip Gloss")
}
```

## Rendering Trees

Lip Gloss ships with a tree rendering sub-package.

```go
import "github.com/charmbracelet/lipgloss/tree"
```

Define a new tree.

```go
t := tree.Root(".").
    Child("A", "B", "C")
```

Print the tree.

```go
fmt.Println(t)

// .
// ├── A
// ├── B
// └── C
```

Trees have the ability to nest.

```go
t := tree.Root(".").
    Child("macOS").
    Child(
        tree.New().
            Root("Linux").
            Child("NixOS").
            Child("Arch Linux (btw)").
            Child("Void Linux"),
        ).
    Child(
        tree.New().
            Root("BSD").
            Child("FreeBSD").
            Child("OpenBSD"),
    )
```

Print the tree.

```go
fmt.Println(t)
```

<p align="center">
<img width="663" alt="Tree Example (simple)" src="https://github.com/user-attachments/assets/5ef14eb8-a5d4-4f94-8834-e15d1e714f89">
</p>

Trees can be customized via their enumeration function as well as using
`lipgloss.Style`s.

```go
enumeratorStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("63")).MarginRight(1)
rootStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("35"))
itemStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("212"))

t := tree.
    Root("⁜ Makeup").
    Child(
        "Glossier",
        "Fenty Beauty",
        tree.New().Child(
            "Gloss Bomb Universal Lip Luminizer",
            "Hot Cheeks Velour Blushlighter",
        ),
        "Nyx",
        "Mac",
        "Milk",
    ).
    Enumerator(tree.RoundedEnumerator).
    EnumeratorStyle(enumeratorStyle).
    RootStyle(rootStyle).
    ItemStyle(itemStyle)
```

Print the tree.

<p align="center">
<img width="663" alt="Tree Example (makeup)" src="https://github.com/user-attachments/assets/06d12d87-744a-4c89-bd98-45de9094a97e">
</p>

The predefined enumerators for trees are `DefaultEnumerator` and `RoundedEnumerator`.

If you need, you can also build trees incrementally:

```go
t := tree.New()

for i := 0; i < repeat; i++ {
    t.Child("Lip Gloss")
}
```

---

## FAQ

<details>
<summary>
Why are things misaligning? Why are borders at the wrong widths?
</summary>
<p>This is most likely due to your locale and encoding, particularly with
regard to Chinese, Japanese, and Korean (for example, <code>zh_CN.UTF-8</code>
or <code>ja_JP.UTF-8</code>). The most direct way to fix this is to set
<code>RUNEWIDTH_EASTASIAN=0</code> in your environment.</p>

<p>For details see <a href="https://github.com/charmbracelet/lipgloss/issues/40">https://github.com/charmbracelet/lipgloss/issues/40.</a></p>
</details>

<details>
<summary>
Why isn't Lip Gloss displaying colors?
</summary>
<p>Lip Gloss automatically degrades colors to the best available option in the
given terminal, and if output's not a TTY it will remove color output entirely.
This is common when running tests, CI, or when piping output elsewhere.</p>

<p>If necessary, you can force a color profile in your tests with
<a href="https://pkg.go.dev/github.com/charmbracelet/lipgloss#SetColorProfile"><code>SetColorProfile</code></a>.</p>

```go
import (
    "github.com/charmbracelet/lipgloss"
    "github.com/muesli/termenv"
)

lipgloss.SetColorProfile(termenv.TrueColor)
```

_Note:_ this option limits the flexibility of your application and can cause
ANSI escape codes to be output in cases where that might not be desired. Take
careful note of your use case and environment before choosing to force a color
profile.

</details>

## What about [Bubble Tea][tea]?

Lip Gloss doesn’t replace Bubble Tea. Rather, it is an excellent Bubble Tea
companion. It was designed to make assembling terminal user interface views as
simple and fun as possible so that you can focus on building your application
instead of concerning yourself with low-level layout details.

In simple terms, you can use Lip Gloss to help build your Bubble Tea views.

[tea]: https://github.com/charmbracelet/tea

## Under the Hood

Lip Gloss is built on the excellent [Termenv][termenv] and [Reflow][reflow]
libraries which deal with color and ANSI-aware text operations, respectively.
For many use cases Termenv and Reflow will be sufficient for your needs.

[termenv]: https://github.com/muesli/termenv
[reflow]: https://github.com/muesli/reflow

## Rendering Markdown

For a more document-centric rendering solution with support for things like
lists, tables, and syntax-highlighted code have a look at [Glamour][glamour],
the stylesheet-based Markdown renderer.

[glamour]: https://github.com/charmbracelet/glamour

## Contributing

See [contributing][contribute].

[contribute]: https://github.com/charmbracelet/lipgloss/contribute

## Feedback

We’d love to hear your thoughts on this project. Feel free to drop us a note!

- [Twitter](https://twitter.com/charmcli)
- [The Fediverse](https://mastodon.social/@charmcli)
- [Discord](https://charm.sh/chat)

## License

[MIT](https://github.com/charmbracelet/lipgloss/raw/master/LICENSE)

---

Part of [Charm](https://charm.sh).

<a href="https://charm.sh/"><img alt="The Charm logo" src="https://stuff.charm.sh/charm-badge.jpg" width="400"></a>

Charm热爱开源 • Charm loves open source

[docs]: https://pkg.go.dev/github.com/charmbracelet/lipgloss?tab=doc
[wish]: https://github.com/charmbracelet/wish
[ssh-example]: examples/ssh
</file>

<file path="docs/info_ascii_mockup.md">
$ gbm info PROJECT-123

╔═══════════════════════════════════════════════════════════════════════════════╗
║                           📋 WORKTREE INFO: PROJECT-123                       ║
╚═══════════════════════════════════════════════════════════════════════════════╝

┌─ 📁 WORKTREE ───────────────────────────────────────────────────────────────────┐
│ Name: PROJECT-123                                                               │
│ Path: /home/user/repos/myapp/worktrees/PROJECT-123                              │
│ Branch: feature/PROJECT-123_update_user_auth_flow                               │
│ Created: 2025-07-02 14:30:15 (3 days ago)                                       │
│ Status: 🟡 DIRTY (5 files modified                                              │
│ PR: https://github.com/company/myapp/pull/456 (Draft)                           │
└─────────────────────────────────────────────────────────────────────────────────┘

┌─ 🎫 JIRA TICKET ────────────────────────────────────────────────────────────────┐
│ Key: PROJECT-123                                                                │
│ Summary: Update user auth flow                                                  │
│ Status: 🔄 In Progress → Code Review                                            │
│ Assignee: john.doe@company.com                                                  │
│ Priority: 🔴 High                    Reporter: jane.smith@company.com           │
│ Created: 2025-06-28 09:15:00         Due Date: 2025-07-10 17:00:00              │
│ Epic: AUTH-001 (User Authentication Overhaul)                                   │
│ Link: https://company.atlassian.net/browse/PROJECT-123                          │
│                                                                                 │
│ 💬 Latest Comment (2 hours ago):                                                │
│    "Please review the password validation logic before merging"                 │
│    - tech.lead@company.com                                                      │
└─────────────────────────────────────────────────────────────────────────────────┘

┌─ 🌿 GIT STATUS ────────────────────────────────────────────────────────────────┐
│ Base Branch: develop (diverged 5 days ago at commit abc1234)                   │
│ Upstream: origin/feature/PROJECT-123_update_user_auth_flow                     │
│ Position: ↑ 4 commits ahead, ↓ 2 commits behind origin                         │
│                                                                                │
│ Last Commit: feat: implement 2FA validation (def5678) - 3 hours ago            │
│ Author: John Doe <john.doe@company.com>                                        │
│                                                                                │
│ Modified Files:                                                                │
│   M  src/auth/validator.go        (+89, -23)                                   │
│   M  src/auth/middleware.go       (+45, -12)                                   │
│   A  src/auth/twofa.go            (+156, -0)                                   │
│   M  tests/auth_test.go           (+78, -5)                                    │
│   M  docs/auth_flow.md            (+12, -3)                                    │
│                                                                                │
│ Recent Commits:                                                                │
│   def5678 feat: implement 2FA validation               (3 hours ago)           │
│   ghi9012 refactor: extract auth helpers               (1 day ago)             │
│   jkl3456 fix: handle edge case in password reset      (2 days ago)            │
│   mno7890 feat: add session timeout configuration      (3 days ago)            │
└────────────────────────────────────────────────────────────────────────────────┘
</file>

<file path="docs/jira_completion_claude_desktop.md">
This is a great enhancement! Let me think through a few approaches for integrating JIRA tickets into your COBRA CLI with good UX.

## Approach 1: Dynamic Shell Completions (Recommended)

COBRA supports dynamic completions that can call external commands. You can have your CLI fetch JIRA issues on-demand during tab completion:

```go
// In your add command setup
addCmd.RegisterFlagCompletionFunc("branch", func(cmd *cobra.Command, args []string, toComplete string) ([]string, cobra.ShellCompDirective) {
    if len(args) == 1 {
        // args[0] is the worktree name (JIRA key)
        return generateBranchSuggestions(args[0]), cobra.ShellCompDirectiveNoFileComp
    }
    return nil, cobra.ShellCompDirectiveNoFileComp
})

// For the positional argument (JIRA key)
addCmd.ValidArgsFunction = func(cmd *cobra.Command, args []string, toComplete string) ([]string, cobra.ShellCompDirective) {
    if len(args) == 0 {
        return getJiraKeys(), cobra.ShellCompDirectiveNoFileComp
    }
    return nil, cobra.ShellCompDirectiveNoFileComp
}

func getJiraKeys() []string {
    cmd := exec.Command("jira", "issue", "list", "-a$(jira me)", "--plain")
    output, err := cmd.Output()
    if err != nil {
        return nil
    }
    
    var keys []string
    lines := strings.Split(string(output), "\n")
    for _, line := range lines[1:] { // Skip header
        if line = strings.TrimSpace(line); line != "" {
            fields := strings.Fields(line)
            if len(fields) >= 2 {
                keys = append(keys, fields[1]) // The KEY column
            }
        }
    }
    return keys
}

func generateBranchSuggestions(jiraKey string) []string {
    // Fetch the specific issue details to get type and summary
    cmd := exec.Command("jira", "issue", "view", jiraKey, "--plain")
    output, err := cmd.Output()
    if err != nil {
        return nil
    }
    
    // Parse output to extract type and summary
    // Then format as: bug/INGSVC-5544_Zoom_Clips_-_New_Integration
    issueType, summary := parseJiraIssue(output)
    branchName := fmt.Sprintf("%s/%s_%s", 
        strings.ToLower(issueType), 
        jiraKey, 
        strings.ReplaceAll(summary, " ", "_"))
    
    return []string{branchName}
}
```

## Approach 2: Smart Default Behavior

Make the command work intuitively without requiring the `-b` flag when using JIRA keys:

```go
func runAddCommand(cmd *cobra.Command, args []string) error {
    worktreeName := args[0]
    branchName, _ := cmd.Flags().GetString("branch")
    
    // Check if worktree name looks like a JIRA key
    if isJiraKey(worktreeName) && branchName == "" {
        // Auto-generate branch name from JIRA
        generatedBranch, err := generateBranchFromJira(worktreeName)
        if err != nil {
            return fmt.Errorf("failed to fetch JIRA issue: %w", err)
        }
        branchName = generatedBranch
        fmt.Printf("Auto-detected JIRA issue, using branch: %s\n", branchName)
    }
    
    return createWorktree(worktreeName, branchName)
}

func isJiraKey(s string) bool {
    // Simple regex to match JIRA key pattern
    matched, _ := regexp.MatchString(`^[A-Z]+-\d+$`, s)
    return matched
}
```

## Approach 3: Interactive Selection

Add a `--interactive` or `--jira` flag that presents a nice selection interface:

```go
func runAddWithJira(cmd *cobra.Command, args []string) error {
    issues, err := fetchJiraIssues()
    if err != nil {
        return err
    }
    
    // Use a library like survey or bubbletea for nice selection
    selected := promptForIssue(issues)
    
    worktreeName := selected.Key
    branchName := generateBranchName(selected)
    
    return createWorktree(worktreeName, branchName)
}
```

## Implementation Details

For the JIRA parsing, you'll want something like:

```go
type JiraIssue struct {
    Type    string
    Key     string
    Summary string
    Status  string
}

func parseJiraList(output string) []JiraIssue {
    var issues []JiraIssue
    lines := strings.Split(output, "\n")
    
    for _, line := range lines[1:] { // Skip header
        if line = strings.TrimSpace(line); line != "" {
            fields := strings.Fields(line)
            if len(fields) >= 4 {
                issue := JiraIssue{
                    Type:    fields[0],
                    Key:     fields[1],
                    Summary: strings.Join(fields[2:len(fields)-1], " "),
                    Status:  fields[len(fields)-1],
                }
                issues = append(issues, issue)
            }
        }
    }
    return issues
}

func (j JiraIssue) BranchName() string {
    summary := strings.ReplaceAll(j.Summary, " ", "_")
    summary = strings.ReplaceAll(summary, "-", "_")
    return fmt.Sprintf("%s/%s_%s", strings.ToLower(j.Type), j.Key, summary)
}
```

## Recommended Combination

I'd suggest implementing **Approach 1 + Approach 2**: 
- Dynamic completions for great UX during typing
- Smart defaults so `gbm add INGSVC-5544` automatically generates the branch name
- Keep the `-b` flag for overrides

This gives you the best of both worlds - great discoverability through completions, but also quick usage for power users who know their JIRA keys.

Would you like me to elaborate on any of these approaches or help with the specific parsing logic?
</file>

<file path="docs/jira_prompt.md">
> how about a different approach. can we use carapace to create the dynamic completions instead? see
  docs/libs/carapace_docs/ for documentation if you need it.

> no. we are off. I want the prompt to be updated in realtime. like other shell completions. not just output
  to stdout.

> looks like you need to give the <worktree-name> when you use the -j flag. the user might not know what to
  call the worktree before checking the jira tickets. could we make it just `gbm add -j` when using that
  flag? and then dynamically create the worktree names after the jira ticket number (KEY)?

> read docs/spec.md docs/todo.md and docs/libs/jira-cli_readme.md. i think
  what we want is
  ```sh
  jira add -j
  ```
  that or (jira add --jira) should execute `jira issue list -a$(jira me) --plain` and that create a search with a select with the options being the output from the `jira issue list -a$(jira me) --plain`. using the search should filter rows out.




> how about a different approach. can we use carapace to create the dynamic completions instead? see
  docs/libs/carapace_docs/ for documentation if you need it.

> no. we are off. I want the prompt to be updated in realtime. like other shell completions. not just output
  to stdout.

> looks like you need to give the <worktree-name> when you use the -j flag. the user might not know what to
  call the worktree before checking the jira tickets. could we make it just `gbm add -j` when using that
  flag? and then dynamically create the worktree names after the jira ticket number (KEY)?

> read docs/spec.md docs/todo.md, docs/libs/charmbracelet_huh_readme.md and docs/libs/jira-cli_readme.md. i think
  what we want is
  ```sh
  jira add -j
  ```
  that or (jira add --jira) should execute `jira issue list -a$(jira me) --plain` and that create a search with a
  select with the options being the output from the `jira issue list -a$(jira me) --plain`. using the search should
  filter rows out.
</file>

<file path="internal/jira.go">
package internal

import (
	"fmt"
	"os/exec"
	"regexp"
	"strings"
)

// JiraIssue represents a JIRA issue with its key, type, summary, and status
type JiraIssue struct {
	Type    string
	Key     string
	Summary string
	Status  string
}

// IsJiraKey checks if a string matches the JIRA key pattern (PROJECT-NUMBER)
func IsJiraKey(s string) bool {
	matched, _ := regexp.MatchString(`^[A-Z]+-\d+$`, s)
	return matched
}

// GetJiraKeys fetches all JIRA issue keys for the current user
func GetJiraKeys() ([]string, error) {
	// Get current user first
	meCmd := exec.Command("jira", "me")
	userOutput, err := meCmd.Output()
	if err != nil {
		return nil, fmt.Errorf("failed to get current JIRA user: %w", err)
	}
	user := strings.TrimSpace(string(userOutput))

	// Now list issues for the user
	cmd := exec.Command("jira", "issue", "list", "-a"+user, "--plain")
	output, err := cmd.Output()
	if err != nil {
		return nil, fmt.Errorf("failed to fetch JIRA issues: %w", err)
	}

	var keys []string
	lines := strings.Split(string(output), "\n")
	for _, line := range lines[1:] { // Skip header
		if line = strings.TrimSpace(line); line != "" {
			fields := strings.Split(line, "\t")
			// Find the field that matches JIRA key pattern
			for _, field := range fields {
				trimmedField := strings.TrimSpace(field)
				if IsJiraKey(trimmedField) {
					keys = append(keys, trimmedField)
					break // Only take the first JIRA key found in this line
				}
			}
		}
	}
	return keys, nil
}

// GetJiraIssues fetches all JIRA issues for the current user with full details
func GetJiraIssues() ([]JiraIssue, error) {
	// Get current user first
	meCmd := exec.Command("jira", "me")
	userOutput, err := meCmd.Output()
	if err != nil {
		return nil, fmt.Errorf("failed to get current JIRA user: %w", err)
	}
	user := strings.TrimSpace(string(userOutput))

	// Now list issues for the user
	cmd := exec.Command("jira", "issue", "list", "-a"+user, "--plain")
	output, err := cmd.Output()
	if err != nil {
		return nil, fmt.Errorf("failed to fetch JIRA issues: %w", err)
	}

	return ParseJiraList(string(output)), nil
}

// GetJiraIssue fetches detailed information for a specific JIRA issue
func GetJiraIssue(key string) (*JiraIssue, error) {
	// Get current user first
	meCmd := exec.Command("jira", "me")
	userOutput, err := meCmd.Output()
	if err != nil {
		return nil, fmt.Errorf("failed to get current JIRA user: %w", err)
	}
	user := strings.TrimSpace(string(userOutput))

	// Get the issue from the list command
	cmd := exec.Command("jira", "issue", "list", "-a"+user, "--plain")
	output, err := cmd.Output()
	if err != nil {
		return nil, fmt.Errorf("failed to fetch JIRA issues: %w", err)
	}

	// Parse the list output to find our specific issue
	lines := strings.Split(string(output), "\n")
	for _, line := range lines[1:] { // Skip header
		if line = strings.TrimSpace(line); line != "" {
			fields := strings.Split(line, "\t")
			if len(fields) >= 3 {
				// Find the JIRA key in this line
				var issueKey, issueType, summary, status string
				keyIndex := -1

				for i, field := range fields {
					trimmedField := strings.TrimSpace(field)
					if IsJiraKey(trimmedField) {
						issueKey = trimmedField
						keyIndex = i
						break
					}
				}

				if issueKey == key {
					// Type is usually the first field
					issueType = strings.TrimSpace(fields[0])

					// Summary is usually the field after the key
					if keyIndex+1 < len(fields) {
						summary = strings.TrimSpace(fields[keyIndex+1])
					}

					// Status is the last non-empty field
					for i := len(fields) - 1; i >= 0; i-- {
						if trimmed := strings.TrimSpace(fields[i]); trimmed != "" {
							status = trimmed
							break
						}
					}

					return &JiraIssue{
						Type:    issueType,
						Key:     issueKey,
						Summary: summary,
						Status:  status,
					}, nil
				}
			}
		}
	}

	return nil, fmt.Errorf("JIRA issue %s not found in your assigned issues", key)
}

// ParseJiraList parses the output of 'jira issue list' command
func ParseJiraList(output string) []JiraIssue {
	var issues []JiraIssue
	lines := strings.Split(output, "\n")

	for _, line := range lines[1:] { // Skip header
		if line = strings.TrimSpace(line); line != "" {
			fields := strings.Split(line, "\t")
			if len(fields) >= 3 {
				// Find the JIRA key in this line
				var issueKey, issueType, summary, status string
				keyIndex := -1

				for i, field := range fields {
					trimmedField := strings.TrimSpace(field)
					if IsJiraKey(trimmedField) {
						issueKey = trimmedField
						keyIndex = i
						break
					}
				}

				if issueKey != "" {
					// Type is usually the first field
					issueType = strings.TrimSpace(fields[0])

					// Summary is usually the field after the key
					if keyIndex+1 < len(fields) {
						summary = strings.TrimSpace(fields[keyIndex+1])
					}

					// Status is the last non-empty field
					for i := len(fields) - 1; i >= 0; i-- {
						if trimmed := strings.TrimSpace(fields[i]); trimmed != "" {
							status = trimmed
							break
						}
					}

					issue := JiraIssue{
						Type:    issueType,
						Key:     issueKey,
						Summary: summary,
						Status:  status,
					}
					issues = append(issues, issue)
				}
			}
		}
	}
	return issues
}

// BranchName generates a branch name from a JIRA issue
func (j *JiraIssue) BranchName() string {
	summary := strings.ReplaceAll(j.Summary, " ", "_")
	summary = strings.ReplaceAll(summary, "-", "_")
	// Remove special characters and make it filesystem-safe
	summary = regexp.MustCompile(`[^a-zA-Z0-9_]`).ReplaceAllString(summary, "_")
	// Clean up multiple underscores
	summary = regexp.MustCompile(`_+`).ReplaceAllString(summary, "_")
	summary = strings.Trim(summary, "_")

	issueType := strings.ToLower(j.Type)
	if issueType == "story" || issueType == "improvement" {
		issueType = "feature"
	}

	return fmt.Sprintf("%s/%s_%s", issueType, j.Key, summary)
}

// GenerateBranchFromJira fetches a JIRA issue and generates a branch name
func GenerateBranchFromJira(jiraKey string) (string, error) {
	issue, err := GetJiraIssue(jiraKey)
	if err != nil {
		return "", err
	}

	return issue.BranchName(), nil
}
</file>

<file path="tools/strip-whitespace.sh">
#!/bin/bash

# Strip trailing whitespace from a file
# Usage: strip-whitespace.sh <file>

set -euo pipefail

if [ $# -ne 1 ]; then
    echo "Usage: $0 <file>" >&2
    exit 1
fi

file="$1"

if [ ! -f "$file" ]; then
    echo "Error: File '$file' not found" >&2
    exit 1
fi

# Strip trailing whitespace and tabs from each line
# Handle macOS vs Linux sed differences
if [[ "$OSTYPE" == "darwin"* ]]; then
    # macOS requires empty string after -i
    sed -i '' 's/[[:space:]]*$//' "$file"
else
    # Linux sed
    sed -i 's/[[:space:]]*$//' "$file"
fi

echo "Stripped trailing whitespace from: $file"
</file>

<file path="ttemp/example_config.toml">
# Git Branch Manager (gbm) Configuration File
# This file should be placed in .gbm/config.toml in your repository root

[settings]
# Directory name for worktrees (relative to repository root)
worktree_prefix = "worktrees"

# Automatically fetch remote branches before operations
auto_fetch = true

# Create missing branches if they don't exist locally or remotely
create_missing_branches = false

[state]
# Last synchronization timestamp (automatically managed)
last_sync = "2024-01-01T00:00:00Z"

# Environment variables being tracked (automatically managed)
tracked_vars = []

[icons]
# Status Icons - Used throughout the CLI for various status indicators
success = "✅"      # Successful operations, valid states
warning = "⚠️"       # Out of sync, needs attention
error = "❌"        # Errors, missing items, validation failures
info = "💡"         # Information, tips, suggestions
orphaned = "🗑️"     # Orphaned worktrees to be cleaned up
dry_run = "🔍"      # Dry run mode indicator
missing = "📁"      # Missing worktrees that need to be created
changes = "🔄"      # Branch changes that need synchronization

# Git Status Icons - Used for git repository state indicators
git_clean = "✓"     # Clean working directory, no changes
git_dirty = "~"     # Dirty working directory, uncommitted changes
git_ahead = "↑"     # Local branch ahead of remote
git_behind = "↓"    # Local branch behind remote
git_diverged = "⇕"  # Local and remote have diverged
git_unknown = "?"   # Unknown git status

# Alternative Icon Sets (uncomment to use):

# Minimal ASCII Icons
# success = "[OK]"
# warning = "[!]"
# error = "[X]"
# info = "[i]"
# orphaned = "[DEL]"
# dry_run = "[DRY]"
# missing = "[ADD]"
# changes = "[CHG]"
# git_clean = "+"
# git_dirty = "*"
# git_ahead = "^"
# git_behind = "v"
# git_diverged = "<>"
# git_unknown = "?"

# Nerdfont Icons (requires a Nerdfont)
# success = ""
# warning = ""
# error = ""
# info = ""
# orphaned = ""
# dry_run = ""
# missing = ""
# changes = ""
# git_clean = ""
# git_dirty = ""
# git_ahead = ""
# git_behind = ""
# git_diverged = ""
# git_unknown = ""

# Simple Text Icons
# success = "PASS"
# warning = "WARN"
# error = "FAIL"
# info = "INFO"
# orphaned = "REMOVE"
# dry_run = "PREVIEW"
# missing = "CREATE"
# changes = "UPDATE"
# git_clean = "CLEAN"
# git_dirty = "DIRTY"
# git_ahead = "AHEAD"
# git_behind = "BEHIND"
# git_diverged = "DIVERGED"
# git_unknown = "UNKNOWN"
</file>

<file path=".envrc.example">
# Example .envrc file for gbm (Git Branch Manager)
# Each environment variable maps to a specific branch

# Long-living environment branches
PROD=production/2025-05-1
PREVIEW=production/2025-06-1
MAIN=master
STAGING=feature/new-api

# Development branches
DEV=develop
HOTFIX=hotfix/urgent-fix

# Feature branches
NEW_FEATURE=feature/user-auth
API_UPDATE=feature/api-v2
</file>

<file path="cmd/clone.go">
package cmd

import (
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strings"

	"github.com/spf13/cobra"
)

var cloneCmd = &cobra.Command{
	Use:   "clone <repository-url>",
	Short: "Clone a repository as a bare repo and create the main worktree",
	Long: `Clone a repository as a bare repository and create the main worktree
using the HEAD branch. This sets up the repository structure for
worktree-based development.`,
	Args: cobra.ExactArgs(1),
	RunE: func(cmd *cobra.Command, args []string) error {
		repoUrl := args[0]

		// Extract repository name from URL
		repoName := extractRepoName(repoUrl)
		bareRepoPath := repoName + ".git"

		PrintInfo("Cloning repository as bare...")
		if err := cloneBareRepo(repoUrl, bareRepoPath); err != nil {
			return fmt.Errorf("failed to clone bare repository: %w", err)
		}

		PrintInfo("Creating main worktree...")
		mainWorktreePath := filepath.Join(bareRepoPath, "worktrees", "MAIN")
		if err := createMainWorktree(bareRepoPath, mainWorktreePath); err != nil {
			return fmt.Errorf("failed to create main worktree: %w", err)
		}

		PrintInfo("Checking for .envrc file...")
		envrcPath := filepath.Join(mainWorktreePath, ".envrc")
		if _, err := os.Stat(envrcPath); err == nil {
			PrintInfo("Found .envrc file in main worktree")
			// Copy .envrc to repository root for reference
			repoEnvrcPath := filepath.Join(bareRepoPath, ".envrc")
			if err := copyFile(envrcPath, repoEnvrcPath); err != nil {
				PrintError("Failed to copy .envrc to repository root: %v", err)
			} else {
				PrintInfo("Copied .envrc to repository root")
			}
		} else {
			PrintInfo("No .envrc file found in main worktree")
			PrintInfo("Consider creating a .envrc file to define environment variables for your worktrees")
			PrintInfo("You can generate one based on the initial worktree structure")
		}

		PrintInfo("Repository cloned successfully!")
		PrintInfo("Bare repository: %s", bareRepoPath)
		PrintInfo("Main worktree: %s", mainWorktreePath)

		return nil
	},
}

func extractRepoName(repoUrl string) string {
	// Remove .git suffix if present
	url := strings.TrimSuffix(repoUrl, ".git")

	// Extract the last part of the URL (repository name)
	parts := strings.Split(url, "/")
	if len(parts) > 0 {
		return parts[len(parts)-1]
	}

	return "repository"
}

func cloneBareRepo(repoUrl, bareRepoPath string) error {
	cmd := exec.Command("git", "clone", "--bare", repoUrl, bareRepoPath)
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr

	return cmd.Run()
}

func createMainWorktree(bareRepoPath, mainWorktreePath string) error {
	// Create worktrees directory
	worktreesDir := filepath.Dir(mainWorktreePath)
	if err := os.MkdirAll(worktreesDir, 0755); err != nil {
		return fmt.Errorf("failed to create worktrees directory: %w", err)
	}

	// Get the default branch (HEAD)
	cmd := exec.Command("git", "symbolic-ref", "refs/remotes/origin/HEAD")
	cmd.Dir = bareRepoPath
	output, err := cmd.Output()
	if err != nil {
		// Fallback to main/master detection
		cmd = exec.Command("git", "branch", "-r")
		cmd.Dir = bareRepoPath
		output, err = cmd.Output()
		if err != nil {
			return fmt.Errorf("failed to get remote branches: %w", err)
		}

		branches := strings.Split(string(output), "\n")
		var defaultBranch string
		for _, branch := range branches {
			branch = strings.TrimSpace(branch)
			if strings.Contains(branch, "origin/main") {
				defaultBranch = "main"
				break
			} else if strings.Contains(branch, "origin/master") {
				defaultBranch = "master"
				break
			}
		}

		if defaultBranch == "" {
			return fmt.Errorf("could not determine default branch")
		}

		// Create worktree with the detected default branch
		cmd = exec.Command("git", "worktree", "add", mainWorktreePath, defaultBranch)
	} else {
		// Extract branch name from refs/remotes/origin/HEAD -> refs/remotes/origin/main
		refPath := strings.TrimSpace(string(output))
		branchName := strings.TrimPrefix(refPath, "refs/remotes/origin/")

		// Create worktree with the HEAD branch
		cmd = exec.Command("git", "worktree", "add", mainWorktreePath, branchName)
	}

	cmd.Dir = bareRepoPath
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr

	return cmd.Run()
}

func copyFile(src, dst string) error {
	srcFile, err := os.Open(src)
	if err != nil {
		return err
	}
	defer srcFile.Close()

	dstFile, err := os.Create(dst)
	if err != nil {
		return err
	}
	defer dstFile.Close()

	_, err = srcFile.WriteTo(dstFile)
	return err
}

func init() {
	rootCmd.AddCommand(cloneCmd)
}
</file>

<file path="cmd/pull.go">
package cmd

import (
	"fmt"
	"os"

	"gbm/internal"

	"github.com/spf13/cobra"
)

var (
	pullAll bool
)

var pullCmd = &cobra.Command{
	Use:   "pull [worktree-name]",
	Short: "Pull worktree changes from remote",
	Long: `Pull changes from the remote repository to a worktree.

Usage:
  gbm pull                    # Pull current worktree (if in a worktree)
  gbm pull <worktree-name>    # Pull specific worktree
  gbm pull --all              # Pull all worktrees`,
	Args: cobra.MaximumNArgs(1),
	RunE: func(cmd *cobra.Command, args []string) error {
		wd, err := os.Getwd()
		if err != nil {
			return fmt.Errorf("failed to get working directory: %w", err)
		}

		repoPath, err := internal.FindGitRoot(wd)
		if err != nil {
			return fmt.Errorf("not in a git repository: %w", err)
		}

		manager, err := internal.NewManager(repoPath)
		if err != nil {
			return fmt.Errorf("failed to create manager: %w", err)
		}

		if pullAll {
			return handlePullAll(manager)
		}

		if len(args) == 0 {
			return handlePullCurrent(manager, wd)
		}

		return handlePullNamed(manager, args[0])
	},
}

func handlePullAll(manager *internal.Manager) error {
	PrintInfo("Pulling all worktrees...")
	return manager.PullAllWorktrees()
}

func handlePullCurrent(manager *internal.Manager, currentPath string) error {
	// Check if we're in a worktree
	inWorktree, worktreeName, err := manager.IsInWorktree(currentPath)
	if err != nil {
		return fmt.Errorf("failed to check if in worktree: %w", err)
	}

	if !inWorktree {
		return fmt.Errorf("not currently in a worktree. Use 'gbm pull <worktree-name>' to pull a specific worktree")
	}

	PrintInfo("Pulling current worktree '%s'...", worktreeName)
	return manager.PullWorktree(worktreeName)
}

func handlePullNamed(manager *internal.Manager, worktreeName string) error {
	// Check if worktree exists
	worktrees, err := manager.GetAllWorktrees()
	if err != nil {
		return fmt.Errorf("failed to get worktrees: %w", err)
	}

	if _, exists := worktrees[worktreeName]; !exists {
		return fmt.Errorf("worktree '%s' does not exist", worktreeName)
	}

	PrintInfo("Pulling worktree '%s'...", worktreeName)
	return manager.PullWorktree(worktreeName)
}

func init() {
	rootCmd.AddCommand(pullCmd)
	pullCmd.Flags().BoolVar(&pullAll, "all", false, "Pull all worktrees")

	// Add completion for worktree names
	pullCmd.ValidArgsFunction = func(cmd *cobra.Command, args []string, toComplete string) ([]string, cobra.ShellCompDirective) {
		if len(args) != 0 {
			return nil, cobra.ShellCompDirectiveNoFileComp
		}
		return getWorktreeNames(), cobra.ShellCompDirectiveNoFileComp
	}
}
</file>

<file path="cmd/push.go">
package cmd

import (
	"fmt"
	"os"

	"gbm/internal"

	"github.com/spf13/cobra"
)

var (
	pushAll bool
)

var pushCmd = &cobra.Command{
	Use:   "push [worktree-name]",
	Short: "Push worktree changes to remote",
	Long: `Push changes from a worktree to the remote repository.

Usage:
  gbm push                    # Push current worktree (if in a worktree)
  gbm push <worktree-name>    # Push specific worktree
  gbm push --all              # Push all worktrees

The command will automatically set upstream (-u) if not already set.`,
	Args: cobra.MaximumNArgs(1),
	RunE: func(cmd *cobra.Command, args []string) error {
		wd, err := os.Getwd()
		if err != nil {
			return fmt.Errorf("failed to get working directory: %w", err)
		}

		repoPath, err := internal.FindGitRoot(wd)
		if err != nil {
			return fmt.Errorf("not in a git repository: %w", err)
		}

		manager, err := internal.NewManager(repoPath)
		if err != nil {
			return fmt.Errorf("failed to create manager: %w", err)
		}

		if pushAll {
			return handlePushAll(manager)
		}

		if len(args) == 0 {
			return handlePushCurrent(manager, wd)
		}

		return handlePushNamed(manager, args[0])
	},
}

func handlePushAll(manager *internal.Manager) error {
	PrintInfo("Pushing all worktrees...")
	return manager.PushAllWorktrees()
}

func handlePushCurrent(manager *internal.Manager, currentPath string) error {
	// Check if we're in a worktree
	inWorktree, worktreeName, err := manager.IsInWorktree(currentPath)
	if err != nil {
		return fmt.Errorf("failed to check if in worktree: %w", err)
	}

	if !inWorktree {
		return fmt.Errorf("not currently in a worktree. Use 'gbm push <worktree-name>' to push a specific worktree")
	}

	PrintInfo("Pushing current worktree '%s'...", worktreeName)
	return manager.PushWorktree(worktreeName)
}

func handlePushNamed(manager *internal.Manager, worktreeName string) error {
	// Check if worktree exists
	worktrees, err := manager.GetAllWorktrees()
	if err != nil {
		return fmt.Errorf("failed to get worktrees: %w", err)
	}

	if _, exists := worktrees[worktreeName]; !exists {
		return fmt.Errorf("worktree '%s' does not exist", worktreeName)
	}

	PrintInfo("Pushing worktree '%s'...", worktreeName)
	return manager.PushWorktree(worktreeName)
}

func init() {
	rootCmd.AddCommand(pushCmd)
	pushCmd.Flags().BoolVar(&pushAll, "all", false, "Push all worktrees")

	// Add completion for worktree names
	pushCmd.ValidArgsFunction = func(cmd *cobra.Command, args []string, toComplete string) ([]string, cobra.ShellCompDirective) {
		if len(args) != 0 {
			return nil, cobra.ShellCompDirectiveNoFileComp
		}
		return getWorktreeNames(), cobra.ShellCompDirectiveNoFileComp
	}
}
</file>

<file path="docs/spec.md">
# Git Branch Manager CLI Design Specification

## Overview

A command-line tool that manages Git repository branches and worktrees based on environment variables defined in a `.envrc` file. The tool synchronizes local worktrees with branch definitions and provides notifications when configurations drift out of sync.

## Core Concept

The `.envrc` file serves as the source of truth for branch management, where each environment variable maps to a specific branch:

```bash
PROD=production/2025-05-1
PREVIEW=production/2025-06-1
MAIN=master
STAGING=feature/new-api
```

## Command Structure

### Primary Commands

**`gbm init`**
- Initializes the current Git repository for branch management
- Creates initial worktree structure based on `.envrc`
- Validates that the repository is a valid Git repo
- Creates `.gbm/` directory for metadata storage

**`gbm sync`**
- Synchronizes all worktrees with current `.envrc` definitions
- Creates missing worktrees for new environment variables
- Updates existing worktrees if branch references have changed
- Removes orphaned worktrees (no longer in `.envrc`)

**`gbm status`**
- Shows current sync status between `.envrc` and actual worktrees
- Displays which branches are out of sync
- Lists missing worktrees
- Shows orphaned worktrees

**`gbm check`**
- Runs automatically on shell prompt or can be called manually
- Quick check for drift between `.envrc` and worktrees
- Returns non-zero exit code if out of sync (useful for shell integration)

### Utility Commands

**`gbm list`**
- Lists all managed worktrees and their status
- Shows environment variable mappings
- Indicates sync status for each entry

**`gbm clean`**
- Removes orphaned worktrees (interactive by default)
- Option for force removal with `--force`

**`gbm validate`**
- Validates `.envrc` syntax and branch references
- Checks if referenced branches exist locally or remotely

## Configuration File Structure

**`.envrc`** - Primary configuration
```bash
# Long-living environment branches
PROD=production/2025-05-1
PREVIEW=production/2025-06-1
MAIN=master
STAGING=feature/new-api
```

**`.gbm/config.toml`** - Tool metadata (created automatically)
```toml
[settings]
worktree_prefix = "worktrees"
auto_fetch = true
create_missing_branches = false

[state]
last_sync = "2025-07-01T10:30:00Z"
tracked_vars = ["PROD", "PREVIEW", "MAIN", "STAGING"]
```

## Worktree Management

### Directory Structure
```
project-root/
├── .git/
├── .envrc
├── .gbm/
│   └── config.toml
├── worktrees/
│   ├── PROD/           # Contains production/2025-05-1 branch
│   ├── PREVIEW/        # Contains production/2025-06-1 branch
│   ├── MAIN/           # Contains master branch
│   └── STAGING/        # Contains feature/new-api branch
└── main-workspace/     # Original repository workspace
```

### Worktree Naming
- Worktrees are named after the environment variable (e.g., `PROD`, `PREVIEW`)
- Stored in `worktrees/` subdirectory by default
- Configurable via `.gbm/config.toml`

## Sync Detection and Notification

### Automatic Checking
Integration with shell prompt to show sync status:
```bash
# Example shell integration
export PS1="$(gbm check --format=prompt)$PS1"
```

### Sync Status Indicators
- ✅ All worktrees in sync
- ⚠️  Some worktrees out of sync
- ❌ Major configuration drift detected
- 🔄 Sync in progress

### Interactive Sync Resolution
When drift is detected, prompt user with options:
```
⚠️  Configuration drift detected:

Changes needed:
  • PROD: production/2025-05-1 → production/2025-07-1 (branch changed)
  • STAGING: worktree missing (new environment variable)
  • OLD_FEATURE: orphaned worktree (variable removed)

Actions:
  [s] Sync all changes
  [r] Review changes individually
  [i] Ignore for this session
  [q] Quit
```

## Command-Line Interface

### Flags and Options

**Global Flags:**
- `--config, -c`: Specify custom `.envrc` path
- `--worktree-dir, -w`: Override worktree directory location
- `--verbose, -v`: Enable verbose output
- `--quiet, -q`: Suppress non-error output

**Command-Specific Options:**

`gbm init`:
- `--force`: Initialize even if worktrees already exist
- `--fetch`: Fetch remote branches during initialization

`gbm sync`:
- `--dry-run`: Show what would be changed without making changes
- `--force`: Skip confirmation prompts
- `--fetch`: Update remote tracking before sync

`gbm check`:
- `--format=prompt|json|text`: Output format for integration
- `--exit-code`: Return status code only

## Error Handling

### Common Error Scenarios
1. **Not a Git repository**: Clear error message with suggestion to run `git init`
2. **Missing `.envrc`**: Prompt to create one or specify path
3. **Invalid branch references**: List invalid branches and suggest alternatives
4. **Permission issues**: Clear guidance on directory permissions
5. **Conflicting worktrees**: Handle existing worktree conflicts gracefully

### Recovery Mechanisms
- Backup worktree state before major operations
- Rollback capability for failed sync operations
- Repair mode for corrupted `.gbm/` metadata

## Integration Points

### Shell Integration
```bash
# Add to .bashrc/.zshrc for automatic checking
eval "$(gbm shell-integration)"
```

### Git Hooks Integration
- Optional pre-commit hook to validate `.envrc` changes
- Post-merge hook to check for sync requirements

### CI/CD Integration
- `gbm validate` can be used in CI pipelines
- JSON output format for programmatic consumption

## Implementation Considerations

### Dependencies
- Standard library only where possible
- Git command-line tool (shell out to `git` commands)
- TOML parsing library for configuration

### Performance
- Lazy loading of Git repository state
- Caching of branch existence checks
- Minimal filesystem operations during status checks

### Cross-Platform Support
- Windows, macOS, and Linux compatibility
- Handle path separators and permissions appropriately
- Shell integration for major shells (bash, zsh, fish)

## Future Enhancements

- **Remote branch creation**: Option to create missing branches remotely
- **Template support**: Branch naming templates and conventions
- **Multi-repository support**: Manage multiple repositories from single config
- **Plugin system**: Custom sync behaviors and integrations
- **Web interface**: Optional local web UI for visual management
</file>

<file path="internal/styles.go">
package internal

import (
	"github.com/charmbracelet/lipgloss"
)

// Global icon manager instance
var globalIconManager *IconManager

// IconManager manages configurable icons
type IconManager struct {
	config *Config
}

// NewIconManager creates a new icon manager with configuration
func NewIconManager(config *Config) *IconManager {
	return &IconManager{config: config}
}

// SetGlobalIconManager sets the global icon manager instance
func SetGlobalIconManager(manager *IconManager) {
	globalIconManager = manager
}

// GetGlobalIconManager returns the global icon manager instance
func GetGlobalIconManager() *IconManager {
	if globalIconManager == nil {
		// Return a default manager if none is set
		return NewIconManager(DefaultConfig())
	}
	return globalIconManager
}

// Icon getter methods
func (im *IconManager) Success() string     { return im.config.Icons.Success }
func (im *IconManager) Warning() string     { return im.config.Icons.Warning }
func (im *IconManager) Error() string       { return im.config.Icons.Error }
func (im *IconManager) Info() string        { return im.config.Icons.Info }
func (im *IconManager) Orphaned() string    { return im.config.Icons.Orphaned }
func (im *IconManager) DryRun() string      { return im.config.Icons.DryRun }
func (im *IconManager) Missing() string     { return im.config.Icons.Missing }
func (im *IconManager) Changes() string     { return im.config.Icons.Changes }
func (im *IconManager) GitClean() string    { return im.config.Icons.GitClean }
func (im *IconManager) GitDirty() string    { return im.config.Icons.GitDirty }
func (im *IconManager) GitAhead() string    { return im.config.Icons.GitAhead }
func (im *IconManager) GitBehind() string   { return im.config.Icons.GitBehind }
func (im *IconManager) GitDiverged() string { return im.config.Icons.GitDiverged }
func (im *IconManager) GitUnknown() string  { return im.config.Icons.GitUnknown }

var (
	// Colors
	primaryColor = lipgloss.Color("#7D56F4")
	successColor = lipgloss.Color("#04B575")
	warningColor = lipgloss.Color("#F59E0B")
	errorColor   = lipgloss.Color("#EF4444")
	infoColor    = lipgloss.Color("#3B82F6")
	subtleColor  = lipgloss.Color("#6B7280")

	// Base styles
	BaseStyle = lipgloss.NewStyle().
			MarginLeft(0).
			MarginRight(0)

	// Header styles
	HeaderStyle = lipgloss.NewStyle().
			Bold(true).
			Foreground(primaryColor).
			MarginBottom(1)

	SubHeaderStyle = lipgloss.NewStyle().
			Bold(true).
			Foreground(subtleColor)

	// Status styles
	SuccessStyle = lipgloss.NewStyle().
			Foreground(successColor).
			Bold(true)

	WarningStyle = lipgloss.NewStyle().
			Foreground(warningColor).
			Bold(true)

	ErrorStyle = lipgloss.NewStyle().
			Foreground(errorColor).
			Bold(true)

	InfoStyle = lipgloss.NewStyle().
			Foreground(infoColor)

	// Table styles
	TableHeaderStyle = lipgloss.NewStyle().
				Bold(true).
				Foreground(primaryColor).
				Align(lipgloss.Center)

	TableCellStyle = lipgloss.NewStyle().
			Padding(0, 1).
			Align(lipgloss.Left)

	TableBorderStyle = lipgloss.NewStyle().
				Foreground(subtleColor)

	// Status icon styles
	StatusOKStyle = lipgloss.NewStyle().
			Foreground(successColor)

	StatusWarningStyle = lipgloss.NewStyle().
				Foreground(warningColor)

	StatusErrorStyle = lipgloss.NewStyle().
				Foreground(errorColor)

	StatusInfoStyle = lipgloss.NewStyle().
			Foreground(infoColor)

	// Utility styles
	BoldStyle = lipgloss.NewStyle().
			Bold(true)

	SubtleStyle = lipgloss.NewStyle().
			Foreground(subtleColor)

	// Message styles
	VerboseStyle = lipgloss.NewStyle().
			Foreground(subtleColor).
			Italic(true)

	PromptStyle = lipgloss.NewStyle().
			Foreground(primaryColor).
			Bold(true)
)

func FormatVerbose(text string) string {
	return VerboseStyle.Render(text)
}

func FormatHeader(text string) string {
	return HeaderStyle.Render(text)
}

func FormatSubHeader(text string) string {
	return SubHeaderStyle.Render(text)
}

func FormatBold(text string) string {
	return BoldStyle.Render(text)
}

func FormatSubtle(text string) string {
	return SubtleStyle.Render(text)
}

func FormatPrompt(text string) string {
	return PromptStyle.Render(text)
}

// Status icon formatting with consistent styling
func FormatStatusIcon(icon, text string) string {
	iconManager := GetGlobalIconManager()

	switch icon {
	case iconManager.Success():
		return StatusOKStyle.Render(icon) + " " + text
	case iconManager.Warning():
		return StatusWarningStyle.Render(icon) + " " + text
	case iconManager.Error():
		return StatusErrorStyle.Render(icon) + " " + text
	case iconManager.Orphaned():
		return StatusErrorStyle.Render(icon) + " " + text
	case iconManager.Info():
		return StatusInfoStyle.Render(icon) + " " + text
	case iconManager.DryRun():
		return StatusInfoStyle.Render(icon) + " " + text
	case iconManager.Missing():
		return StatusWarningStyle.Render(icon) + " " + text
	case iconManager.Changes():
		return StatusWarningStyle.Render(icon) + " " + text
	default:
		return icon + " " + text
	}
}

// Helper functions for common icons
func FormatSuccess(text string) string {
	iconManager := GetGlobalIconManager()
	return FormatStatusIcon(iconManager.Success(), text)
}

func FormatWarning(text string) string {
	iconManager := GetGlobalIconManager()
	return FormatStatusIcon(iconManager.Warning(), text)
}

func FormatError(text string) string {
	iconManager := GetGlobalIconManager()
	return FormatStatusIcon(iconManager.Error(), text)
}

func FormatInfo(text string) string {
	iconManager := GetGlobalIconManager()
	return FormatStatusIcon(iconManager.Info(), text)
}

// Git status formatting
func FormatGitStatus(status *GitStatus) string {
	iconManager := GetGlobalIconManager()

	if status == nil {
		return StatusInfoStyle.Render(iconManager.GitUnknown())
	}

	if status.IsDirty {
		return StatusWarningStyle.Render(iconManager.GitDirty())
	}

	if status.Ahead > 0 && status.Behind > 0 {
		return StatusErrorStyle.Render(iconManager.GitDiverged())
	}

	if status.Ahead > 0 {
		return StatusInfoStyle.Render(iconManager.GitAhead())
	}

	if status.Behind > 0 {
		return StatusWarningStyle.Render(iconManager.GitBehind())
	}

	return StatusOKStyle.Render(iconManager.GitClean())
}
</file>

<file path="CLAUDE.md">
# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Current State

This repository is in its initial state with minimal structure:
- `docs/spec.md` - Empty specification file

## Architecture

The repository appears to be intended for a worktree manager tool based on the name, but no implementation exists yet.

## Development Setup

No build system, dependencies, or development tooling has been configured yet. When development begins, standard practices should be established for the chosen technology stack.
</file>

<file path="go.mod">
module gbm

go 1.24.4

require (
	github.com/BurntSushi/toml v1.5.0
	github.com/charmbracelet/bubbletea v1.3.5
	github.com/go-git/go-git/v5 v5.16.2
	github.com/spf13/cobra v1.9.1
)

require (
	dario.cat/mergo v1.0.0 // indirect
	github.com/Microsoft/go-winio v0.6.2 // indirect
	github.com/ProtonMail/go-crypto v1.1.6 // indirect
	github.com/aymanbagabas/go-osc52/v2 v2.0.1 // indirect
	github.com/charmbracelet/colorprofile v0.2.3-0.20250311203215-f60798e515dc // indirect
	github.com/charmbracelet/lipgloss v1.1.0 // indirect
	github.com/charmbracelet/x/ansi v0.8.0 // indirect
	github.com/charmbracelet/x/cellbuf v0.0.13-0.20250311204145-2c3ea96c31dd // indirect
	github.com/charmbracelet/x/term v0.2.1 // indirect
	github.com/cloudflare/circl v1.6.1 // indirect
	github.com/cyphar/filepath-securejoin v0.4.1 // indirect
	github.com/emirpasic/gods v1.18.1 // indirect
	github.com/erikgeiser/coninput v0.0.0-20211004153227-1c3628e74d0f // indirect
	github.com/go-git/gcfg v1.5.1-0.20230307220236-3a3c6141e376 // indirect
	github.com/go-git/go-billy/v5 v5.6.2 // indirect
	github.com/golang/groupcache v0.0.0-20241129210726-2c02b8208cf8 // indirect
	github.com/inconshreveable/mousetrap v1.1.0 // indirect
	github.com/jbenet/go-context v0.0.0-20150711004518-d14ea06fba99 // indirect
	github.com/kevinburke/ssh_config v1.2.0 // indirect
	github.com/lucasb-eyer/go-colorful v1.2.0 // indirect
	github.com/mattn/go-isatty v0.0.20 // indirect
	github.com/mattn/go-localereader v0.0.1 // indirect
	github.com/mattn/go-runewidth v0.0.16 // indirect
	github.com/muesli/ansi v0.0.0-20230316100256-276c6243b2f6 // indirect
	github.com/muesli/cancelreader v0.2.2 // indirect
	github.com/muesli/termenv v0.16.0 // indirect
	github.com/pjbgf/sha1cd v0.3.2 // indirect
	github.com/rivo/uniseg v0.4.7 // indirect
	github.com/sergi/go-diff v1.3.2-0.20230802210424-5b0b94c5c0d3 // indirect
	github.com/skeema/knownhosts v1.3.1 // indirect
	github.com/spf13/pflag v1.0.6 // indirect
	github.com/xanzy/ssh-agent v0.3.3 // indirect
	github.com/xo/terminfo v0.0.0-20220910002029-abceb7e1c41e // indirect
	golang.org/x/crypto v0.37.0 // indirect
	golang.org/x/net v0.39.0 // indirect
	golang.org/x/sync v0.13.0 // indirect
	golang.org/x/sys v0.32.0 // indirect
	golang.org/x/text v0.24.0 // indirect
	gopkg.in/warnings.v0 v0.1.2 // indirect
)
</file>

<file path="cmd/completion.go">
package cmd

import (
	"os"

	"github.com/spf13/cobra"
)

var completionCmd = &cobra.Command{
	Use:   "completion [bash|zsh|fish|powershell]",
	Short: "Generate completion script",
	Long: `Generate completion script for your shell.

To load completions:

Bash:
  source <(gbm completion bash)

  # To load completions for each session, execute once:
  # Linux:
  gbm completion bash > /etc/bash_completion.d/gbm
  # macOS:
  gbm completion bash > /usr/local/etc/bash_completion.d/gbm

Zsh:
  # If shell completion is not already enabled in your environment,
  # you will need to enable it. You can execute the following once:
  echo "autoload -U compinit; compinit" >> ~/.zshrc

  # To load completions for each session, execute once:
  gbm completion zsh > "${fpath[1]}/_gbm"

  # You will need to start a new shell for this setup to take effect.

fish:
  gbm completion fish | source

  # To load completions for each session, execute once:
  gbm completion fish > ~/.config/fish/completions/gbm.fish

PowerShell:
  gbm completion powershell | Out-String | Invoke-Expression

  # To load completions for every new session, run:
  gbm completion powershell > gbm.ps1
  # and source this file from your PowerShell profile.
`,
	DisableFlagsInUseLine: true,
	ValidArgs:             []string{"bash", "zsh", "fish", "powershell"},
	Args:                  cobra.MatchAll(cobra.ExactArgs(1), cobra.OnlyValidArgs),
	RunE: func(cmd *cobra.Command, args []string) error {
		switch args[0] {
		case "bash":
			return cmd.Root().GenBashCompletion(os.Stdout)
		case "zsh":
			return cmd.Root().GenZshCompletion(os.Stdout)
		case "fish":
			return cmd.Root().GenFishCompletion(os.Stdout, true)
		case "powershell":
			return cmd.Root().GenPowerShellCompletion(os.Stdout)
		}
		return nil
	},
}

func init() {
	rootCmd.AddCommand(completionCmd)
}
</file>

<file path="main.go">
package main

import (
	"os"

	"gbm/cmd"
)

func main() {
	defer cmd.CloseLogFile()

	if err := cmd.Execute(); err != nil {
		cmd.PrintError("Error: %v", err)
		os.Exit(1)
	}
}
</file>

<file path="README.md">
# Git Branch Manager (gbm)

A command-line tool that manages Git repository branches and worktrees based on environment variables defined in a `.envrc` file. The tool synchronizes local worktrees with branch definitions and provides notifications when configurations drift out of sync.

## Installation

```bash
go build -o gbm
```

## Quick Start

1. Create a `.envrc` file in your Git repository:
```bash
PROD=production/2025-05-1
PREVIEW=production/2025-06-1
MAIN=master
STAGING=feature/new-api
```

2. Initialize gbm:
```bash
./gbm init
```

3. Check status:
```bash
./gbm status
```

4. Sync worktrees:
```bash
./gbm sync
```

## Commands

### Core Commands

- `gbm init` - Initialize the repository for branch management
- `gbm sync` - Synchronize worktrees with .envrc definitions
- `gbm status` - Show current sync status
- `gbm check` - Quick check for drift (useful for automation)

### Utility Commands

- `gbm list` - List all managed worktrees
- `gbm clean` - Remove orphaned worktrees
- `gbm validate` - Validate .envrc syntax and branch references

### Ad-hoc Worktree Management

- `gbm add <worktree-name> [branch-name]` - Add a new worktree
  - `gbm add feature-work existing-branch` - Create worktree on existing branch
  - `gbm add feature-work new-branch -b` - Create worktree with new branch
  - `gbm add feature-work --interactive` - Interactive branch selection

### JIRA Integration

The `add` command includes intelligent JIRA integration when the `jira` CLI is available:

#### Tab Completion
- **First tab**: Shows JIRA keys with issue summaries for context
- **Second tab**: Suggests branch names based on JIRA issue details

```bash
$ gbm add <TAB>
INGSVC-5544    Zoom Clips - New Integration
INGSVC-5581    MsSharepoint - Authentication Error
INGSVC-3663    MONDAY.COM: handle error response

$ gbm add INGSVC-5544 <TAB>
feature/INGSVC-5544_Zoom_Clips_New_Integration
```

#### Smart Branch Generation
- **Stories** and **Improvements** → `feature/` prefix
- **Bugs** → `bug/` prefix
- Summary text cleaned and formatted for branch names
- Special characters replaced with underscores

#### Workflow Examples
```bash
# Two-tab completion workflow
$ gbm add INGSV<TAB>                    # Complete to INGSVC-5544
$ gbm add INGSVC-5544 <TAB>             # Complete to branch name
$ gbm add INGSVC-5544 feature/INGSVC-5544_Zoom_Clips_New_Integration -b

# Smart suggestion workflow
$ gbm add INGSVC-5544
Error: branch name required. Suggested: feature/INGSVC-5544_Zoom_Clips_New_Integration

Try: gbm add INGSVC-5544 feature/INGSVC-5544_Zoom_Clips_New_Integration -b
```

#### Requirements
- `jira` CLI tool installed and authenticated
- Gracefully falls back to basic completion when JIRA unavailable

### Shell Integration

#### Status Checking
Add automatic checking to your shell:

```bash
# Add to .bashrc/.zshrc
eval "$(gbm shell-integration)"
```

#### Tab Completion
Enable tab completion for enhanced JIRA integration:

```bash
# Bash
gbm completion bash > /etc/bash_completion.d/gbm
# Or for current session: source <(gbm completion bash)

# Zsh
gbm completion zsh > "${fpath[1]}/_gbm"

# Fish
gbm completion fish > ~/.config/fish/completions/gbm.fish
```

## Configuration

The tool creates a `.gbm/config.toml` file for metadata storage with default settings:

```toml
[settings]
worktree_prefix = "worktrees"
auto_fetch = true
create_missing_branches = false

[state]
last_sync = "2025-07-01T10:30:00Z"
tracked_vars = ["PROD", "PREVIEW", "MAIN", "STAGING"]
```

## Directory Structure

```
project-root/
├── .git/
├── .envrc
├── .gbm/
│   └── config.toml
├── worktrees/
│   ├── PROD/           # Contains production/2025-05-1 branch
│   ├── PREVIEW/        # Contains production/2025-06-1 branch
│   ├── MAIN/           # Contains master branch
│   └── STAGING/        # Contains feature/new-api branch
└── main-workspace/     # Original repository workspace
```

## Global Flags

- `--config, -c`: Specify custom .envrc path
- `--worktree-dir, -w`: Override worktree directory location
- `--verbose, -v`: Enable verbose output
- `--quiet, -q`: Suppress non-error output
</file>

<file path="cmd/root.go">
package cmd

import (
	"fmt"
	"os"
	"runtime"
	"time"

	"gbm/internal"

	tea "github.com/charmbracelet/bubbletea"
	"github.com/spf13/cobra"
)

var (
	configPath  string
	worktreeDir string
	debug       bool
	logFile     *os.File
)

var rootCmd = &cobra.Command{
	Use:   "gbm",
	Short: "Git Branch Manager - Manage Git worktrees based on .envrc configuration",
	Long: `Git Branch Manager (gbm) is a CLI tool that manages Git repository branches
and worktrees based on environment variables defined in a .envrc file.

The tool synchronizes local worktrees with branch definitions and provides
notifications when configurations drift out of sync.`,
	PersistentPreRun: func(cmd *cobra.Command, args []string) {
		InitializeLogging()
	},
}

func Execute() error {
	return rootCmd.Execute()
}

func init() {
	rootCmd.PersistentFlags().StringVarP(&configPath, "config", "c", "", "specify custom .envrc path")
	rootCmd.PersistentFlags().StringVarP(&worktreeDir, "worktree-dir", "w", "", "override worktree directory location")
	rootCmd.PersistentFlags().BoolVarP(&debug, "debug", "d", false, "enable debug logging to ./gbm.log")
}

func GetConfigPath() string {
	if configPath != "" {
		return configPath
	}
	return ".envrc"
}

func GetWorktreeDir() string {
	if worktreeDir != "" {
		return worktreeDir
	}
	return "worktrees"
}

func InitializeLogging() {
	if debug {
		var err error
		logFile, err = tea.LogToFile("gbm.log", "gbm")
		if err != nil {
			PrintError("Failed to initialize log file: %v", err)
		}
	}
}

func PrintInfo(format string, args ...interface{}) {
	msg := fmt.Sprintf(format, args...)
	fmt.Fprintf(os.Stderr, "%s\n", internal.FormatInfo(msg))
	if logFile != nil {
		_, file, line, _ := runtime.Caller(1)
		timestamp := time.Now().Format("2006-01-02T15:04:05.000")
		fmt.Fprintf(logFile, "%s [INFO] %s:%d %s\n", timestamp, file, line, msg)
	}
}

func PrintVerbose(format string, args ...interface{}) {
	msg := fmt.Sprintf(format, args...)
	if debug {
		fmt.Fprintf(os.Stderr, "%s\n", internal.FormatVerbose(msg))
	}
	if logFile != nil {
		_, file, line, _ := runtime.Caller(1)
		timestamp := time.Now().Format("2006-01-02T15:04:05.000")
		fmt.Fprintf(logFile, "%s [DEBUG] %s:%d %s\n", timestamp, file, line, msg)
	}
}

func PrintError(format string, args ...interface{}) {
	msg := fmt.Sprintf(format, args...)
	fmt.Fprintf(os.Stderr, "%s\n", internal.FormatError("ERROR: "+msg))
	if logFile != nil {
		_, file, line, _ := runtime.Caller(1)
		timestamp := time.Now().Format("2006-01-02T15:04:05.000")
		fmt.Fprintf(logFile, "%s [ERROR] %s:%d %s\n", timestamp, file, line, msg)
	}
}

func CloseLogFile() {
	if logFile != nil {
		logFile.Close()
	}
}
</file>

<file path="cmd/switch.go">
package cmd

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"gbm/internal"

	"github.com/spf13/cobra"
)

var (
	printPath bool
)

var switchCmd = &cobra.Command{
	Use:   "switch [WORKTREE_NAME]",
	Short: "Switch to a different worktree",
	Long: `Switch to a different worktree by environment variable name.

If no worktree name is provided, lists all available worktrees.
Use with shell integration for automatic directory switching:

  gbm-switch() {
      local target_dir=$(gbm switch --print-path "$1")
      if [ $? -eq 0 ] && [ -n "$target_dir" ]; then
          cd "$target_dir"
      else
          gbm switch "$@"
      fi
  }

Examples:
  gbm switch PROD      # Show path to PROD worktree
  gbm switch STAGING   # Show path to STAGING worktree
  gbm switch -         # Switch to previous worktree
  gbm switch           # List all available worktrees`,
	RunE: func(cmd *cobra.Command, args []string) error {
		PrintVerbose("Running switch command")

		wd, err := os.Getwd()
		if err != nil {
			return fmt.Errorf("failed to get working directory: %w", err)
		}

		repoRoot, err := internal.FindGitRoot(wd)
		if err != nil {
			return fmt.Errorf("failed to find git repository root: %w", err)
		}
		PrintVerbose("Checking status from repository root: %s", repoRoot)

		manager, err := internal.NewManager(repoRoot)
		if err != nil {
			return err
		}

		// Load .envrc configuration for proper sorting
		if err := manager.LoadEnvMapping(GetConfigPath()); err != nil {
			PrintVerbose("No .envrc found or failed to load: %v", err)
		}

		if len(args) == 0 {
			return listWorktrees(manager)
		}

		worktreeName := args[0]

		// Handle special case of "-" to switch to previous worktree
		if worktreeName == "-" {
			previous := manager.GetPreviousWorktree()
			if previous == "" {
				return fmt.Errorf("no previous worktree available")
			}
			PrintInfo("Switching to previous worktree: %s", previous)
			worktreeName = previous
		} else {
			worktreeName = strings.ToUpper(worktreeName)
		}

		return switchToWorktree(manager, worktreeName)
	},
}

func switchToWorktree(manager *internal.Manager, worktreeName string) error {
	PrintVerbose("Switching to worktree: %s", worktreeName)

	// Try exact match first
	targetPath, err := manager.GetWorktreePath(worktreeName)
	if err != nil {
		// If exact match fails, try fuzzy matching
		PrintVerbose("Exact match failed, trying fuzzy matching")
		matchedName := findFuzzyMatch(manager, worktreeName)
		if matchedName != "" {
			PrintInfo("Fuzzy matched '%s' to '%s'", worktreeName, matchedName)
			targetPath, err = manager.GetWorktreePath(matchedName)
			if err != nil {
				return err
			}
			worktreeName = matchedName // Update for display
		} else {
			return err
		}
	}

	// Track this worktree switch
	if err := manager.SetCurrentWorktree(worktreeName); err != nil {
		PrintVerbose("Failed to track current worktree: %v", err)
	}

	if printPath {
		fmt.Print(targetPath)
		return nil
	}

	// Check if shell integration is available by looking for gbm-switch function
	if os.Getenv("GBM_SHELL_INTEGRATION") != "" {
		// If shell integration is available, output cd command
		fmt.Printf("cd %s\n", targetPath)
		return nil
	}

	fmt.Printf("%s\n", internal.FormatInfo(fmt.Sprintf("Worktree %s is located at: %s", worktreeName, targetPath)))
	fmt.Println(internal.FormatSubtle("Use shell integration 'gbm-switch' function to automatically change directory"))
	fmt.Println(internal.FormatSubtle("Or run: cd " + targetPath))
	return nil
}

func findFuzzyMatch(manager *internal.Manager, target string) string {
	worktrees, err := manager.GetAllWorktrees()
	if err != nil {
		return ""
	}

	target = strings.ToUpper(target)

	// Look for case-insensitive substring matches
	var matches []string
	for name := range worktrees {
		upperName := strings.ToUpper(name)
		if strings.Contains(upperName, target) {
			matches = append(matches, name)
		}
	}

	// If we have exactly one match, return it
	if len(matches) == 1 {
		return matches[0]
	}

	// If we have multiple matches, prefer the one that starts with the target
	for _, match := range matches {
		upperMatch := strings.ToUpper(match)
		if strings.HasPrefix(upperMatch, target) {
			return match
		}
	}

	// If no prefix match, return the first match (if any)
	if len(matches) > 0 {
		return matches[0]
	}

	return ""
}

func listWorktrees(manager *internal.Manager) error {
	PrintVerbose("Listing available worktrees")

	worktrees, err := manager.GetAllWorktrees()
	if err != nil {
		return err
	}

	if len(worktrees) == 0 {
		fmt.Println(internal.FormatInfo("No worktrees found. Run 'gbm init' to create worktrees."))
		return nil
	}

	fmt.Println(internal.FormatSubHeader("Available worktrees:"))

	// Get sorted worktree names (.envrc first, then ad hoc by creation time desc)
	names := manager.GetSortedWorktreeNames(worktrees)

	for _, name := range names {
		info := worktrees[name]
		status := "ready"
		if info.GitStatus != nil {
			status = manager.GetStatusIcon(info.GitStatus)
		}

		relPath, _ := filepath.Rel(".", info.Path)
		branchInfo := info.CurrentBranch
		if info.ExpectedBranch != info.CurrentBranch {
			branchInfo = fmt.Sprintf("%s -> %s", info.CurrentBranch, info.ExpectedBranch)
		}
		fmt.Printf("  %s %-12s %s (%s)\n", status, name, relPath, branchInfo)
	}

	return nil
}

func init() {
	rootCmd.AddCommand(switchCmd)
	switchCmd.Flags().BoolVar(&printPath, "print-path", false, "Print the worktree path only (for shell integration)")

	// Add completion for worktree names
	switchCmd.ValidArgsFunction = func(cmd *cobra.Command, args []string, toComplete string) ([]string, cobra.ShellCompDirective) {
		if len(args) != 0 {
			return nil, cobra.ShellCompDirectiveNoFileComp
		}
		return getWorktreeNames(), cobra.ShellCompDirectiveNoFileComp
	}
}

func getWorktreeNames() []string {
	wd, err := os.Getwd()
	if err != nil {
		return nil
	}

	repoRoot, err := internal.FindGitRoot(wd)
	if err != nil {
		return nil
	}

	manager, err := internal.NewManager(repoRoot)
	if err != nil {
		return nil
	}

	worktrees, err := manager.GetAllWorktrees()
	if err != nil {
		return nil
	}

	var names []string
	for name := range worktrees {
		names = append(names, name)
	}
	return names
}
</file>

<file path="internal/table.go">
package internal

import (
	"fmt"

	"github.com/charmbracelet/lipgloss"
	"github.com/charmbracelet/lipgloss/table"
)

type Table struct {
	table *table.Table
}

func NewTable(headers []string) *Table {
	t := table.New().
		Border(lipgloss.NormalBorder()).
		BorderStyle(TableBorderStyle).
		StyleFunc(func(row, col int) lipgloss.Style {
			if row == table.HeaderRow {
				return TableHeaderStyle
			}
			return TableCellStyle
		}).
		Headers(headers...)

	return &Table{
		table: t,
	}
}

func (t *Table) AddRow(row []string) {
	t.table.Row(row...)
}

func (t *Table) Print() {
	if t.table == nil {
		return
	}
	fmt.Println(t.table.String())
}

func (t *Table) String() string {
	if t.table == nil {
		return ""
	}
	return t.table.String()
}
</file>

<file path="cmd/init.go">
package cmd

import (
	"fmt"
	"os"

	"gbm/internal"

	"github.com/spf13/cobra"
)

var (
	initForce bool
	initFetch bool
)

var initCmd = &cobra.Command{
	Use:   "init",
	Short: "Initialize the current Git repository for branch management",
	Long: `Initialize the current Git repository for branch management.

Creates initial worktree structure based on .envrc file.
Validates that the repository is a valid Git repo and creates .gbm/ directory for metadata storage.`,
	RunE: func(cmd *cobra.Command, args []string) error {
		wd, err := os.Getwd()
		if err != nil {
			return fmt.Errorf("failed to get working directory: %w", err)
		}

		repoRoot, err := internal.FindGitRoot(wd)
		if err != nil {
			return fmt.Errorf("failed to find git repository root: %w", err)
		}

		manager, err := internal.NewManager(repoRoot)
		if err != nil {
			return err
		}

		PrintVerbose("Loading .envrc configuration from: %s", GetConfigPath())
		if err := manager.LoadEnvMapping(GetConfigPath()); err != nil {
			return fmt.Errorf("failed to load .envrc: %w", err)
		}

		PrintVerbose("Initializing worktree management (force=%v, fetch=%v)", initForce, initFetch)
		if err := manager.Initialize(initForce, initFetch); err != nil {
			return err
		}

		PrintInfo("%s", internal.FormatSuccess("Successfully initialized Git Branch Manager"))
		return nil
	},
}

func init() {
	rootCmd.AddCommand(initCmd)
	initCmd.Flags().BoolVar(&initForce, "force", false, "initialize even if worktrees already exist")
	initCmd.Flags().BoolVar(&initFetch, "fetch", false, "fetch remote branches during initialization")
}
</file>

<file path="cmd/shell-integration.go">
package cmd

import (
	"fmt"

	"github.com/spf13/cobra"
)

var shellIntegrationCmd = &cobra.Command{
	Use:   "shell-integration",
	Short: "Generate shell integration code for automatic checking",
	Long: `Generate shell integration code that can be evaluated in your shell to enable automatic checking.

This command outputs shell code that can be added to your .bashrc, .zshrc, or other shell configuration
to automatically check for worktree drift and display status in your prompt.

Example usage:
  eval "$(gbm shell-integration)"

Or add to your shell configuration:
  echo 'eval "$(gbm shell-integration)"' >> ~/.bashrc`,
	RunE: func(cmd *cobra.Command, args []string) error {
		PrintVerbose("Generating shell integration code")
		shellCode := `
# Git Branch Manager (gbm) shell integration
# Automatically check for worktree drift and display status

# Set environment variable to indicate shell integration is active
export GBM_SHELL_INTEGRATION=1

# Enable completion
if [ -n "$ZSH_VERSION" ]; then
    # For zsh, enable completion
    autoload -U compinit && compinit
    source <(gbm completion zsh)
elif [ -n "$BASH_VERSION" ]; then
    # For bash, enable completion
    source <(gbm completion bash)
fi

__gbm_prompt() {
    if [ -f ".envrc" ] && [ -d ".git" ]; then
        local gbm_status=$(gbm check --format=prompt 2>/dev/null)
        if [ $? -eq 0 ] && [ -n "$gbm_status" ]; then
            echo "$gbm_status"
        fi
    fi
}

# Add gbm status to PS1 for bash/zsh
if [ -n "$BASH_VERSION" ] || [ -n "$ZSH_VERSION" ]; then
    if [[ "$PS1" != *"__gbm_prompt"* ]]; then
        PS1='$(__gbm_prompt)'$PS1
    fi
fi

# Function to manually check gbm status
gbm-status() {
    gbm check --format=text
}

# Function to quickly sync worktrees
gbm-sync() {
    gbm sync "$@"
}

# Function to switch between worktrees
gbm-switch() {
    if [ $# -eq 0 ]; then
        gbm switch
        return
    fi

    local target_dir=$(gbm switch --print-path "$1" 2>/dev/null)
    if [ $? -eq 0 ] && [ -n "$target_dir" ]; then
        cd "$target_dir"
        echo "Switched to worktree: $1"
    else
        gbm switch "$@"
    fi
}

# Override gbm function to handle switch command specially
gbm() {
    if [ "$1" = "switch" ] && [ $# -gt 1 ]; then
        # For switch command with arguments, execute the cd command
        local cmd_output=$(command gbm "$@" 2>/dev/null)
        if [ $? -eq 0 ] && [[ "$cmd_output" =~ ^cd ]]; then
            eval "$cmd_output"
            echo "Switched to worktree: $2"
        else
            command gbm "$@"
        fi
    else
        # For all other commands, just pass through
        command gbm "$@"
    fi
}
`
		PrintVerbose("Outputting shell integration script")
		fmt.Print(shellCode)
		return nil
	},
}

func init() {
	rootCmd.AddCommand(shellIntegrationCmd)
}
</file>

<file path="cmd/sync.go">
package cmd

import (
	"fmt"
	"os"

	"gbm/internal"

	"github.com/spf13/cobra"
)

var (
	syncDryRun bool
	syncForce  bool
	syncFetch  bool
)

var syncCmd = &cobra.Command{
	Use:   "sync",
	Short: "Synchronize all worktrees with current .envrc definitions",
	Long: `Synchronize all worktrees with current .envrc definitions.

Creates missing worktrees for new environment variables, updates existing worktrees
if branch references have changed, and optionally removes orphaned worktrees.`,
	RunE: func(cmd *cobra.Command, args []string) error {
		wd, err := os.Getwd()
		if err != nil {
			return fmt.Errorf("failed to get working directory: %w", err)
		}

		repoRoot, err := internal.FindGitRoot(wd)
		if err != nil {
			return fmt.Errorf("failed to find git repository root: %w", err)
		}

		manager, err := internal.NewManager(repoRoot)
		if err != nil {
			return err
		}

		PrintVerbose("Loading .envrc configuration from: %s", GetConfigPath())
		if err := manager.LoadEnvMapping(GetConfigPath()); err != nil {
			return fmt.Errorf("failed to load .envrc: %w", err)
		}

		if syncDryRun {
			iconManager := internal.GetGlobalIconManager()
			PrintInfo("%s", internal.FormatStatusIcon(iconManager.DryRun(), "Dry run mode - showing what would be changed:"))
			status, err := manager.GetSyncStatus()
			if err != nil {
				return err
			}

			if status.InSync {
				PrintInfo("%s", internal.FormatSuccess("All worktrees are in sync"))
				return nil
			}

			if len(status.MissingWorktrees) > 0 {
				iconManager := internal.GetGlobalIconManager()
				PrintInfo("%s", internal.FormatStatusIcon(iconManager.Missing(), "Missing worktrees:"))
				for _, envVar := range status.MissingWorktrees {
					PrintInfo("  • %s", envVar)
				}
			}

			if len(status.BranchChanges) > 0 {
				iconManager := internal.GetGlobalIconManager()
				PrintInfo("%s", internal.FormatStatusIcon(iconManager.Changes(), "Branch changes needed:"))
				for envVar, change := range status.BranchChanges {
					PrintInfo("  • %s: %s → %s", envVar, change.OldBranch, change.NewBranch)
				}
			}

			if len(status.OrphanedWorktrees) > 0 {
				iconManager := internal.GetGlobalIconManager()
				PrintInfo("%s", internal.FormatStatusIcon(iconManager.Orphaned(), "Orphaned worktrees (use --force to remove):"))
				for _, envVar := range status.OrphanedWorktrees {
					PrintInfo("  • %s", envVar)
				}
			}

			return nil
		}

		PrintVerbose("Synchronizing worktrees (force=%v, fetch=%v)", syncForce, syncFetch)
		if err := manager.Sync(syncDryRun, syncForce, syncFetch); err != nil {
			return err
		}

		PrintInfo("%s", internal.FormatSuccess("Successfully synchronized worktrees"))
		return nil
	},
}

func init() {
	rootCmd.AddCommand(syncCmd)
	syncCmd.Flags().BoolVar(&syncDryRun, "dry-run", false, "show what would be changed without making changes")
	syncCmd.Flags().BoolVar(&syncForce, "force", false, "skip confirmation prompts and remove orphaned worktrees")
	syncCmd.Flags().BoolVar(&syncFetch, "fetch", false, "update remote tracking before sync")
}
</file>

<file path="cmd/validate.go">
package cmd

import (
	"fmt"
	"os"

	"gbm/internal"

	"github.com/spf13/cobra"
)

var validateCmd = &cobra.Command{
	Use:   "validate",
	Short: "Validate .envrc syntax and branch references",
	Long: `Validate .envrc syntax and branch references.

Checks if referenced branches exist locally or remotely. Useful for CI/CD integration
and ensuring configuration correctness before syncing.`,
	RunE: func(cmd *cobra.Command, args []string) error {
		wd, err := os.Getwd()
		if err != nil {
			return fmt.Errorf("failed to get working directory: %w", err)
		}

		repoRoot, err := internal.FindGitRoot(wd)
		if err != nil {
			return fmt.Errorf("failed to find git repository root: %w", err)
		}

		manager, err := internal.NewManager(repoRoot)
		if err != nil {
			return err
		}

		PrintVerbose("Loading .envrc configuration from: %s", GetConfigPath())
		if err := manager.LoadEnvMapping(GetConfigPath()); err != nil {
			return fmt.Errorf("failed to load .envrc: %w", err)
		}

		PrintVerbose("Validating branch references...")

		// Get the mapping to validate
		mapping, err := manager.GetEnvMapping()
		if err != nil {
			return err
		}

		// Create table for validation results
		table := internal.NewTable([]string{"ENV VARIABLE", "BRANCH", "STATUS"})

		allValid := true
		for envVar, branchName := range mapping {
			exists, err := manager.BranchExists(branchName)
			if err != nil {
				table.AddRow([]string{envVar, branchName, internal.FormatError("ERROR")})
				allValid = false
				continue
			}

			if exists {
				table.AddRow([]string{envVar, branchName, internal.FormatSuccess("VALID")})
			} else {
				table.AddRow([]string{envVar, branchName, internal.FormatError("NOT FOUND")})
				allValid = false
			}
		}

		// Display validation header
		if allValid {
			PrintInfo("%s", internal.FormatSuccess(".envrc validation passed"))
		} else {
			PrintError("%s", internal.FormatError(".envrc validation failed"))
		}

		fmt.Println()
		table.Print()

		if !allValid {
			return fmt.Errorf("validation failed - one or more branches do not exist")
		}

		return nil
	},
}

func init() {
	rootCmd.AddCommand(validateCmd)
}
</file>

<file path="internal/config.go">
package internal

import (
	"bufio"
	"fmt"
	"os"
	"path/filepath"
	"regexp"
	"strings"
	"time"

	"github.com/BurntSushi/toml"
)

type Config struct {
	Settings ConfigSettings `toml:"settings"`
	State    ConfigState    `toml:"state"`
	Icons    ConfigIcons    `toml:"icons"`
}

type ConfigSettings struct {
	WorktreePrefix        string `toml:"worktree_prefix"`
	AutoFetch             bool   `toml:"auto_fetch"`
	CreateMissingBranches bool   `toml:"create_missing_branches"`
}

type ConfigState struct {
	LastSync         time.Time `toml:"last_sync"`
	TrackedVars      []string  `toml:"tracked_vars"`
	AdHocWorktrees   []string  `toml:"ad_hoc_worktrees"`
	CurrentWorktree  string    `toml:"current_worktree"`
	PreviousWorktree string    `toml:"previous_worktree"`
}

type ConfigIcons struct {
	// Status icons
	Success  string `toml:"success"`
	Warning  string `toml:"warning"`
	Error    string `toml:"error"`
	Info     string `toml:"info"`
	Orphaned string `toml:"orphaned"`
	DryRun   string `toml:"dry_run"`
	Missing  string `toml:"missing"`
	Changes  string `toml:"changes"`

	// Git status icons
	GitClean    string `toml:"git_clean"`
	GitDirty    string `toml:"git_dirty"`
	GitAhead    string `toml:"git_ahead"`
	GitBehind   string `toml:"git_behind"`
	GitDiverged string `toml:"git_diverged"`
	GitUnknown  string `toml:"git_unknown"`
}

type EnvMapping struct {
	Variables map[string]string
}

func DefaultConfig() *Config {
	return &Config{
		Settings: ConfigSettings{
			WorktreePrefix:        "worktrees",
			AutoFetch:             true,
			CreateMissingBranches: false,
		},
		State: ConfigState{
			LastSync:         time.Time{},
			TrackedVars:      []string{},
			AdHocWorktrees:   []string{},
			CurrentWorktree:  "",
			PreviousWorktree: "",
		},
		Icons: ConfigIcons{
			// Status icons
			Success:  "✅",
			Warning:  "⚠️",
			Error:    "❌",
			Info:     "💡",
			Orphaned: "🗑️",
			DryRun:   "🔍",
			Missing:  "📁",
			Changes:  "🔄",

			// Git status icons
			GitClean:    "✓",
			GitDirty:    "~",
			GitAhead:    "↑",
			GitBehind:   "↓",
			GitDiverged: "⇕",
			GitUnknown:  "?",
		},
	}
}

func LoadConfig(gbmDir string) (*Config, error) {
	configPath := filepath.Join(gbmDir, "config.toml")

	if _, err := os.Stat(configPath); os.IsNotExist(err) {
		return DefaultConfig(), nil
	}

	var config Config
	if _, err := toml.DecodeFile(configPath, &config); err != nil {
		return nil, fmt.Errorf("failed to decode config file: %w", err)
	}

	return &config, nil
}

func (c *Config) Save(gbmDir string) error {
	if err := os.MkdirAll(gbmDir, 0755); err != nil {
		return fmt.Errorf("failed to create .gbm directory: %w", err)
	}

	configPath := filepath.Join(gbmDir, "config.toml")
	file, err := os.Create(configPath)
	if err != nil {
		return fmt.Errorf("failed to create config file: %w", err)
	}
	defer file.Close()

	encoder := toml.NewEncoder(file)
	if err := encoder.Encode(c); err != nil {
		return fmt.Errorf("failed to encode config: %w", err)
	}

	return nil
}

func ParseEnvrc(path string) (*EnvMapping, error) {
	file, err := os.Open(path)
	if err != nil {
		return nil, fmt.Errorf("failed to open .envrc file: %w", err)
	}
	defer file.Close()

	mapping := &EnvMapping{
		Variables: make(map[string]string),
	}

	scanner := bufio.NewScanner(file)
	envVarRegex := regexp.MustCompile(`^([A-Z_][A-Z0-9_]*)=(.+)$`)

	for scanner.Scan() {
		line := strings.TrimSpace(scanner.Text())

		if line == "" || strings.HasPrefix(line, "#") {
			continue
		}

		matches := envVarRegex.FindStringSubmatch(line)
		if len(matches) == 3 {
			varName := matches[1]
			branchName := strings.Trim(matches[2], "\"'")
			mapping.Variables[varName] = branchName
		}
	}

	if err := scanner.Err(); err != nil {
		return nil, fmt.Errorf("error reading .envrc file: %w", err)
	}

	return mapping, nil
}
</file>

<file path="cmd/add.go">
package cmd

import (
	"fmt"
	"strings"

	"gbm/internal"

	"github.com/spf13/cobra"
)

var (
	newBranch   bool
	baseBranch  string
	interactive bool
)

var addCmd = &cobra.Command{
	Use:   "add <worktree-name> [branch-name]",
	Short: "Add a new worktree",
	Long: `Add a new worktree with various options:
- Create on existing branch: gbm add INGSVC-5544 existing-branch-name
- Create on new branch: gbm add INGSVC-5544 feature/new-branch -b
- Interactive mode: gbm add INGSVC-5544 --interactive
- Tab completion: Shows JIRA keys with summaries, suggests branch names when needed`,
	Args: cobra.MinimumNArgs(1),
	RunE: func(cmd *cobra.Command, args []string) error {
		worktreeName := args[0]

		// Find git repository root
		repoPath, err := internal.FindGitRoot(".")
		if err != nil {
			return fmt.Errorf("not in a git repository: %w", err)
		}

		// Create manager
		manager, err := internal.NewManager(repoPath)
		if err != nil {
			return fmt.Errorf("failed to create manager: %w", err)
		}

		// Load .envrc configuration to check if worktree is tracked
		if err := manager.LoadEnvMapping(GetConfigPath()); err != nil {
			PrintVerbose("No .envrc found or failed to load, treating as ad hoc worktree: %v", err)
		}

		var branchName string

		if interactive {
			// Handle interactive mode
			branchName, err = handleInteractive(manager)
			if err != nil {
				return fmt.Errorf("failed to handle interactive mode: %w", err)
			}
		} else {
			// Handle direct specification
			if len(args) > 1 {
				branchName = args[1]
			} else if newBranch {
				// Generate branch name from worktree name
				branchName = generateBranchName(worktreeName)
			} else if internal.IsJiraKey(worktreeName) {
				// Auto-suggest branch name for JIRA keys
				suggestedBranch := generateBranchName(worktreeName)
				return fmt.Errorf("branch name required. Suggested: %s\n\nTry: gbm add %s %s -b", suggestedBranch, worktreeName, suggestedBranch)
			} else {
				return fmt.Errorf("branch name required when not creating new branch (use -b to create new branch)")
			}
		}

		PrintInfo("Adding worktree '%s' on branch '%s'", worktreeName, branchName)

		// Add the worktree
		if err := manager.AddWorktree(worktreeName, branchName, newBranch); err != nil {
			return fmt.Errorf("failed to add worktree: %w", err)
		}

		PrintInfo("Worktree '%s' added successfully", worktreeName)

		return nil
	},
}

func handleInteractive(manager *internal.Manager) (string, error) {
	// Get available branches
	branches, err := manager.GetRemoteBranches()
	if err != nil {
		return "", fmt.Errorf("failed to get remote branches: %w", err)
	}

	fmt.Println(internal.FormatSubHeader("Available branches:"))
	for i, branch := range branches {
		fmt.Printf("  %s\n", internal.FormatInfo(fmt.Sprintf("%d. %s", i+1, branch)))
	}
	fmt.Printf("  %s\n", internal.FormatInfo(fmt.Sprintf("%d. Create new branch", len(branches)+1)))

	var choice int
	fmt.Print(internal.FormatPrompt("Select a branch: "))
	if _, err := fmt.Scanln(&choice); err != nil {
		return "", fmt.Errorf("failed to read choice: %w", err)
	}

	if choice < 1 || choice > len(branches)+1 {
		return "", fmt.Errorf("invalid choice")
	}

	if choice == len(branches)+1 {
		// Create new branch
		newBranch = true
		fmt.Print(internal.FormatPrompt("Enter new branch name: "))
		var branchName string
		if _, err := fmt.Scanln(&branchName); err != nil {
			return "", fmt.Errorf("failed to read branch name: %w", err)
		}
		return branchName, nil
	} else {
		// Use existing branch
		newBranch = false
		return branches[choice-1], nil
	}
}

func generateBranchName(worktreeName string) string {
	// Check if this is a JIRA key first
	if internal.IsJiraKey(worktreeName) {
		branchName, err := internal.GenerateBranchFromJira(worktreeName)
		if err != nil {
			PrintVerbose("Failed to generate branch name from JIRA issue %s: %v", worktreeName, err)
			PrintInfo("Could not fetch JIRA issue details. Using default branch name format.")
			// Generate a basic branch name from the JIRA key
			return fmt.Sprintf("feature/%s", strings.ToLower(worktreeName))
		} else {
			PrintInfo("Auto-generated branch name from JIRA issue: %s", branchName)
			return branchName
		}
	}

	// Convert worktree name to a valid branch name
	branchName := strings.ReplaceAll(worktreeName, " ", "-")
	branchName = strings.ReplaceAll(branchName, "_", "-")
	branchName = strings.ToLower(branchName)

	// Add feature/ prefix if not already present
	if !strings.HasPrefix(branchName, "feature/") && !strings.HasPrefix(branchName, "bugfix/") && !strings.HasPrefix(branchName, "hotfix/") {
		branchName = "feature/" + branchName
	}

	return branchName
}

func init() {
	rootCmd.AddCommand(addCmd)

	addCmd.Flags().BoolVarP(&newBranch, "new-branch", "b", false, "Create a new branch for the worktree")
	addCmd.Flags().StringVar(&baseBranch, "base", "", "Base branch for new branch (default: current branch)")
	addCmd.Flags().BoolVarP(&interactive, "interactive", "i", false, "Interactive mode to select branch")

	// Add JIRA key completions for the first positional argument
	addCmd.ValidArgsFunction = func(cmd *cobra.Command, args []string, toComplete string) ([]string, cobra.ShellCompDirective) {
		if len(args) == 0 {
			// Complete JIRA keys with summaries for context
			jiraIssues, err := internal.GetJiraIssues()
			if err != nil {
				// If JIRA CLI is not available, fall back to no completions
				return nil, cobra.ShellCompDirectiveNoFileComp
			}

			var completions []string
			for _, issue := range jiraIssues {
				// Format: "KEY\tSummary" - clean completion of just the key with summary context
				completion := fmt.Sprintf("%s\t%s", issue.Key, issue.Summary)
				completions = append(completions, completion)
			}
			return completions, cobra.ShellCompDirectiveNoFileComp
		} else if len(args) == 1 {
			// Complete branch name based on the JIRA key
			worktreeName := args[0]
			if internal.IsJiraKey(worktreeName) {
				branchName, err := internal.GenerateBranchFromJira(worktreeName)
				if err != nil {
					// Fallback to default branch name generation
					branchName = fmt.Sprintf("feature/%s", strings.ToLower(worktreeName))
				}
				return []string{branchName}, cobra.ShellCompDirectiveNoFileComp
			}
			return nil, cobra.ShellCompDirectiveNoFileComp
		}
		return nil, cobra.ShellCompDirectiveNoFileComp
	}
}
</file>

<file path="cmd/clean.go">
package cmd

import (
	"fmt"
	"os"

	"gbm/internal"

	"github.com/spf13/cobra"
)

var (
	cleanForce bool
)

var cleanCmd = &cobra.Command{
	Use:   "clean",
	Short: "Remove orphaned worktrees (interactive by default)",
	Long: `Remove orphaned worktrees that are no longer defined in .envrc.

By default, this command is interactive and will prompt for confirmation before removing
each orphaned worktree. Use --force to skip confirmations.`,
	RunE: func(cmd *cobra.Command, args []string) error {
		wd, err := os.Getwd()
		if err != nil {
			return fmt.Errorf("failed to get working directory: %w", err)
		}

		repoRoot, err := internal.FindGitRoot(wd)
		if err != nil {
			return fmt.Errorf("failed to find git repository root: %w", err)
		}
		PrintVerbose("Starting cleanup from repository root: %s", repoRoot)

		manager, err := internal.NewManager(repoRoot)
		if err != nil {
			return err
		}

		PrintVerbose("Loading .envrc configuration from: %s", GetConfigPath())
		if err := manager.LoadEnvMapping(GetConfigPath()); err != nil {
			return fmt.Errorf("failed to load .envrc: %w", err)
		}

		PrintVerbose("Retrieving sync status to identify orphaned worktrees")
		status, err := manager.GetSyncStatus()
		if err != nil {
			return err
		}

		PrintVerbose("Found %d orphaned worktrees to process", len(status.OrphanedWorktrees))
		if len(status.OrphanedWorktrees) == 0 {
			PrintInfo("%s", internal.FormatSuccess("No orphaned worktrees found"))
			return nil
		}

		iconManager := internal.GetGlobalIconManager()
		PrintInfo("%s", internal.FormatStatusIcon(iconManager.Orphaned(), fmt.Sprintf("Found %d orphaned worktree(s):", len(status.OrphanedWorktrees))))
		for _, envVar := range status.OrphanedWorktrees {
			PrintInfo("  • %s", envVar)
		}
		fmt.Println()

		PrintVerbose("Cleanup mode: force=%v", cleanForce)
		if cleanForce {
			PrintInfo("%s", internal.FormatStatusIcon("🔥", "Force mode enabled - removing all orphaned worktrees..."))
		} else {
			PrintInfo("%s", internal.FormatInfo("Interactive mode - you will be prompted for each worktree"))
		}

		PrintVerbose("Initiating cleanup of orphaned worktrees")
		if err := manager.CleanOrphaned(cleanForce); err != nil {
			return err
		}

		PrintInfo("%s", internal.FormatSuccess("Orphaned worktree cleanup completed"))
		return nil
	},
}

func init() {
	rootCmd.AddCommand(cleanCmd)
	cleanCmd.Flags().BoolVar(&cleanForce, "force", false, "force removal without confirmation prompts")
}
</file>

<file path="docs/todo.md">
# TODO
- [x] option to log to file
- [x] binary can be called anywhere inside the git repo
- [x] add clone verb
    - [x] clones a bare repo
    - [x] creates the MAIN worktree using the HEAD branch
    - [x] detects if the worktree has a .envrc
        * YES - use that as the .envrc for the repo
        * NO - tell user to create a .envrc file. suggest to user to generate one based on the initial worktree we created.
- [x] suport `add` verb to add worktree
    - [x] normal worktree on new branch
    - [x] normal worktree on existing branch
    - [x] worktree based on JIRA ticket (use `jira-cli` to select ticket)
        - [x] configure your own rules for parsing jira ticket for branch name
    - [x] https://github.com/ankitpokhrel/jira-cli/discussions/356
- [x] enhance `switch` command (future features)
    - [x] auto-completion for worktree names
    - [x] automatic directory switching with shell integration
    - [x] fuzzy matching (e.g., `gbm switch prod` matches `PROD`)
- [x] add `push` verb
    - [x] `gbm push` pushes worktree if in a worktree - otherwise error
    - [x] `gbm push <worktree_name>` pushes named worktree - no matter what directoy you are in
    - [x] `gbm push --all` pushes all managed worktrees
- [x] add `pull` verb
    - [x] `gbm pull` pulls worktree if in a worktree - otherwise error
    - [x] `gbm pull <worktree_name>` pulls named worktree - no matter what directoy you are in
    - [x] `gbm pull --all` pulls all managed worktrees
- [x] use lipgloss for tables and styling
- [x] fix `gbm pull`
```sh
󰀵 jschneider  ~/code/scratch/integrator/worktrees/MAIN   master  󰟓 v1.24.4
  gbm pull
Pulling current worktree 'MAIN'...
There is no tracking information for the current branch.
Please specify which branch you want to merge with.
See git-pull(1) for details.

    git pull <remote> <branch>

If you wish to set tracking information for this branch you can do so with:

    git branch --set-upstream-to=origin/<branch> master

Error: exit status 1
Usage:
  gbm pull [worktree-name] [flags]

Flags:
      --all    Pull all worktrees
  -h, --help   help for pull

Global Flags:
  -c, --config string         specify custom .envrc path
  -d, --debug                 enable debug logging to ./gbm.log
  -w, --worktree-dir string   override worktree directory location

ERROR: Error: exit status 1
```
- [x] add completion support (cobra built-in bash/zsh/fish/powershell)
- [x] add configuration for controlling the icons for git status, repo validations, etc
    - [x] ./.gbm/config.toml
- [x] track all worktrees created with `gbm` in the `list` and `status` commands
- [x]  add `remove` verb
- [x] support `gbm switch -` to go to previous worktree
- [x] sort branches by .envrc first, then worktree createdAt DESC
- [x] add info verb
    - [x] worktree (createdAt, base branch, JIRA ticket/URL), git history
- [ ] configuration for copying files into new worktrees (.env, anything not tracked by git)
- [ ] track merge backs... not sure how yet and how to prompt the user.
    - [ ] helper to create a merge worktree
- [ ] add carapace completion
- [x] jira-cli support
- [ ] control branch name JIRA through config file (use current as defaults)
- [ ] add jira me to config.toml
- [ ] replace confirmation with bubbltea confirmation (lipgloss?)
- [ ] combine list and status. they do the same thing.
    - [ ] use `list` and remove `status`
    - [ ] columns should be WORKTREE | BRANCH | GIT STATUS | SYNC STATUS | PATH (if not enough room in terminal, omit PATH)
- [ ] add `theme` verb with default themes
- [ ] support `JIRA_CONFIG_FILE` env var ( see https://github.com/ankitpokhrel/jira-cli?tab=readme-ov-file#multiple-projects)
- [ ] add https://github.com/swisscom/bitbucket-cli integration for PRs
</file>

<file path="cmd/check.go">
package cmd

import (
	"encoding/json"
	"fmt"
	"os"
	"slices"

	"gbm/internal"

	"github.com/spf13/cobra"
)

var (
	checkFormat   string
	checkExitCode bool
)

type CheckOutput struct {
	InSync    bool     `json:"in_sync"`
	Status    string   `json:"status"`
	Issues    []string `json:"issues,omitempty"`
	Indicator string   `json:"indicator"`
}

var checkCmd = &cobra.Command{
	Use:   "check",
	Short: "Quick check for drift between .envrc and worktrees",
	Long: `Quick check for drift between .envrc and worktrees.

Can be used for shell integration or automated checking. Returns non-zero exit code if out of sync.`,
	RunE: func(cmd *cobra.Command, args []string) error {
		wd, err := os.Getwd()
		if err != nil {
			return fmt.Errorf("failed to get working directory: %w", err)
		}

		repoRoot, err := internal.FindGitRoot(wd)
		if err != nil {
			return fmt.Errorf("failed to find git repository root: %w", err)
		}
		PrintVerbose("Performing check from repository root: %s", repoRoot)

		manager, err := internal.NewManager(repoRoot)
		if err != nil {
			if checkExitCode {
				os.Exit(1)
			}
			return err
		}

		PrintVerbose("Loading .envrc configuration from: %s", GetConfigPath())
		if err := manager.LoadEnvMapping(GetConfigPath()); err != nil {
			if checkExitCode {
				os.Exit(1)
			}
			return fmt.Errorf("failed to load .envrc: %w", err)
		}

		PrintVerbose("Retrieving sync status for check operation")
		status, err := manager.GetSyncStatus()
		if err != nil {
			if checkExitCode {
				os.Exit(1)
			}
			return err
		}

		output := CheckOutput{
			InSync: status.InSync,
			Issues: []string{},
		}

		iconManager := internal.GetGlobalIconManager()
		if status.InSync {
			output.Status = "in_sync"
			output.Indicator = iconManager.Success()
		} else {
			output.Status = "out_of_sync"
			output.Indicator = iconManager.Warning()

			for _, envVar := range status.MissingWorktrees {
				output.Issues = append(output.Issues, fmt.Sprintf("Missing worktree: %s", envVar))
			}

			for envVar, change := range status.BranchChanges {
				output.Issues = append(output.Issues, fmt.Sprintf("Branch change: %s (%s → %s)", envVar, change.OldBranch, change.NewBranch))
			}

			for _, envVar := range status.OrphanedWorktrees {
				output.Issues = append(output.Issues, fmt.Sprintf("Orphaned worktree: %s", envVar))
			}
		}

		PrintVerbose("Formatting output as: %s", checkFormat)
		switch checkFormat {
		case "json":
			encoder := json.NewEncoder(os.Stdout)
			encoder.SetIndent("", "  ")
			if err := encoder.Encode(output); err != nil {
				return fmt.Errorf("failed to encode JSON: %w", err)
			}
		case "prompt":
			if !status.InSync {
				fmt.Printf("[gbm:%s] ", output.Indicator)
			}
		case "table":
			// Get worktree information for table
			worktrees, err := manager.GetWorktreeList()
			if err != nil {
				return fmt.Errorf("failed to get worktree list: %w", err)
			}
			PrintVerbose("Generating table format for %d worktrees", len(worktrees))

			table := internal.NewTable([]string{"ENV VAR", "BRANCH", "STATUS", "ISSUES"})

			for envVar, info := range worktrees {
				statusText := "OK"
				issues := ""

				// Check for issues
				if slices.Contains(status.MissingWorktrees, envVar) {
					statusText = "MISSING"
					issues = "Worktree missing"
				}

				if change, exists := status.BranchChanges[envVar]; exists {
					statusText = "OUT_OF_SYNC"
					issues = fmt.Sprintf("%s → %s", change.OldBranch, change.NewBranch)
				}

				if slices.Contains(status.OrphanedWorktrees, envVar) {
					statusText = "ORPHANED"
					issues = "Variable removed"
				}

				table.AddRow([]string{envVar, info.ExpectedBranch, statusText, issues})
			}

			table.Print()
		case "text":
			fallthrough
		default:
			if status.InSync {
				PrintInfo("%s", internal.FormatStatusIcon(output.Indicator, "All worktrees in sync"))
			} else {
				PrintInfo("%s", internal.FormatStatusIcon(output.Indicator, fmt.Sprintf("%d issue(s) detected", len(output.Issues))))
				for _, issue := range output.Issues {
					PrintInfo("  • %s", issue)
				}
			}
		}

		if checkExitCode {
			if status.InSync {
				os.Exit(0)
			} else {
				os.Exit(1)
			}
		}

		return nil
	},
}

func init() {
	rootCmd.AddCommand(checkCmd)
	checkCmd.Flags().StringVar(&checkFormat, "format", "text", "output format (prompt|json|text|table)")
	checkCmd.Flags().BoolVar(&checkExitCode, "exit-code", false, "return status code only")
}
</file>

<file path="cmd/list.go">
package cmd

import (
	"fmt"
	"os"
	"slices"

	"gbm/internal"

	"github.com/spf13/cobra"
)

var listCmd = &cobra.Command{
	Use:   "list",
	Short: "List all managed worktrees and their status",
	Long: `List all managed worktrees and their status.

Shows environment variable mappings and indicates sync status for each entry.`,
	RunE: func(cmd *cobra.Command, args []string) error {
		wd, err := os.Getwd()
		if err != nil {
			return fmt.Errorf("failed to get working directory: %w", err)
		}

		repoRoot, err := internal.FindGitRoot(wd)
		if err != nil {
			return fmt.Errorf("failed to find git repository root: %w", err)
		}
		PrintVerbose("Listing worktrees from repository root: %s", repoRoot)

		manager, err := internal.NewManager(repoRoot)
		if err != nil {
			return err
		}

		PrintVerbose("Loading .envrc configuration from: %s", GetConfigPath())
		if err := manager.LoadEnvMapping(GetConfigPath()); err != nil {
			return fmt.Errorf("failed to load .envrc: %w", err)
		}

		PrintVerbose("Retrieving sync status for list operation")
		status, err := manager.GetSyncStatus()
		if err != nil {
			return err
		}

		PrintVerbose("Fetching detailed worktree information")
		// Get all worktrees (including those created with gbm add)
		worktrees, err := manager.GetAllWorktrees()
		if err != nil {
			return fmt.Errorf("failed to get worktree list: %w", err)
		}

		PrintVerbose("Found %d worktrees to display", len(worktrees))
		if len(worktrees) == 0 {
			return nil
		}

		PrintVerbose("Building worktree list table")
		table := internal.NewTable([]string{"WORKTREE", "BRANCH", "STATUS", "PATH"})

		iconManager := internal.GetGlobalIconManager()

		// Get sorted worktree names (.envrc first, then ad hoc by creation time desc)
		sortedNames := manager.GetSortedWorktreeNames(worktrees)

		for _, worktreeName := range sortedNames {
			info := worktrees[worktreeName]
			statusIcon := iconManager.Success()
			statusText := "OK"

			// Check if this worktree has issues
			if slices.Contains(status.MissingWorktrees, worktreeName) {
				statusIcon = iconManager.Error()
				statusText = "MISSING"
			}

			if change, exists := status.BranchChanges[worktreeName]; exists {
				statusIcon = iconManager.Warning()
				statusText = "OUT_OF_SYNC"
				info.CurrentBranch = change.OldBranch
			}

			if slices.Contains(status.OrphanedWorktrees, worktreeName) {
				statusIcon = iconManager.Orphaned()
				statusText = "UNTRACKED"
			}

			// For worktrees not in .envrc, mark as "UNTRACKED"
			if info.ExpectedBranch == info.CurrentBranch && info.ExpectedBranch != "" {
				// Check if this worktree is actually tracked in .envrc
				envMapping, err := manager.GetEnvMapping()
				if err == nil {
					if _, exists := envMapping[worktreeName]; !exists {
						statusIcon = iconManager.Info()
						statusText = "UNTRACKED"
					}
				}
			}

			branchDisplay := info.CurrentBranch
			if info.ExpectedBranch != "" && info.ExpectedBranch != info.CurrentBranch {
				branchDisplay = fmt.Sprintf("%s (expected: %s)", info.CurrentBranch, info.ExpectedBranch)
			}

			table.AddRow([]string{worktreeName, branchDisplay, internal.FormatStatusIcon(statusIcon, statusText), info.Path})
		}

		table.Print()

		fmt.Println()
		if !status.InSync {
			PrintInfo("%s", internal.FormatInfo("Run 'gbm status' for detailed information or 'gbm sync' to fix issues"))
		}

		return nil
	},
}

func init() {
	rootCmd.AddCommand(listCmd)
}
</file>

<file path="internal/git.go">
package internal

import (
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strings"

	"github.com/go-git/go-git/v5"
	"github.com/go-git/go-git/v5/plumbing"
	"github.com/go-git/go-git/v5/plumbing/storer"
)

type GitManager struct {
	repo     *git.Repository
	repoPath string
}

type WorktreeInfo struct {
	Name       string
	Path       string
	Branch     string
	IsOrphaned bool
	NeedsSync  bool
	GitStatus  *GitStatus
}

type GitStatus struct {
	IsDirty   bool
	Ahead     int
	Behind    int
	Untracked int
	Modified  int
	Staged    int
}

func (gs *GitStatus) HasChanges() bool {
	return gs.IsDirty || gs.Untracked > 0 || gs.Modified > 0 || gs.Staged > 0
}

// execCommand executes a command with debug output
func execCommand(cmd *exec.Cmd) ([]byte, error) {
	output, err := cmd.Output()
	return output, err
}

// execCommandRun executes a command using Run() instead of Output() with debug output
func execCommandRun(cmd *exec.Cmd) error {
	err := cmd.Run()
	return err
}

// FindGitRoot finds the root directory of the git repository
func FindGitRoot(startPath string) (string, error) {
	// First, try direct git commands from the current directory
	cmd := exec.Command("git", "rev-parse", "--git-dir")
	cmd.Dir = startPath
	gitDirOutput, err := cmd.Output()
	if err == nil {
		gitDir := strings.TrimSpace(string(gitDirOutput))

		// If .git-dir contains "worktrees", we're in a worktree
		if strings.Contains(gitDir, "worktrees") {
			// Extract the main repository path from the worktree git dir
			// Format: /path/to/main/repo/.git/worktrees/worktree-name
			parts := strings.Split(gitDir, "/.git/worktrees/")
			if len(parts) >= 2 {
				return parts[0], nil
			}
		}

		// Check if this is a bare repository
		cmd = exec.Command("git", "rev-parse", "--is-bare-repository")
		cmd.Dir = startPath
		output, err := cmd.Output()
		if err == nil && strings.TrimSpace(string(output)) == "true" {
			// For bare repositories, the git directory is the repository root
			if filepath.IsAbs(gitDir) {
				return filepath.Dir(gitDir), nil
			} else {
				// gitDir is relative (e.g., ".git"), so repository root is startPath
				return startPath, nil
			}
		}

		// Standard git root detection if we're in a regular repo
		cmd = exec.Command("git", "rev-parse", "--show-toplevel")
		cmd.Dir = startPath
		output, err = cmd.Output()
		if err == nil {
			return strings.TrimSpace(string(output)), nil
		}

		// If show-toplevel failed, try alternative detection methods
		// Check if we have a .git directory or file
		gitPath := filepath.Join(startPath, ".git")
		if _, err := os.Stat(gitPath); err == nil {
			// We have a .git entry, so this is likely the repository root
			return startPath, nil
		}

		// If gitDir is absolute, we can derive the repository root
		if filepath.IsAbs(gitDir) {
			// Remove .git suffix to get repository root
			if strings.HasSuffix(gitDir, ".git") {
				return strings.TrimSuffix(gitDir, ".git"), nil
			}
			return filepath.Dir(gitDir), nil
		}
	}

	// If we're not in a git repository, check for git repositories in subdirectories
	// This handles the case where we're in a directory that contains worktrees
	// but isn't itself a git repository
	entries, err := os.ReadDir(startPath)
	if err == nil {
		var foundRepos []string

		for _, entry := range entries {
			if entry.IsDir() {
				subPath := filepath.Join(startPath, entry.Name())

				// Check if this subdirectory is a git repository
				cmd := exec.Command("git", "rev-parse", "--git-dir")
				cmd.Dir = subPath
				gitDirOutput, err := cmd.Output()
				if err == nil {
					gitDir := strings.TrimSpace(string(gitDirOutput))

					// If this is a worktree, get the main repository path
					if strings.Contains(gitDir, "worktrees") {
						parts := strings.Split(gitDir, "/.git/worktrees/")
						if len(parts) >= 2 {
							foundRepos = append(foundRepos, parts[0])
						}
					} else {
						// Check if this is a bare repository
						cmd = exec.Command("git", "rev-parse", "--is-bare-repository")
						cmd.Dir = subPath
						output, err := cmd.Output()
						if err == nil && strings.TrimSpace(string(output)) == "true" {
							// For bare repositories, the git directory is the repository root
							if filepath.IsAbs(gitDir) {
								foundRepos = append(foundRepos, filepath.Dir(gitDir))
							} else {
								// gitDir is relative (e.g., ".git"), so repository root is subPath
								foundRepos = append(foundRepos, subPath)
							}
						} else {
							// If this is a regular git repository, return its root
							cmd = exec.Command("git", "rev-parse", "--show-toplevel")
							cmd.Dir = subPath
							output, err := cmd.Output()
							if err == nil {
								foundRepos = append(foundRepos, strings.TrimSpace(string(output)))
							}
						}
					}
				}
			}
		}

		// If we found repositories in subdirectories, use the first one
		if len(foundRepos) > 0 {
			return foundRepos[0], nil
		}
	}

	return "", fmt.Errorf("not in a git repository and no git repositories found in subdirectories")
}

func NewGitManager(repoPath string) (*GitManager, error) {
	repo, err := git.PlainOpen(repoPath)
	if err != nil {
		return nil, fmt.Errorf("not a git repository: %w", err)
	}

	return &GitManager{
		repo:     repo,
		repoPath: repoPath,
	}, nil
}

func (gm *GitManager) IsGitRepository() bool {
	_, err := git.PlainOpen(gm.repoPath)
	return err == nil
}

func (gm *GitManager) BranchExists(branchName string) (bool, error) {
	refs, err := gm.repo.References()
	if err != nil {
		return false, err
	}

	var found bool
	err = refs.ForEach(func(ref *plumbing.Reference) error {
		if ref.Name().IsBranch() {
			if ref.Name().Short() == branchName {
				found = true
				return storer.ErrStop
			}
		}
		return nil
	})

	if err != nil && err != storer.ErrStop {
		return false, err
	}

	return found, nil
}

func (gm *GitManager) GetWorktrees() ([]*WorktreeInfo, error) {
	cmd := exec.Command("git", "worktree", "list", "--porcelain")
	cmd.Dir = gm.repoPath
	output, err := execCommand(cmd)
	if err != nil {
		return nil, fmt.Errorf("failed to get worktrees: %w", err)
	}

	var infos []*WorktreeInfo
	lines := strings.Split(string(output), "\n")

	var currentWorktree *WorktreeInfo
	for _, line := range lines {
		line = strings.TrimSpace(line)
		if line == "" {
			if currentWorktree != nil {
				infos = append(infos, currentWorktree)
				currentWorktree = nil
			}
			continue
		}

		if strings.HasPrefix(line, "worktree ") {
			path := strings.TrimPrefix(line, "worktree ")
			currentWorktree = &WorktreeInfo{
				Name: filepath.Base(path),
				Path: path,
			}
		} else if strings.HasPrefix(line, "branch ") && currentWorktree != nil {
			branch := strings.TrimPrefix(line, "branch ")
			branch = strings.TrimPrefix(branch, "refs/heads/")
			currentWorktree.Branch = branch
		}
	}

	if currentWorktree != nil {
		infos = append(infos, currentWorktree)
	}

	return infos, nil
}

func (gm *GitManager) CreateWorktree(envVar, branchName, worktreeDir string) error {
	worktreePath := filepath.Join(gm.repoPath, worktreeDir, envVar)

	if _, err := os.Stat(worktreePath); !os.IsNotExist(err) {
		return fmt.Errorf("worktree directory already exists: %s", worktreePath)
	}

	branchExists, err := gm.BranchExists(branchName)
	if err != nil {
		return fmt.Errorf("failed to check if branch exists: %w", err)
	}

	if !branchExists {
		return fmt.Errorf("branch '%s' does not exist", branchName)
	}

	// Check if remote tracking branch exists
	remoteBranch := fmt.Sprintf("origin/%s", branchName)
	cmd := exec.Command("git", "rev-parse", "--verify", remoteBranch)
	cmd.Dir = gm.repoPath
	_, err = execCommand(cmd)

	if err == nil {
		// Remote tracking branch exists, use --track
		cmd = exec.Command("git", "worktree", "add", "--track", "-b", branchName, worktreePath, remoteBranch)
	} else {
		// No remote tracking branch, create worktree without tracking
		cmd = exec.Command("git", "worktree", "add", worktreePath, branchName)
	}

	cmd.Dir = gm.repoPath
	if err := execCommandRun(cmd); err != nil {
		return fmt.Errorf("failed to create worktree: %w", err)
	}

	return nil
}

func (gm *GitManager) RemoveWorktree(worktreePath string) error {
	cmd := exec.Command("git", "worktree", "remove", worktreePath, "--force")
	cmd.Dir = gm.repoPath
	if err := execCommandRun(cmd); err != nil {
		return fmt.Errorf("failed to remove worktree: %w", err)
	}

	return nil
}

func (gm *GitManager) UpdateWorktree(worktreePath, newBranch string) error {
	if err := gm.RemoveWorktree(worktreePath); err != nil {
		return fmt.Errorf("failed to remove old worktree: %w", err)
	}

	worktreeDir := filepath.Dir(worktreePath)
	envVar := filepath.Base(worktreePath)
	relativeWorktreeDir := strings.TrimPrefix(worktreeDir, gm.repoPath+string(filepath.Separator))

	return gm.CreateWorktree(envVar, newBranch, relativeWorktreeDir)
}

func (gm *GitManager) FetchAll() error {
	remote, err := gm.repo.Remote("origin")
	if err != nil {
		return fmt.Errorf("failed to get origin remote: %w", err)
	}

	err = remote.Fetch(&git.FetchOptions{})
	if err != nil && err != git.NoErrAlreadyUpToDate {
		return fmt.Errorf("failed to fetch from remote: %w", err)
	}

	return nil
}

func (gm *GitManager) GetWorktreeStatus(worktreePath string) (*GitStatus, error) {
	if _, err := os.Stat(worktreePath); os.IsNotExist(err) {
		return nil, fmt.Errorf("worktree path does not exist: %s", worktreePath)
	}

	status := &GitStatus{}

	// Get git status
	cmd := exec.Command("git", "status", "--porcelain", "--ahead-behind")
	cmd.Dir = worktreePath
	output, err := execCommand(cmd)
	if err != nil {
		return nil, fmt.Errorf("failed to get git status: %w", err)
	}

	statusLines := strings.Split(string(output), "\n")
	for _, line := range statusLines {
		line = strings.TrimSpace(line)
		if line == "" {
			continue
		}

		status.IsDirty = true

		// Parse git status output
		if len(line) >= 2 {
			indexStatus := line[0]
			worktreeStatus := line[1]

			switch indexStatus {
			case 'A', 'M', 'D', 'R', 'C':
				status.Staged++
			}

			switch worktreeStatus {
			case 'M', 'D':
				status.Modified++
			}

			if indexStatus == '?' && worktreeStatus == '?' {
				status.Untracked++
			}
		}
	}

	// Get ahead/behind info
	cmd = exec.Command("git", "rev-list", "--left-right", "--count", "HEAD...@{upstream}")
	cmd.Dir = worktreePath
	output, err = execCommand(cmd)
	if err == nil {
		parts := strings.Fields(string(output))
		if len(parts) == 2 {
			if _, err := fmt.Sscanf(parts[0], "%d", &status.Ahead); err == nil {
				fmt.Sscanf(parts[1], "%d", &status.Behind)
			}
		}
	}

	return status, nil
}

func (gm *GitManager) GetStatusIcon(gitStatus *GitStatus) string {
	iconManager := GetGlobalIconManager()

	if gitStatus == nil {
		return iconManager.Error()
	}

	var icons []string

	// Check ahead/behind first
	if gitStatus.Ahead > 0 && gitStatus.Behind > 0 {
		icons = append(icons, iconManager.GitDiverged())
	} else if gitStatus.Ahead > 0 {
		icons = append(icons, iconManager.GitAhead())
	} else if gitStatus.Behind > 0 {
		icons = append(icons, iconManager.GitBehind())
	}

	// Check dirty status
	if gitStatus.IsDirty {
		if gitStatus.Staged > 0 {
			icons = append(icons, "●")
		}
		if gitStatus.Modified > 0 {
			icons = append(icons, "✚")
		}
		if gitStatus.Untracked > 0 {
			icons = append(icons, "?")
		}
	}

	if len(icons) == 0 {
		return iconManager.Success()
	}

	return strings.Join(icons, "")
}

func (gm *GitManager) CreateBranch(branchName, baseBranch string) error {
	if baseBranch == "" {
		baseBranch = "HEAD"
	}

	cmd := exec.Command("git", "branch", branchName, baseBranch)
	cmd.Dir = gm.repoPath
	if err := execCommandRun(cmd); err != nil {
		return fmt.Errorf("failed to create branch: %w", err)
	}

	return nil
}

func (gm *GitManager) AddWorktree(worktreeName, branchName string, createBranch bool) error {
	worktreeDir := filepath.Join(gm.repoPath, "worktrees")
	worktreePath := filepath.Join(worktreeDir, worktreeName)

	// Check if worktree already exists
	if _, err := os.Stat(worktreePath); !os.IsNotExist(err) {
		return fmt.Errorf("worktree '%s' already exists", worktreeName)
	}

	// Create worktrees directory if it doesn't exist
	if err := os.MkdirAll(worktreeDir, 0755); err != nil {
		return fmt.Errorf("failed to create worktrees directory: %w", err)
	}

	var cmd *exec.Cmd
	if createBranch {
		// Check if branch already exists
		branchExists, err := gm.BranchExists(branchName)
		if err != nil {
			return fmt.Errorf("failed to check if branch exists: %w", err)
		}

		if branchExists {
			// Branch exists, create worktree on existing branch
			cmd = exec.Command("git", "worktree", "add", worktreePath, branchName)
		} else {
			// Create new branch and worktree
			cmd = exec.Command("git", "worktree", "add", "-b", branchName, worktreePath)
		}
	} else {
		// Create worktree on existing branch
		branchExists, err := gm.BranchExists(branchName)
		if err != nil {
			return fmt.Errorf("failed to check if branch exists: %w", err)
		}

		if !branchExists {
			return fmt.Errorf("branch '%s' does not exist", branchName)
		}

		// Check if remote tracking branch exists
		remoteBranch := fmt.Sprintf("origin/%s", branchName)
		checkCmd := exec.Command("git", "rev-parse", "--verify", remoteBranch)
		checkCmd.Dir = gm.repoPath
		_, err = execCommand(checkCmd)

		if err == nil {
			// Remote tracking branch exists, use --track
			cmd = exec.Command("git", "worktree", "add", "--track", "-b", branchName, worktreePath, remoteBranch)
		} else {
			// No remote tracking branch, create worktree without tracking
			cmd = exec.Command("git", "worktree", "add", worktreePath, branchName)
		}
	}

	cmd.Dir = gm.repoPath
	if err := execCommandRun(cmd); err != nil {
		return fmt.Errorf("failed to add worktree (command: %s): %w", strings.Join(cmd.Args, " "), err)
	}

	return nil
}

func (gm *GitManager) GetCurrentBranch() (string, error) {
	cmd := exec.Command("git", "rev-parse", "--abbrev-ref", "HEAD")
	cmd.Dir = gm.repoPath
	output, err := execCommand(cmd)
	if err != nil {
		return "", fmt.Errorf("failed to get current branch: %w", err)
	}

	return strings.TrimSpace(string(output)), nil
}

func (gm *GitManager) GetRemoteBranches() ([]string, error) {
	cmd := exec.Command("git", "branch", "-r")
	cmd.Dir = gm.repoPath
	output, err := execCommand(cmd)
	if err != nil {
		return nil, fmt.Errorf("failed to get remote branches: %w", err)
	}

	var branches []string
	lines := strings.Split(string(output), "\n")
	for _, line := range lines {
		line = strings.TrimSpace(line)
		if line == "" || strings.Contains(line, "HEAD") {
			continue
		}

		// Remove "origin/" prefix
		if strings.HasPrefix(line, "origin/") {
			branch := strings.TrimPrefix(line, "origin/")
			branches = append(branches, branch)
		}
	}

	return branches, nil
}

func (gm *GitManager) PushWorktree(worktreePath string) error {
	if _, err := os.Stat(worktreePath); os.IsNotExist(err) {
		return fmt.Errorf("worktree path does not exist: %s", worktreePath)
	}

	// Get the current branch
	cmd := exec.Command("git", "rev-parse", "--abbrev-ref", "HEAD")
	cmd.Dir = worktreePath
	output, err := execCommand(cmd)
	if err != nil {
		return fmt.Errorf("failed to get current branch: %w", err)
	}

	currentBranch := strings.TrimSpace(string(output))

	// Check if upstream is set
	cmd = exec.Command("git", "rev-parse", "--abbrev-ref", "@{upstream}")
	cmd.Dir = worktreePath
	_, err = execCommand(cmd)

	if err != nil {
		// No upstream set, push with -u flag
		cmd = exec.Command("git", "push", "-u", "origin", currentBranch)
	} else {
		// Upstream is set, simple push
		cmd = exec.Command("git", "push")
	}

	cmd.Dir = worktreePath
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr

	return cmd.Run()
}

func (gm *GitManager) PullWorktree(worktreePath string) error {
	if _, err := os.Stat(worktreePath); os.IsNotExist(err) {
		return fmt.Errorf("worktree path does not exist: %s", worktreePath)
	}

	// Get the current branch
	cmd := exec.Command("git", "rev-parse", "--abbrev-ref", "HEAD")
	cmd.Dir = worktreePath
	output, err := execCommand(cmd)
	if err != nil {
		return fmt.Errorf("failed to get current branch: %w", err)
	}

	currentBranch := strings.TrimSpace(string(output))

	// Check if upstream is set
	cmd = exec.Command("git", "rev-parse", "--abbrev-ref", "@{upstream}")
	cmd.Dir = worktreePath
	_, err = execCommand(cmd)

	if err != nil {
		// No upstream set, try to set it and pull
		remoteBranch := fmt.Sprintf("origin/%s", currentBranch)

		// Check if remote branch exists
		cmd = exec.Command("git", "rev-parse", "--verify", remoteBranch)
		cmd.Dir = worktreePath
		_, err = execCommand(cmd)

		if err == nil {
			// Remote branch exists, set upstream and pull
			cmd = exec.Command("git", "branch", "--set-upstream-to", remoteBranch)
			cmd.Dir = worktreePath
			if err := execCommandRun(cmd); err != nil {
				return fmt.Errorf("failed to set upstream: %w", err)
			}

			// Now pull
			cmd = exec.Command("git", "pull")
		} else {
			// Remote branch doesn't exist, try to pull with explicit remote and branch
			cmd = exec.Command("git", "pull", "origin", currentBranch)
		}
	} else {
		// Upstream is set, simple pull
		cmd = exec.Command("git", "pull")
	}

	cmd.Dir = worktreePath
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr

	return cmd.Run()
}

func (gm *GitManager) IsInWorktree(currentPath string) (bool, string, error) {
	// Check if we're in a worktree
	cmd := exec.Command("git", "rev-parse", "--show-toplevel")
	cmd.Dir = currentPath
	output, err := execCommand(cmd)
	if err != nil {
		return false, "", fmt.Errorf("not in a git repository: %w", err)
	}

	worktreePath := strings.TrimSpace(string(output))

	// Check if this is a worktree by checking if it's under the worktrees directory
	worktreePrefix := filepath.Join(gm.repoPath, "worktrees")
	if strings.HasPrefix(worktreePath, worktreePrefix) {
		worktreeName := filepath.Base(worktreePath)
		return true, worktreeName, nil
	}

	return false, "", nil
}
</file>

<file path="internal/manager.go">
package internal

import (
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"time"
)

type Manager struct {
	config     *Config
	gitManager *GitManager
	envMapping *EnvMapping
	repoPath   string
	gbmDir     string
}

type WorktreeListInfo struct {
	Path           string
	ExpectedBranch string
	CurrentBranch  string
	GitStatus      *GitStatus
}

type SyncStatus struct {
	InSync            bool
	MissingWorktrees  []string
	OrphanedWorktrees []string
	BranchChanges     map[string]BranchChange
}

type BranchChange struct {
	OldBranch string
	NewBranch string
}

func NewManager(repoPath string) (*Manager, error) {
	gitManager, err := NewGitManager(repoPath)
	if err != nil {
		return nil, err
	}

	gbmDir := filepath.Join(repoPath, ".gbm")
	config, err := LoadConfig(gbmDir)
	if err != nil {
		return nil, fmt.Errorf("failed to load config: %w", err)
	}

	// Initialize the global icon manager with the loaded config
	iconManager := NewIconManager(config)
	SetGlobalIconManager(iconManager)

	return &Manager{
		config:     config,
		gitManager: gitManager,
		repoPath:   repoPath,
		gbmDir:     gbmDir,
	}, nil
}

func (m *Manager) LoadEnvMapping(envrcPath string) error {
	if envrcPath == "" {
		envrcPath = filepath.Join(m.repoPath, ".envrc")
	}

	if !filepath.IsAbs(envrcPath) {
		envrcPath = filepath.Join(m.repoPath, envrcPath)
	}

	mapping, err := ParseEnvrc(envrcPath)
	if err != nil {
		return err
	}

	m.envMapping = mapping
	return nil
}

func (m *Manager) Initialize(force, fetch bool) error {
	if !m.gitManager.IsGitRepository() {
		return fmt.Errorf("not a git repository")
	}

	if m.envMapping == nil {
		return fmt.Errorf("no .envrc mapping loaded")
	}

	if fetch {
		if err := m.gitManager.FetchAll(); err != nil {
			return fmt.Errorf("failed to fetch: %w", err)
		}
	}

	worktreeDir := filepath.Join(m.repoPath, m.config.Settings.WorktreePrefix)
	if !force {
		if _, err := os.Stat(worktreeDir); !os.IsNotExist(err) {
			return fmt.Errorf("worktree directory already exists, use --force to override")
		}
	}

	for envVar, branchName := range m.envMapping.Variables {
		err := m.gitManager.CreateWorktree(envVar, branchName, m.config.Settings.WorktreePrefix)
		if err != nil {
			return fmt.Errorf("failed to create worktree for %s: %w", envVar, err)
		}
	}

	var trackedVars []string
	for envVar := range m.envMapping.Variables {
		trackedVars = append(trackedVars, envVar)
	}
	m.config.State.TrackedVars = trackedVars
	m.config.State.LastSync = time.Now()

	return m.config.Save(m.gbmDir)
}

func (m *Manager) GetSyncStatus() (*SyncStatus, error) {
	if m.envMapping == nil {
		return nil, fmt.Errorf("no .envrc mapping loaded")
	}

	status := &SyncStatus{
		InSync:            true,
		MissingWorktrees:  []string{},
		OrphanedWorktrees: []string{},
		BranchChanges:     make(map[string]BranchChange),
	}

	worktrees, err := m.gitManager.GetWorktrees()
	if err != nil {
		return nil, fmt.Errorf("failed to get worktrees: %w", err)
	}

	worktreeMap := make(map[string]*WorktreeInfo)
	for _, wt := range worktrees {
		if strings.HasPrefix(wt.Path, filepath.Join(m.repoPath, m.config.Settings.WorktreePrefix)) {
			worktreeMap[wt.Name] = wt
		}
	}

	for envVar, expectedBranch := range m.envMapping.Variables {
		if wt, exists := worktreeMap[envVar]; exists {
			if wt.Branch != expectedBranch {
				status.BranchChanges[envVar] = BranchChange{
					OldBranch: wt.Branch,
					NewBranch: expectedBranch,
				}
				status.InSync = false
			}
			delete(worktreeMap, envVar)
		} else {
			status.MissingWorktrees = append(status.MissingWorktrees, envVar)
			status.InSync = false
		}
	}

	for envVar := range worktreeMap {
		status.OrphanedWorktrees = append(status.OrphanedWorktrees, envVar)
		status.InSync = false
	}

	return status, nil
}

func (m *Manager) Sync(dryRun, force, fetch bool) error {
	if m.envMapping == nil {
		return fmt.Errorf("no .envrc mapping loaded")
	}

	if fetch {
		if err := m.gitManager.FetchAll(); err != nil {
			return fmt.Errorf("failed to fetch: %w", err)
		}
	}

	status, err := m.GetSyncStatus()
	if err != nil {
		return err
	}

	if status.InSync {
		return nil
	}

	if dryRun {
		return nil
	}

	for _, envVar := range status.MissingWorktrees {
		branchName := m.envMapping.Variables[envVar]
		err := m.gitManager.CreateWorktree(envVar, branchName, m.config.Settings.WorktreePrefix)
		if err != nil {
			return fmt.Errorf("failed to create worktree for %s: %w", envVar, err)
		}
	}

	for envVar, change := range status.BranchChanges {
		worktreePath := filepath.Join(m.repoPath, m.config.Settings.WorktreePrefix, envVar)
		err := m.gitManager.UpdateWorktree(worktreePath, change.NewBranch)
		if err != nil {
			return fmt.Errorf("failed to update worktree for %s: %w", envVar, err)
		}
	}

	if force {
		for _, envVar := range status.OrphanedWorktrees {
			worktreePath := filepath.Join(m.repoPath, m.config.Settings.WorktreePrefix, envVar)
			err := m.gitManager.RemoveWorktree(worktreePath)
			if err != nil {
				return fmt.Errorf("failed to remove orphaned worktree %s: %w", envVar, err)
			}
		}
	}

	var trackedVars []string
	for envVar := range m.envMapping.Variables {
		trackedVars = append(trackedVars, envVar)
	}
	m.config.State.TrackedVars = trackedVars
	m.config.State.LastSync = time.Now()

	return m.config.Save(m.gbmDir)
}

func (m *Manager) ValidateEnvrc() error {
	if m.envMapping == nil {
		return fmt.Errorf("no .envrc mapping loaded")
	}

	for envVar, branchName := range m.envMapping.Variables {
		exists, err := m.gitManager.BranchExists(branchName)
		if err != nil {
			return fmt.Errorf("failed to check branch %s for %s: %w", branchName, envVar, err)
		}
		if !exists {
			return fmt.Errorf("branch '%s' for environment variable '%s' does not exist", branchName, envVar)
		}
	}

	return nil
}

func (m *Manager) CleanOrphaned(force bool) error {
	status, err := m.GetSyncStatus()
	if err != nil {
		return err
	}

	for _, envVar := range status.OrphanedWorktrees {
		worktreePath := filepath.Join(m.repoPath, m.config.Settings.WorktreePrefix, envVar)

		if !force {
			fmt.Printf("Remove orphaned worktree %s? [y/N]: ", envVar)
			var response string
			fmt.Scanln(&response)
			if strings.ToLower(response) != "y" && strings.ToLower(response) != "yes" {
				continue
			}
		}

		err := m.gitManager.RemoveWorktree(worktreePath)
		if err != nil {
			return fmt.Errorf("failed to remove orphaned worktree %s: %w", envVar, err)
		}
	}

	return nil
}

func (m *Manager) GetEnvMapping() (map[string]string, error) {
	if m.envMapping == nil {
		return nil, fmt.Errorf("no .envrc mapping loaded")
	}
	return m.envMapping.Variables, nil
}

func (m *Manager) BranchExists(branchName string) (bool, error) {
	return m.gitManager.BranchExists(branchName)
}

func (m *Manager) GetWorktreeList() (map[string]*WorktreeListInfo, error) {
	if m.envMapping == nil {
		return nil, fmt.Errorf("no .envrc mapping loaded")
	}

	result := make(map[string]*WorktreeListInfo)

	for envVar, expectedBranch := range m.envMapping.Variables {
		worktreePath := filepath.Join(m.repoPath, m.config.Settings.WorktreePrefix, envVar)

		info := &WorktreeListInfo{
			Path:           worktreePath,
			ExpectedBranch: expectedBranch,
			CurrentBranch:  "",
		}

		if _, err := os.Stat(worktreePath); err == nil {
			worktrees, err := m.gitManager.GetWorktrees()
			if err == nil {
				for _, wt := range worktrees {
					if wt.Path == worktreePath {
						info.CurrentBranch = wt.Branch
						break
					}
				}
			}

			// Get git status for the worktree
			if gitStatus, err := m.gitManager.GetWorktreeStatus(worktreePath); err == nil {
				info.GitStatus = gitStatus
			}
		}

		result[envVar] = info
	}

	return result, nil
}

func (m *Manager) GetStatusIcon(gitStatus *GitStatus) string {
	return m.gitManager.GetStatusIcon(gitStatus)
}

func (m *Manager) GetWorktreePath(worktreeName string) (string, error) {
	worktreePath := filepath.Join(m.repoPath, m.config.Settings.WorktreePrefix, worktreeName)

	if _, err := os.Stat(worktreePath); os.IsNotExist(err) {
		return "", fmt.Errorf("worktree directory '%s' does not exist", worktreeName)
	}

	return worktreePath, nil
}

func (m *Manager) GetAllWorktrees() (map[string]*WorktreeListInfo, error) {
	result := make(map[string]*WorktreeListInfo)

	// Get all actual worktrees from git
	worktrees, err := m.gitManager.GetWorktrees()
	if err != nil {
		return nil, fmt.Errorf("failed to get worktrees: %w", err)
	}

	worktreePrefix := filepath.Join(m.repoPath, m.config.Settings.WorktreePrefix)

	for _, wt := range worktrees {
		if strings.HasPrefix(wt.Path, worktreePrefix) {
			// Extract worktree name from path
			worktreeName := filepath.Base(wt.Path)

			info := &WorktreeListInfo{
				Path:          wt.Path,
				CurrentBranch: wt.Branch,
			}

			// Set expected branch if it's tracked in .envrc
			if m.envMapping != nil {
				if expectedBranch, exists := m.envMapping.Variables[worktreeName]; exists {
					info.ExpectedBranch = expectedBranch
				} else {
					info.ExpectedBranch = wt.Branch // Use current branch as expected for ad hoc worktrees
				}
			} else {
				info.ExpectedBranch = wt.Branch
			}

			// Get git status for the worktree
			if gitStatus, err := m.gitManager.GetWorktreeStatus(wt.Path); err == nil {
				info.GitStatus = gitStatus
			}

			result[worktreeName] = info
		}
	}

	return result, nil
}

func (m *Manager) AddWorktree(worktreeName, branchName string, createBranch bool) error {
	err := m.gitManager.AddWorktree(worktreeName, branchName, createBranch)
	if err != nil {
		return err
	}

	// Track this worktree as ad hoc if it's not in .envrc
	if m.envMapping != nil {
		if _, exists := m.envMapping.Variables[worktreeName]; !exists {
			// Add to ad hoc worktrees list if not already there
			if !contains(m.config.State.AdHocWorktrees, worktreeName) {
				m.config.State.AdHocWorktrees = append(m.config.State.AdHocWorktrees, worktreeName)
				// Save the updated config
				if saveErr := m.config.Save(m.gbmDir); saveErr != nil {
					// Log warning but don't fail the operation
					fmt.Printf("Warning: failed to save config: %v\n", saveErr)
				}
			}
		}
	}

	return nil
}

// Helper function to check if a slice contains a string
func contains(slice []string, item string) bool {
	for _, s := range slice {
		if s == item {
			return true
		}
	}
	return false
}

func (m *Manager) GetRemoteBranches() ([]string, error) {
	return m.gitManager.GetRemoteBranches()
}

func (m *Manager) GetCurrentBranch() (string, error) {
	return m.gitManager.GetCurrentBranch()
}

func (m *Manager) PushWorktree(worktreeName string) error {
	worktreePath := filepath.Join(m.repoPath, m.config.Settings.WorktreePrefix, worktreeName)
	return m.gitManager.PushWorktree(worktreePath)
}

func (m *Manager) PullWorktree(worktreeName string) error {
	worktreePath := filepath.Join(m.repoPath, m.config.Settings.WorktreePrefix, worktreeName)
	return m.gitManager.PullWorktree(worktreePath)
}

func (m *Manager) IsInWorktree(currentPath string) (bool, string, error) {
	return m.gitManager.IsInWorktree(currentPath)
}

func (m *Manager) PushAllWorktrees() error {
	worktrees, err := m.GetAllWorktrees()
	if err != nil {
		return fmt.Errorf("failed to get worktrees: %w", err)
	}

	for name, info := range worktrees {
		fmt.Printf("Pushing worktree '%s'...\n", name)
		if err := m.gitManager.PushWorktree(info.Path); err != nil {
			fmt.Printf("Failed to push worktree '%s': %v\n", name, err)
			continue
		}
		fmt.Printf("Successfully pushed worktree '%s'\n", name)
	}

	return nil
}

func (m *Manager) PullAllWorktrees() error {
	worktrees, err := m.GetAllWorktrees()
	if err != nil {
		return fmt.Errorf("failed to get worktrees: %w", err)
	}

	for name, info := range worktrees {
		fmt.Printf("Pulling worktree '%s'...\n", name)
		if err := m.gitManager.PullWorktree(info.Path); err != nil {
			fmt.Printf("Failed to pull worktree '%s': %v\n", name, err)
			continue
		}
		fmt.Printf("Successfully pulled worktree '%s'\n", name)
	}

	return nil
}

func (m *Manager) RemoveWorktree(worktreeName string) error {
	worktreePath := filepath.Join(m.repoPath, m.config.Settings.WorktreePrefix, worktreeName)

	// Remove the worktree using git
	if err := m.gitManager.RemoveWorktree(worktreePath); err != nil {
		return fmt.Errorf("failed to remove worktree: %w", err)
	}

	// Remove from ad hoc worktrees list if it exists there
	for i, name := range m.config.State.AdHocWorktrees {
		if name == worktreeName {
			m.config.State.AdHocWorktrees = append(m.config.State.AdHocWorktrees[:i], m.config.State.AdHocWorktrees[i+1:]...)
			break
		}
	}

	// Save the updated config
	if err := m.config.Save(m.gbmDir); err != nil {
		// Log warning but don't fail the operation
		fmt.Printf("Warning: failed to save config: %v\n", err)
	}

	return nil
}

func (m *Manager) GetWorktreeStatus(worktreePath string) (*GitStatus, error) {
	return m.gitManager.GetWorktreeStatus(worktreePath)
}

func (m *Manager) SetCurrentWorktree(worktreeName string) error {
	// Update previous worktree before changing current
	if m.config.State.CurrentWorktree != "" && m.config.State.CurrentWorktree != worktreeName {
		m.config.State.PreviousWorktree = m.config.State.CurrentWorktree
	}
	m.config.State.CurrentWorktree = worktreeName
	return m.config.Save(m.gbmDir)
}

func (m *Manager) GetPreviousWorktree() string {
	return m.config.State.PreviousWorktree
}

func (m *Manager) GetCurrentWorktree() string {
	return m.config.State.CurrentWorktree
}

func (m *Manager) GetSortedWorktreeNames(worktrees map[string]*WorktreeListInfo) []string {
	var envrcNames []string
	var adHocNames []string

	// Get .envrc mapping if available
	envMapping := make(map[string]string)
	if m.envMapping != nil {
		envMapping = m.envMapping.Variables
	}

	// Separate worktrees into .envrc tracked and ad hoc
	for name := range worktrees {
		if _, exists := envMapping[name]; exists {
			envrcNames = append(envrcNames, name)
		} else {
			adHocNames = append(adHocNames, name)
		}
	}

	// Sort .envrc names alphabetically
	sort.Strings(envrcNames)

	// Sort ad hoc names by creation time (directory modification time) descending
	sort.Slice(adHocNames, func(i, j int) bool {
		pathI := worktrees[adHocNames[i]].Path
		pathJ := worktrees[adHocNames[j]].Path

		statI, errI := os.Stat(pathI)
		statJ, errJ := os.Stat(pathJ)

		// If we can't get stats, fall back to alphabetical
		if errI != nil || errJ != nil {
			return adHocNames[i] < adHocNames[j]
		}

		// Sort by modification time descending (newer first)
		return statI.ModTime().After(statJ.ModTime())
	})

	// Return .envrc worktrees first, then ad hoc worktrees
	result := make([]string, 0, len(envrcNames)+len(adHocNames))
	result = append(result, envrcNames...)
	result = append(result, adHocNames...)

	return result
}
</file>

<file path="cmd/status.go">
package cmd

import (
	"fmt"
	"os"
	"slices"

	"gbm/internal"

	"github.com/spf13/cobra"
)

var statusCmd = &cobra.Command{
	Use:   "status",
	Short: "Show current sync status between .envrc and actual worktrees",
	Long: `Show current sync status between .envrc and actual worktrees.

Displays which branches are out of sync, lists missing worktrees, and shows orphaned worktrees.`,
	RunE: func(cmd *cobra.Command, args []string) error {
		wd, err := os.Getwd()
		if err != nil {
			return fmt.Errorf("failed to get working directory: %w", err)
		}

		repoRoot, err := internal.FindGitRoot(wd)
		if err != nil {
			return fmt.Errorf("failed to find git repository root: %w", err)
		}
		PrintVerbose("Checking status from repository root: %s", repoRoot)

		manager, err := internal.NewManager(repoRoot)
		if err != nil {
			return err
		}

		PrintVerbose("Loading .envrc configuration from: %s", GetConfigPath())
		if err := manager.LoadEnvMapping(GetConfigPath()); err != nil {
			return fmt.Errorf("failed to load .envrc: %w", err)
		}

		PrintVerbose("Retrieving sync status from manager")
		status, err := manager.GetSyncStatus()
		if err != nil {
			return err
		}

		PrintVerbose("Fetching worktree list for status display")
		// Get all worktrees (including those created with gbm add)
		worktrees, err := manager.GetAllWorktrees()
		if err != nil {
			return fmt.Errorf("failed to get worktree list: %w", err)
		}

		PrintVerbose("Building status table with %d worktrees", len(worktrees))
		table := internal.NewTable([]string{"WORKTREE", "BRANCH", "GIT STATUS", "SYNC STATUS"})

		// Get sorted worktree names (.envrc first, then ad hoc by creation time desc)
		sortedNames := manager.GetSortedWorktreeNames(worktrees)

		// Add rows for each worktree
		for _, worktreeName := range sortedNames {
			info := worktrees[worktreeName]
			var syncStatus string

			// Check for missing worktrees
			if slices.Contains(status.MissingWorktrees, worktreeName) {
				syncStatus = "MISSING"
			}

			// Check for branch changes
			if change, exists := status.BranchChanges[worktreeName]; exists {
				syncStatus = fmt.Sprintf("OUT_OF_SYNC (%s → %s)", change.OldBranch, change.NewBranch)
			}

			// Check for orphaned worktrees
			if slices.Contains(status.OrphanedWorktrees, worktreeName) {
				syncStatus = "UNTRACKED"
			}

			// Check if this is an untracked worktree (not in .envrc)
			if syncStatus == "" {
				envMapping, err := manager.GetEnvMapping()
				if err == nil {
					if _, exists := envMapping[worktreeName]; !exists {
						syncStatus = internal.FormatInfo("UNTRACKED")
					} else {
						syncStatus = internal.FormatSuccess("IN_SYNC")
					}
				} else {
					syncStatus = internal.FormatSuccess("IN_SYNC")
				}
			}

			// Get git status icon
			gitStatusIcon := internal.FormatGitStatus(info.GitStatus)

			branchDisplay := info.CurrentBranch
			if info.ExpectedBranch != "" && info.ExpectedBranch != info.CurrentBranch {
				branchDisplay = fmt.Sprintf("%s (expected: %s)", info.CurrentBranch, info.ExpectedBranch)
			}

			table.AddRow([]string{worktreeName, branchDisplay, gitStatusIcon, syncStatus})
		}

		table.Print()

		if !status.InSync {
			fmt.Println()
			PrintInfo("%s", internal.FormatInfo("Run 'gbm sync' to synchronize changes"))
		}
		return nil
	},
}

func init() {
	rootCmd.AddCommand(statusCmd)
}
</file>

</files>
