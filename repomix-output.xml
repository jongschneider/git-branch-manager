This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.claude/
  settings.local.json
cmd/
  add.go
  check.go
  clean.go
  clone.go
  completion.go
  info.go
  init.go
  list.go
  pull.go
  push.go
  remove.go
  root.go
  shell-integration.go
  status.go
  switch.go
  sync.go
  validate.go
docs/
  libs/
    charmbracelet_lipgloss_readme.md
  info_ascii_mockup.md
  info_prd.md
  jira_completion_claude_desktop.md
  jira_list_raw.md
  jira_prompt.md
  spec.md
  todo.md
internal/
  scripts/
    git-bare-clone.sh
  config.go
  git.go
  info_renderer.go
  jira.go
  manager.go
  styles.go
  table.go
tools/
  strip-whitespace.sh
.envrc
.envrc.example
CLAUDE.md
go.mod
main.go
README.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".envrc">
# Example .envrc file for gbm (Git Branch Manager)
# Each environment variable maps to a specific branch

# Long-living environment branches
PROD=production/2025-05-1
PREVIEW=production/2025-06-1
MAIN=master
STAGING=feature/new-api

# Development branches
DEV=develop
HOTFIX=hotfix/urgent-fix

# Feature branches
NEW_FEATURE=feature/user-auth
API_UPDATE=feature/api-v2
</file>

<file path=".claude/settings.local.json">
{
  "permissions": {
    "allow": [
      "Bash(go build:*)",
      "Bash(go install:*)"
    ],
    "deny": []
  }
}
</file>

<file path="cmd/info.go">
package cmd

import (
	"encoding/json"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strconv"
	"strings"
	"time"

	"gbm/internal"

	"github.com/spf13/cobra"
)

var infoCmd = &cobra.Command{
	Use:   "info <worktree-name>",
	Short: "Display detailed information about a worktree",
	Long: `Display comprehensive information about a specific worktree including:
- Worktree metadata (name, path, branch, creation date)
- Git status and branch information
- JIRA ticket details (if the worktree name matches a JIRA key)
- Recent commits and modified files`,
	Args: cobra.ExactArgs(1),
	RunE: runInfoCommand,
}

func runInfoCommand(cmd *cobra.Command, args []string) error {
	worktreeName := args[0]

	// Handle current directory reference
	if worktreeName == "." {
		currentPath, err := os.Getwd()
		if err != nil {
			return fmt.Errorf("failed to get current directory: %w", err)
		}
		worktreeName = filepath.Base(currentPath)
	}

	// Find git root
	gitRoot, err := internal.FindGitRoot(".")
	if err != nil {
		return fmt.Errorf("not in a git repository: %w", err)
	}

	// Initialize git manager
	gitManager, err := internal.NewGitManager(gitRoot)
	if err != nil {
		return fmt.Errorf("failed to initialize git manager: %w", err)
	}

	// Get worktree information
	worktreeInfo, err := getWorktreeInfo(gitManager, worktreeName)
	if err != nil {
		return fmt.Errorf("failed to get worktree info: %w", err)
	}

	// Display the information
	displayWorktreeInfo(worktreeInfo)

	return nil
}

func getWorktreeInfo(gitManager *internal.GitManager, worktreeName string) (*internal.WorktreeInfoData, error) {
	// Get all worktrees
	worktrees, err := gitManager.GetWorktrees()
	if err != nil {
		return nil, fmt.Errorf("failed to get worktrees: %w", err)
	}

	// Find the specific worktree
	var targetWorktree *internal.WorktreeInfo
	for _, wt := range worktrees {
		if wt.Name == worktreeName {
			targetWorktree = wt
			break
		}
	}

	if targetWorktree == nil {
		return nil, fmt.Errorf("worktree '%s' not found", worktreeName)
	}

	// Get git status for the worktree
	gitStatus, err := gitManager.GetWorktreeStatus(targetWorktree.Path)
	if err != nil {
		PrintVerbose("Failed to get git status for worktree %s: %v", worktreeName, err)
		gitStatus = nil
	}

	// Get worktree creation time
	createdAt, err := getWorktreeCreationTime(targetWorktree.Path)
	if err != nil {
		PrintVerbose("Failed to get creation time for worktree %s: %v", worktreeName, err)
	}

	// Get recent commits
	commits, err := getRecentCommits(targetWorktree.Path, 5)
	if err != nil {
		PrintVerbose("Failed to get recent commits for worktree %s: %v", worktreeName, err)
	}

	// Get modified files
	modifiedFiles, err := getModifiedFiles(targetWorktree.Path)
	if err != nil {
		PrintVerbose("Failed to get modified files for worktree %s: %v", worktreeName, err)
	}

	// Get base branch info
	baseInfo, err := getBaseBranchInfo(targetWorktree.Path)
	if err != nil {
		PrintVerbose("Failed to get base branch info for worktree %s: %v", worktreeName, err)
	}

	// Try to get JIRA ticket details if the worktree name matches a JIRA key
	var jiraTicket *internal.JiraTicketDetails
	if internal.IsJiraKey(worktreeName) {
		jiraTicket, err = getJiraTicketDetails(worktreeName)
		if err != nil {
			PrintVerbose("Failed to get JIRA ticket details for %s: %v", worktreeName, err)
		}
	}

	return &internal.WorktreeInfoData{
		Name:          worktreeName,
		Path:          targetWorktree.Path,
		Branch:        targetWorktree.Branch,
		CreatedAt:     createdAt,
		GitStatus:     gitStatus,
		BaseInfo:      baseInfo,
		Commits:       commits,
		ModifiedFiles: modifiedFiles,
		JiraTicket:    jiraTicket,
	}, nil
}

func displayWorktreeInfo(data *internal.WorktreeInfoData) {
	renderer := internal.NewInfoRenderer()
	output := renderer.RenderWorktreeInfo(data)
	fmt.Print(output)
}

func getWorktreeCreationTime(worktreePath string) (time.Time, error) {
	stat, err := os.Stat(worktreePath)
	if err != nil {
		return time.Time{}, err
	}
	return stat.ModTime(), nil
}

func getRecentCommits(worktreePath string, count int) ([]internal.CommitInfo, error) {
	cmd := exec.Command("git", "log", fmt.Sprintf("-%d", count), "--oneline", "--format=%H|%s|%an|%ct")
	cmd.Dir = worktreePath
	output, err := cmd.Output()
	if err != nil {
		return nil, err
	}

	var commits []internal.CommitInfo
	lines := strings.Split(strings.TrimSpace(string(output)), "\n")
	for _, line := range lines {
		if line == "" {
			continue
		}
		parts := strings.Split(line, "|")
		if len(parts) != 4 {
			continue
		}

		timestamp, err := strconv.ParseInt(parts[3], 10, 64)
		if err != nil {
			continue
		}

		commits = append(commits, internal.CommitInfo{
			Hash:      parts[0],
			Message:   parts[1],
			Author:    parts[2],
			Timestamp: time.Unix(timestamp, 0),
		})
	}

	return commits, nil
}

func getModifiedFiles(worktreePath string) ([]internal.FileChange, error) {
	// Get unstaged changes
	cmd := exec.Command("git", "diff", "--numstat")
	cmd.Dir = worktreePath
	output, err := cmd.Output()
	if err != nil {
		return nil, err
	}

	var files []internal.FileChange
	
	// Parse unstaged changes
	lines := strings.Split(strings.TrimSpace(string(output)), "\n")
	for _, line := range lines {
		if line == "" {
			continue
		}
		parts := strings.Fields(line)
		if len(parts) != 3 {
			continue
		}

		additions, _ := strconv.Atoi(parts[0])
		deletions, _ := strconv.Atoi(parts[1])
		path := parts[2]

		// Determine status based on changes
		status := "M"
		if additions > 0 && deletions == 0 {
			status = "A"
		} else if additions == 0 && deletions > 0 {
			status = "D"
		}

		files = append(files, internal.FileChange{
			Path:      path,
			Status:    status,
			Additions: additions,
			Deletions: deletions,
		})
	}

	// Get staged changes
	cmd = exec.Command("git", "diff", "--cached", "--numstat")
	cmd.Dir = worktreePath
	output, err = cmd.Output()
	if err == nil {
		lines = strings.Split(strings.TrimSpace(string(output)), "\n")
		for _, line := range lines {
			if line == "" {
				continue
			}
			parts := strings.Fields(line)
			if len(parts) != 3 {
				continue
			}

			additions, _ := strconv.Atoi(parts[0])
			deletions, _ := strconv.Atoi(parts[1])
			path := parts[2]

			// Check if file already exists in our list
			found := false
			for i, existing := range files {
				if existing.Path == path {
					// Update existing entry with staged changes
					files[i].Additions += additions
					files[i].Deletions += deletions
					found = true
					break
				}
			}

			if !found {
				status := "M"
				if additions > 0 && deletions == 0 {
					status = "A"
				} else if additions == 0 && deletions > 0 {
					status = "D"
				}

				files = append(files, internal.FileChange{
					Path:      path,
					Status:    status,
					Additions: additions,
					Deletions: deletions,
				})
			}
		}
	}

	return files, nil
}

func getBaseBranchInfo(worktreePath string) (*internal.BranchInfo, error) {
	// Get current branch (not used for base branch detection anymore)
	cmd := exec.Command("git", "rev-parse", "--abbrev-ref", "HEAD")
	cmd.Dir = worktreePath
	output, err := cmd.Output()
	if err != nil {
		return nil, err
	}
	_ = strings.TrimSpace(string(output)) // Not needed for base branch detection

	// Get upstream branch
	cmd = exec.Command("git", "rev-parse", "--abbrev-ref", "@{upstream}")
	cmd.Dir = worktreePath
	output, err = cmd.Output()
	upstream := ""
	if err == nil {
		upstream = strings.TrimSpace(string(output))
	}

	// Get ahead/behind count
	cmd = exec.Command("git", "rev-list", "--left-right", "--count", "HEAD...@{upstream}")
	cmd.Dir = worktreePath
	output, err = cmd.Output()
	aheadBy, behindBy := 0, 0
	if err == nil {
		parts := strings.Fields(string(output))
		if len(parts) == 2 {
			aheadBy, _ = strconv.Atoi(parts[0])
			behindBy, _ = strconv.Atoi(parts[1])
		}
	}

	// Try to determine actual base branch using git merge-base
	baseBranch := ""
	// Try common base branches in order of preference
	candidateBranches := []string{"main", "master", "develop", "dev"}
	for _, candidate := range candidateBranches {
		cmd = exec.Command("git", "rev-parse", "--verify", candidate)
		cmd.Dir = worktreePath
		if _, err := cmd.Output(); err == nil {
			// Branch exists, check if it's actually a base
			cmd = exec.Command("git", "merge-base", "--is-ancestor", candidate, "HEAD")
			cmd.Dir = worktreePath
			if err := cmd.Run(); err == nil {
				baseBranch = candidate
				break
			}
		}
	}

	return &internal.BranchInfo{
		Name:     baseBranch,
		Upstream: upstream,
		AheadBy:  aheadBy,
		BehindBy: behindBy,
	}, nil
}

// JSON structs for parsing jira --raw output
type JiraRawResponse struct {
	Key    string `json:"key"`
	Self   string `json:"self"`
	Fields struct {
		Summary     string `json:"summary"`
		Created     string `json:"created"`
		DueDate     *string   `json:"duedate"`
		Status      struct {
			Name string `json:"name"`
		} `json:"status"`
		Priority struct {
			Name string `json:"name"`
		} `json:"priority"`
		Reporter struct {
			DisplayName  string `json:"displayName"`
			EmailAddress string `json:"emailAddress"`
		} `json:"reporter"`
		Assignee *struct {
			DisplayName  string `json:"displayName"`
			EmailAddress string `json:"emailAddress"`
		} `json:"assignee"`
		Parent *struct {
			Key string `json:"key"`
		} `json:"parent"`
		Description *struct {
			Content []struct {
				Content []struct {
					Text string `json:"text"`
				} `json:"content"`
			} `json:"content"`
		} `json:"description"`
		Comment struct {
			Comments []struct {
				Author struct {
					DisplayName string `json:"displayName"`
				} `json:"author"`
				Body struct {
					Content []struct {
						Content []struct {
							Text string `json:"text"`
						} `json:"content"`
					} `json:"content"`
				} `json:"body"`
				Created string `json:"created"`
			} `json:"comments"`
		} `json:"comment"`
	} `json:"fields"`
}

func getJiraTicketDetails(jiraKey string) (*internal.JiraTicketDetails, error) {
	// Check if jira CLI is available
	if _, err := exec.LookPath("jira"); err != nil {
		return nil, fmt.Errorf("jira CLI not found: %w", err)
	}

	// Get raw JSON data using jira CLI
	cmd := exec.Command("jira", "issue", "view", jiraKey, "--raw")
	output, err := cmd.Output()
	if err != nil {
		return nil, fmt.Errorf("failed to get JIRA issue: %w", err)
	}

	// Parse the JSON response
	var jiraResponse JiraRawResponse
	if err := json.Unmarshal(output, &jiraResponse); err != nil {
		return nil, fmt.Errorf("failed to parse JIRA response: %w", err)
	}

	// Build the ticket details from parsed JSON
	ticket := &internal.JiraTicketDetails{
		Key:     jiraResponse.Key,
		Summary: jiraResponse.Fields.Summary,
		Status:  jiraResponse.Fields.Status.Name,
		URL:     formatJiraURL(jiraResponse.Self, jiraResponse.Key),
	}

	// Parse created date
	if jiraResponse.Fields.Created != "" {
		if createdDate, err := time.Parse(time.RFC3339, jiraResponse.Fields.Created); err == nil {
			ticket.Created = createdDate
		}
	}

	// Add priority
	if jiraResponse.Fields.Priority.Name != "" {
		ticket.Priority = jiraResponse.Fields.Priority.Name
	}

	// Add reporter
	if jiraResponse.Fields.Reporter.DisplayName != "" {
		reporter := jiraResponse.Fields.Reporter.DisplayName
		if jiraResponse.Fields.Reporter.EmailAddress != "" {
			reporter += " (" + jiraResponse.Fields.Reporter.EmailAddress + ")"
		}
		ticket.Reporter = reporter
	}

	// Add assignee (can be null)
	if jiraResponse.Fields.Assignee != nil {
		assignee := jiraResponse.Fields.Assignee.DisplayName
		if jiraResponse.Fields.Assignee.EmailAddress != "" {
			assignee += " (" + jiraResponse.Fields.Assignee.EmailAddress + ")"
		}
		ticket.Assignee = assignee
	}

	// Add due date (can be null)
	if jiraResponse.Fields.DueDate != nil && *jiraResponse.Fields.DueDate != "" {
		if dueDate, err := time.Parse("2006-01-02", *jiraResponse.Fields.DueDate); err == nil {
			ticket.DueDate = &dueDate
		}
	}

	// Add epic information
	if jiraResponse.Fields.Parent != nil {
		ticket.Epic = jiraResponse.Fields.Parent.Key
	}

	// Add latest comment
	if len(jiraResponse.Fields.Comment.Comments) > 0 {
		latest := jiraResponse.Fields.Comment.Comments[0]
		
		// Extract comment text from nested structure
		var commentText strings.Builder
		for _, content := range latest.Body.Content {
			for _, textContent := range content.Content {
				if textContent.Text != "" {
					commentText.WriteString(textContent.Text)
				}
			}
		}

		if commentText.Len() > 0 {
			comment := &internal.Comment{
				Author:  latest.Author.DisplayName,
				Content: commentText.String(),
			}
			
			// Parse comment timestamp
			if latest.Created != "" {
				if timestamp, err := time.Parse(time.RFC3339, latest.Created); err == nil {
					comment.Timestamp = timestamp
				}
			}
			
			ticket.LatestComment = comment
		}
	}

	return ticket, nil
}

// formatJiraURL converts the API URL to user-friendly browse URL
// Input: "https://thetalake.atlassian.net/rest/api/3/issue/45305", "INGSVC-4929"
// Output: "https://thetalake.atlassian.net/browse/INGSVC-4929"
func formatJiraURL(selfURL, key string) string {
	if selfURL == "" || key == "" {
		return ""
	}

	// Find the position of "/rest" in the URL
	restIndex := strings.Index(selfURL, "/rest")
	if restIndex == -1 {
		// If "/rest" not found, return the original URL
		return selfURL
	}

	// Extract the base URL (everything before "/rest")
	baseURL := selfURL[:restIndex]
	
	// Construct the browse URL
	return baseURL + "/browse/" + key
}

func init() {
	rootCmd.AddCommand(infoCmd)
}
</file>

<file path="docs/libs/charmbracelet_lipgloss_readme.md">
# Lip Gloss

<p>
    <picture>
      <source media="(prefers-color-scheme: light)" srcset="https://stuff.charm.sh/lipgloss/lip-gloss-light-2025-06.png" width="340">
      <source media="(prefers-color-scheme: dark)" srcset="https://stuff.charm.sh/lipgloss/lip-gloss-dark-2025-06.png" width="340">
      <img src="https://stuff.charm.sh/lipgloss/lip-gloss-light-2025-06.png" width="340" />
    </picture>
    <br>
    <a href="https://github.com/charmbracelet/lipgloss/releases"><img src="https://img.shields.io/github/release/charmbracelet/lipgloss.svg" alt="Latest Release"></a>
    <a href="https://pkg.go.dev/github.com/charmbracelet/lipgloss?tab=doc"><img src="https://godoc.org/github.com/golang/gddo?status.svg" alt="GoDoc"></a>
    <a href="https://github.com/charmbracelet/lipgloss/actions"><img src="https://github.com/charmbracelet/lipgloss/workflows/build/badge.svg" alt="Build Status"></a>
</p>

Style definitions for nice terminal layouts. Built with TUIs in mind.

![Lip Gloss example](https://github.com/user-attachments/assets/92560e60-d70e-4ce0-b39e-a60bb933356b)

Lip Gloss takes an expressive, declarative approach to terminal rendering.
Users familiar with CSS will feel at home with Lip Gloss.

```go

import "github.com/charmbracelet/lipgloss"

var style = lipgloss.NewStyle().
    Bold(true).
    Foreground(lipgloss.Color("#FAFAFA")).
    Background(lipgloss.Color("#7D56F4")).
    PaddingTop(2).
    PaddingLeft(4).
    Width(22)

fmt.Println(style.Render("Hello, kitty"))
```

## Colors

Lip Gloss supports the following color profiles:

### ANSI 16 colors (4-bit)

```go
lipgloss.Color("5")  // magenta
lipgloss.Color("9")  // red
lipgloss.Color("12") // light blue
```

### ANSI 256 Colors (8-bit)

```go
lipgloss.Color("86")  // aqua
lipgloss.Color("201") // hot pink
lipgloss.Color("202") // orange
```

### True Color (16,777,216 colors; 24-bit)

```go
lipgloss.Color("#0000FF") // good ol' 100% blue
lipgloss.Color("#04B575") // a green
lipgloss.Color("#3C3C3C") // a dark gray
```

...as well as a 1-bit ASCII profile, which is black and white only.

The terminal's color profile will be automatically detected, and colors outside
the gamut of the current palette will be automatically coerced to their closest
available value.

### Adaptive Colors

You can also specify color options for light and dark backgrounds:

```go
lipgloss.AdaptiveColor{Light: "236", Dark: "248"}
```

The terminal's background color will automatically be detected and the
appropriate color will be chosen at runtime.

### Complete Colors

CompleteColor specifies exact values for True Color, ANSI256, and ANSI color
profiles.

```go
lipgloss.CompleteColor{TrueColor: "#0000FF", ANSI256: "86", ANSI: "5"}
```

Automatic color degradation will not be performed in this case and it will be
based on the color specified.

### Complete Adaptive Colors

You can use `CompleteColor` with `AdaptiveColor` to specify the exact values for
light and dark backgrounds without automatic color degradation.

```go
lipgloss.CompleteAdaptiveColor{
    Light: CompleteColor{TrueColor: "#d7ffae", ANSI256: "193", ANSI: "11"},
    Dark:  CompleteColor{TrueColor: "#d75fee", ANSI256: "163", ANSI: "5"},
}
```

## Inline Formatting

Lip Gloss supports the usual ANSI text formatting options:

```go
var style = lipgloss.NewStyle().
    Bold(true).
    Italic(true).
    Faint(true).
    Blink(true).
    Strikethrough(true).
    Underline(true).
    Reverse(true)
```

## Block-Level Formatting

Lip Gloss also supports rules for block-level formatting:

```go
// Padding
var style = lipgloss.NewStyle().
    PaddingTop(2).
    PaddingRight(4).
    PaddingBottom(2).
    PaddingLeft(4)

// Margins
var style = lipgloss.NewStyle().
    MarginTop(2).
    MarginRight(4).
    MarginBottom(2).
    MarginLeft(4)
```

There is also shorthand syntax for margins and padding, which follows the same
format as CSS:

```go
// 2 cells on all sides
lipgloss.NewStyle().Padding(2)

// 2 cells on the top and bottom, 4 cells on the left and right
lipgloss.NewStyle().Margin(2, 4)

// 1 cell on the top, 4 cells on the sides, 2 cells on the bottom
lipgloss.NewStyle().Padding(1, 4, 2)

// Clockwise, starting from the top: 2 cells on the top, 4 on the right, 3 on
// the bottom, and 1 on the left
lipgloss.NewStyle().Margin(2, 4, 3, 1)
```

## Aligning Text

You can align paragraphs of text to the left, right, or center.

```go
var style = lipgloss.NewStyle().
    Width(24).
    Align(lipgloss.Left).  // align it left
    Align(lipgloss.Right). // no wait, align it right
    Align(lipgloss.Center) // just kidding, align it in the center
```

## Width and Height

Setting a minimum width and height is simple and straightforward.

```go
var style = lipgloss.NewStyle().
    SetString("What’s for lunch?").
    Width(24).
    Height(32).
    Foreground(lipgloss.Color("63"))
```

## Borders

Adding borders is easy:

```go
// Add a purple, rectangular border
var style = lipgloss.NewStyle().
    BorderStyle(lipgloss.NormalBorder()).
    BorderForeground(lipgloss.Color("63"))

// Set a rounded, yellow-on-purple border to the top and left
var anotherStyle = lipgloss.NewStyle().
    BorderStyle(lipgloss.RoundedBorder()).
    BorderForeground(lipgloss.Color("228")).
    BorderBackground(lipgloss.Color("63")).
    BorderTop(true).
    BorderLeft(true)

// Make your own border
var myCuteBorder = lipgloss.Border{
    Top:         "._.:*:",
    Bottom:      "._.:*:",
    Left:        "|*",
    Right:       "|*",
    TopLeft:     "*",
    TopRight:    "*",
    BottomLeft:  "*",
    BottomRight: "*",
}
```

There are also shorthand functions for defining borders, which follow a similar
pattern to the margin and padding shorthand functions.

```go
// Add a thick border to the top and bottom
lipgloss.NewStyle().
    Border(lipgloss.ThickBorder(), true, false)

// Add a double border to the top and left sides. Rules are set clockwise
// from top.
lipgloss.NewStyle().
    Border(lipgloss.DoubleBorder(), true, false, false, true)
```

For more on borders see [the docs][docs].

## Copying Styles

Just use assignment:

```go
style := lipgloss.NewStyle().Foreground(lipgloss.Color("219"))

copiedStyle := style // this is a true copy

wildStyle := style.Blink(true) // this is also true copy, with blink added

```

Since `Style` data structures contains only primitive types, assigning a style
to another effectively creates a new copy of the style without mutating the
original.

## Inheritance

Styles can inherit rules from other styles. When inheriting, only unset rules
on the receiver are inherited.

```go
var styleA = lipgloss.NewStyle().
    Foreground(lipgloss.Color("229")).
    Background(lipgloss.Color("63"))

// Only the background color will be inherited here, because the foreground
// color will have been already set:
var styleB = lipgloss.NewStyle().
    Foreground(lipgloss.Color("201")).
    Inherit(styleA)
```

## Unsetting Rules

All rules can be unset:

```go
var style = lipgloss.NewStyle().
    Bold(true).                        // make it bold
    UnsetBold().                       // jk don't make it bold
    Background(lipgloss.Color("227")). // yellow background
    UnsetBackground()                  // never mind
```

When a rule is unset, it won't be inherited or copied.

## Enforcing Rules

Sometimes, such as when developing a component, you want to make sure style
definitions respect their intended purpose in the UI. This is where `Inline`
and `MaxWidth`, and `MaxHeight` come in:

```go
// Force rendering onto a single line, ignoring margins, padding, and borders.
someStyle.Inline(true).Render("yadda yadda")

// Also limit rendering to five cells
someStyle.Inline(true).MaxWidth(5).Render("yadda yadda")

// Limit rendering to a 5x5 cell block
someStyle.MaxWidth(5).MaxHeight(5).Render("yadda yadda")
```

## Tabs

The tab character (`\t`) is rendered differently in different terminals (often
as 8 spaces, sometimes 4). Because of this inconsistency, Lip Gloss converts
tabs to 4 spaces at render time. This behavior can be changed on a per-style
basis, however:

```go
style := lipgloss.NewStyle() // tabs will render as 4 spaces, the default
style = style.TabWidth(2)    // render tabs as 2 spaces
style = style.TabWidth(0)    // remove tabs entirely
style = style.TabWidth(lipgloss.NoTabConversion) // leave tabs intact
```

## Rendering

Generally, you just call the `Render(string...)` method on a `lipgloss.Style`:

```go
style := lipgloss.NewStyle().Bold(true).SetString("Hello,")
fmt.Println(style.Render("kitty.")) // Hello, kitty.
fmt.Println(style.Render("puppy.")) // Hello, puppy.
```

But you could also use the Stringer interface:

```go
var style = lipgloss.NewStyle().SetString("你好，猫咪。").Bold(true)
fmt.Println(style) // 你好，猫咪。
```

### Custom Renderers

Custom renderers allow you to render to a specific outputs. This is
particularly important when you want to render to different outputs and
correctly detect the color profile and dark background status for each, such as
in a server-client situation.

```go
func myLittleHandler(sess ssh.Session) {
    // Create a renderer for the client.
    renderer := lipgloss.NewRenderer(sess)

    // Create a new style on the renderer.
    style := renderer.NewStyle().Background(lipgloss.AdaptiveColor{Light: "63", Dark: "228"})

    // Render. The color profile and dark background state will be correctly detected.
    io.WriteString(sess, style.Render("Heyyyyyyy"))
}
```

For an example on using a custom renderer over SSH with [Wish][wish] see the
[SSH example][ssh-example].

## Utilities

In addition to pure styling, Lip Gloss also ships with some utilities to help
assemble your layouts.

### Joining Paragraphs

Horizontally and vertically joining paragraphs is a cinch.

```go
// Horizontally join three paragraphs along their bottom edges
lipgloss.JoinHorizontal(lipgloss.Bottom, paragraphA, paragraphB, paragraphC)

// Vertically join two paragraphs along their center axes
lipgloss.JoinVertical(lipgloss.Center, paragraphA, paragraphB)

// Horizontally join three paragraphs, with the shorter ones aligning 20%
// from the top of the tallest
lipgloss.JoinHorizontal(0.2, paragraphA, paragraphB, paragraphC)
```

### Measuring Width and Height

Sometimes you’ll want to know the width and height of text blocks when building
your layouts.

```go
// Render a block of text.
var style = lipgloss.NewStyle().
    Width(40).
    Padding(2)
var block string = style.Render(someLongString)

// Get the actual, physical dimensions of the text block.
width := lipgloss.Width(block)
height := lipgloss.Height(block)

// Here's a shorthand function.
w, h := lipgloss.Size(block)
```

### Placing Text in Whitespace

Sometimes you’ll simply want to place a block of text in whitespace.

```go
// Center a paragraph horizontally in a space 80 cells wide. The height of
// the block returned will be as tall as the input paragraph.
block := lipgloss.PlaceHorizontal(80, lipgloss.Center, fancyStyledParagraph)

// Place a paragraph at the bottom of a space 30 cells tall. The width of
// the text block returned will be as wide as the input paragraph.
block := lipgloss.PlaceVertical(30, lipgloss.Bottom, fancyStyledParagraph)

// Place a paragraph in the bottom right corner of a 30x80 cell space.
block := lipgloss.Place(30, 80, lipgloss.Right, lipgloss.Bottom, fancyStyledParagraph)
```

You can also style the whitespace. For details, see [the docs][docs].

## Rendering Tables

Lip Gloss ships with a table rendering sub-package.

```go
import "github.com/charmbracelet/lipgloss/table"
```

Define some rows of data.

```go
rows := [][]string{
    {"Chinese", "您好", "你好"},
    {"Japanese", "こんにちは", "やあ"},
    {"Arabic", "أهلين", "أهلا"},
    {"Russian", "Здравствуйте", "Привет"},
    {"Spanish", "Hola", "¿Qué tal?"},
}
```

Use the table package to style and render the table.

```go
var (
    purple    = lipgloss.Color("99")
    gray      = lipgloss.Color("245")
    lightGray = lipgloss.Color("241")

    headerStyle  = lipgloss.NewStyle().Foreground(purple).Bold(true).Align(lipgloss.Center)
    cellStyle    = lipgloss.NewStyle().Padding(0, 1).Width(14)
    oddRowStyle  = cellStyle.Foreground(gray)
    evenRowStyle = cellStyle.Foreground(lightGray)
)

t := table.New().
    Border(lipgloss.NormalBorder()).
    BorderStyle(lipgloss.NewStyle().Foreground(purple)).
    StyleFunc(func(row, col int) lipgloss.Style {
        switch {
        case row == table.HeaderRow:
            return headerStyle
        case row%2 == 0:
            return evenRowStyle
        default:
            return oddRowStyle
        }
    }).
    Headers("LANGUAGE", "FORMAL", "INFORMAL").
    Rows(rows...)

// You can also add tables row-by-row
t.Row("English", "You look absolutely fabulous.", "How's it going?")
```

Print the table.

```go
fmt.Println(t)
```

![Table Example](https://github.com/charmbracelet/lipgloss/assets/42545625/6e4b70c4-f494-45da-a467-bdd27df30d5d)

> [!WARNING]
> Table `Rows` need to be declared before `Offset` otherwise it does nothing.

### Table Borders

There are helpers to generate tables in markdown or ASCII style:

#### Markdown Table

```go
table.New().Border(lipgloss.MarkdownBorder()).BorderTop(false).BorderBottom(false)
```

```
| LANGUAGE |    FORMAL    | INFORMAL  |
|----------|--------------|-----------|
| Chinese  | Nǐn hǎo      | Nǐ hǎo    |
| French   | Bonjour      | Salut     |
| Russian  | Zdravstvuyte | Privet    |
| Spanish  | Hola         | ¿Qué tal? |
```

#### ASCII Table

```go
table.New().Border(lipgloss.ASCIIBorder())
```

```
+----------+--------------+-----------+
| LANGUAGE |    FORMAL    | INFORMAL  |
+----------+--------------+-----------+
| Chinese  | Nǐn hǎo      | Nǐ hǎo    |
| French   | Bonjour      | Salut     |
| Russian  | Zdravstvuyte | Privet    |
| Spanish  | Hola         | ¿Qué tal? |
+----------+--------------+-----------+
```

For more on tables see [the docs](https://pkg.go.dev/github.com/charmbracelet/lipgloss?tab=doc) and [examples](https://github.com/charmbracelet/lipgloss/tree/master/examples/table).

## Rendering Lists

Lip Gloss ships with a list rendering sub-package.

```go
import "github.com/charmbracelet/lipgloss/list"
```

Define a new list.

```go
l := list.New("A", "B", "C")
```

Print the list.

```go
fmt.Println(l)

// • A
// • B
// • C
```

Lists have the ability to nest.

```go
l := list.New(
    "A", list.New("Artichoke"),
    "B", list.New("Baking Flour", "Bananas", "Barley", "Bean Sprouts"),
    "C", list.New("Cashew Apple", "Cashews", "Coconut Milk", "Curry Paste", "Currywurst"),
    "D", list.New("Dill", "Dragonfruit", "Dried Shrimp"),
    "E", list.New("Eggs"),
    "F", list.New("Fish Cake", "Furikake"),
    "J", list.New("Jicama"),
    "K", list.New("Kohlrabi"),
    "L", list.New("Leeks", "Lentils", "Licorice Root"),
)
```

Print the list.

```go
fmt.Println(l)
```

<p align="center">
<img width="600" alt="image" src="https://github.com/charmbracelet/lipgloss/assets/42545625/0dc9f440-0748-4151-a3b0-7dcf29dfcdb0">
</p>

Lists can be customized via their enumeration function as well as using
`lipgloss.Style`s.

```go
enumeratorStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("99")).MarginRight(1)
itemStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("212")).MarginRight(1)

l := list.New(
    "Glossier",
    "Claire’s Boutique",
    "Nyx",
    "Mac",
    "Milk",
    ).
    Enumerator(list.Roman).
    EnumeratorStyle(enumeratorStyle).
    ItemStyle(itemStyle)
```

Print the list.

<p align="center">
<img width="600" alt="List example" src="https://github.com/charmbracelet/lipgloss/assets/42545625/360494f1-57fb-4e13-bc19-0006efe01561">
</p>

In addition to the predefined enumerators (`Arabic`, `Alphabet`, `Roman`, `Bullet`, `Tree`),
you may also define your own custom enumerator:

```go
l := list.New("Duck", "Duck", "Duck", "Duck", "Goose", "Duck", "Duck")

func DuckDuckGooseEnumerator(l list.Items, i int) string {
    if l.At(i).Value() == "Goose" {
        return "Honk →"
    }
    return ""
}

l = l.Enumerator(DuckDuckGooseEnumerator)
```

Print the list:

<p align="center">
<img width="600" alt="image" src="https://github.com/charmbracelet/lipgloss/assets/42545625/157aaf30-140d-4948-9bb4-dfba46e5b87e">
</p>

If you need, you can also build lists incrementally:

```go
l := list.New()

for i := 0; i < repeat; i++ {
    l.Item("Lip Gloss")
}
```

## Rendering Trees

Lip Gloss ships with a tree rendering sub-package.

```go
import "github.com/charmbracelet/lipgloss/tree"
```

Define a new tree.

```go
t := tree.Root(".").
    Child("A", "B", "C")
```

Print the tree.

```go
fmt.Println(t)

// .
// ├── A
// ├── B
// └── C
```

Trees have the ability to nest.

```go
t := tree.Root(".").
    Child("macOS").
    Child(
        tree.New().
            Root("Linux").
            Child("NixOS").
            Child("Arch Linux (btw)").
            Child("Void Linux"),
        ).
    Child(
        tree.New().
            Root("BSD").
            Child("FreeBSD").
            Child("OpenBSD"),
    )
```

Print the tree.

```go
fmt.Println(t)
```

<p align="center">
<img width="663" alt="Tree Example (simple)" src="https://github.com/user-attachments/assets/5ef14eb8-a5d4-4f94-8834-e15d1e714f89">
</p>

Trees can be customized via their enumeration function as well as using
`lipgloss.Style`s.

```go
enumeratorStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("63")).MarginRight(1)
rootStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("35"))
itemStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("212"))

t := tree.
    Root("⁜ Makeup").
    Child(
        "Glossier",
        "Fenty Beauty",
        tree.New().Child(
            "Gloss Bomb Universal Lip Luminizer",
            "Hot Cheeks Velour Blushlighter",
        ),
        "Nyx",
        "Mac",
        "Milk",
    ).
    Enumerator(tree.RoundedEnumerator).
    EnumeratorStyle(enumeratorStyle).
    RootStyle(rootStyle).
    ItemStyle(itemStyle)
```

Print the tree.

<p align="center">
<img width="663" alt="Tree Example (makeup)" src="https://github.com/user-attachments/assets/06d12d87-744a-4c89-bd98-45de9094a97e">
</p>

The predefined enumerators for trees are `DefaultEnumerator` and `RoundedEnumerator`.

If you need, you can also build trees incrementally:

```go
t := tree.New()

for i := 0; i < repeat; i++ {
    t.Child("Lip Gloss")
}
```

---

## FAQ

<details>
<summary>
Why are things misaligning? Why are borders at the wrong widths?
</summary>
<p>This is most likely due to your locale and encoding, particularly with
regard to Chinese, Japanese, and Korean (for example, <code>zh_CN.UTF-8</code>
or <code>ja_JP.UTF-8</code>). The most direct way to fix this is to set
<code>RUNEWIDTH_EASTASIAN=0</code> in your environment.</p>

<p>For details see <a href="https://github.com/charmbracelet/lipgloss/issues/40">https://github.com/charmbracelet/lipgloss/issues/40.</a></p>
</details>

<details>
<summary>
Why isn't Lip Gloss displaying colors?
</summary>
<p>Lip Gloss automatically degrades colors to the best available option in the
given terminal, and if output's not a TTY it will remove color output entirely.
This is common when running tests, CI, or when piping output elsewhere.</p>

<p>If necessary, you can force a color profile in your tests with
<a href="https://pkg.go.dev/github.com/charmbracelet/lipgloss#SetColorProfile"><code>SetColorProfile</code></a>.</p>

```go
import (
    "github.com/charmbracelet/lipgloss"
    "github.com/muesli/termenv"
)

lipgloss.SetColorProfile(termenv.TrueColor)
```

_Note:_ this option limits the flexibility of your application and can cause
ANSI escape codes to be output in cases where that might not be desired. Take
careful note of your use case and environment before choosing to force a color
profile.

</details>

## What about [Bubble Tea][tea]?

Lip Gloss doesn’t replace Bubble Tea. Rather, it is an excellent Bubble Tea
companion. It was designed to make assembling terminal user interface views as
simple and fun as possible so that you can focus on building your application
instead of concerning yourself with low-level layout details.

In simple terms, you can use Lip Gloss to help build your Bubble Tea views.

[tea]: https://github.com/charmbracelet/tea

## Under the Hood

Lip Gloss is built on the excellent [Termenv][termenv] and [Reflow][reflow]
libraries which deal with color and ANSI-aware text operations, respectively.
For many use cases Termenv and Reflow will be sufficient for your needs.

[termenv]: https://github.com/muesli/termenv
[reflow]: https://github.com/muesli/reflow

## Rendering Markdown

For a more document-centric rendering solution with support for things like
lists, tables, and syntax-highlighted code have a look at [Glamour][glamour],
the stylesheet-based Markdown renderer.

[glamour]: https://github.com/charmbracelet/glamour

## Contributing

See [contributing][contribute].

[contribute]: https://github.com/charmbracelet/lipgloss/contribute

## Feedback

We’d love to hear your thoughts on this project. Feel free to drop us a note!

- [Twitter](https://twitter.com/charmcli)
- [The Fediverse](https://mastodon.social/@charmcli)
- [Discord](https://charm.sh/chat)

## License

[MIT](https://github.com/charmbracelet/lipgloss/raw/master/LICENSE)

---

Part of [Charm](https://charm.sh).

<a href="https://charm.sh/"><img alt="The Charm logo" src="https://stuff.charm.sh/charm-badge.jpg" width="400"></a>

Charm热爱开源 • Charm loves open source

[docs]: https://pkg.go.dev/github.com/charmbracelet/lipgloss?tab=doc
[wish]: https://github.com/charmbracelet/wish
[ssh-example]: examples/ssh
</file>

<file path="docs/info_ascii_mockup.md">
$ gbm info PROJECT-123

╔═══════════════════════════════════════════════════════════════════════════════╗
║                           📋 WORKTREE INFO: PROJECT-123                       ║
╚═══════════════════════════════════════════════════════════════════════════════╝

┌─ 📁 WORKTREE ───────────────────────────────────────────────────────────────────┐
│ Name: PROJECT-123                                                               │
│ Path: /home/user/repos/myapp/worktrees/PROJECT-123                              │
│ Branch: feature/PROJECT-123_update_user_auth_flow                               │
│ Created: 2025-07-02 14:30:15 (3 days ago)                                       │
│ Status: 🟡 DIRTY (5 files modified                                              │
│ PR: https://github.com/company/myapp/pull/456 (Draft)                           │
└─────────────────────────────────────────────────────────────────────────────────┘

┌─ 🎫 JIRA TICKET ────────────────────────────────────────────────────────────────┐
│ Key: PROJECT-123                                                                │
│ Summary: Update user auth flow                                                  │
│ Status: 🔄 In Progress → Code Review                                            │
│ Assignee: john.doe@company.com                                                  │
│ Priority: 🔴 High                    Reporter: jane.smith@company.com           │
│ Created: 2025-06-28 09:15:00         Due Date: 2025-07-10 17:00:00              │
│ Epic: AUTH-001 (User Authentication Overhaul)                                   │
│ Link: https://company.atlassian.net/browse/PROJECT-123                          │
│                                                                                 │
│ 💬 Latest Comment (2 hours ago):                                                │
│    "Please review the password validation logic before merging"                 │
│    - tech.lead@company.com                                                      │
└─────────────────────────────────────────────────────────────────────────────────┘

┌─ 🌿 GIT STATUS ────────────────────────────────────────────────────────────────┐
│ Base Branch: develop (diverged 5 days ago at commit abc1234)                   │
│ Upstream: origin/feature/PROJECT-123_update_user_auth_flow                     │
│ Position: ↑ 4 commits ahead, ↓ 2 commits behind origin                         │
│                                                                                │
│ Last Commit: feat: implement 2FA validation (def5678) - 3 hours ago            │
│ Author: John Doe <john.doe@company.com>                                        │
│                                                                                │
│ Modified Files:                                                                │
│   M  src/auth/validator.go        (+89, -23)                                   │
│   M  src/auth/middleware.go       (+45, -12)                                   │
│   A  src/auth/twofa.go            (+156, -0)                                   │
│   M  tests/auth_test.go           (+78, -5)                                    │
│   M  docs/auth_flow.md            (+12, -3)                                    │
│                                                                                │
│ Recent Commits:                                                                │
│   def5678 feat: implement 2FA validation               (3 hours ago)           │
│   ghi9012 refactor: extract auth helpers               (1 day ago)             │
│   jkl3456 fix: handle edge case in password reset      (2 days ago)            │
│   mno7890 feat: add session timeout configuration      (3 days ago)            │
└────────────────────────────────────────────────────────────────────────────────┘
</file>

<file path="docs/info_prd.md">
# Product Requirements Document: `gbm info` Command

## Overview

The `gbm info` command provides comprehensive information about a specific worktree, including its Git status, JIRA ticket details (if applicable), and other relevant metadata. This command combines local Git information with external JIRA data to give users a complete picture of their worktree's state.

## Functional Requirements

### Core Command Behavior

**Command Signature:**
```bash
gbm info <worktree-name>
```
or if in a worktree directory
```bash
gbm info .
```

**Primary Function:**
- Display detailed information about a specified worktree in a visually appealing, structured format
- Integrate JIRA ticket information when the worktree name matches a JIRA key pattern
- Show Git repository status, branch information, and recent activity
- Present information in themed sections using `charmbracelet/lipgloss` styling

### Information Sections

Based on the mockup in `docs/info_ascii_mockup.md`, the command should display:

#### 1. Header Section
- Worktree name prominently displayed
- Visual separator/border using lipgloss styling

#### 2. Worktree Information Section
- **Name**: Worktree identifier
- **Path**: Absolute path to worktree directory
- **Branch**: Current branch name
- **Created**: Creation timestamp (relative time format)
- **Status**: Git status indicator (clean/dirty with file count)

#### 3. JIRA Ticket Section (if applicable)
- **Key**: JIRA ticket identifier
- **Summary**: Ticket title/description
- **Status**: Current JIRA status with transition arrows
- **Assignee**: Assigned user
- **Priority**: Priority level with visual indicator
- **Reporter**: Ticket creator
- **Created**: Ticket creation date
- **Due Date**: Due date (if set)
- **Epic**: Parent epic information (if applicable)
- **Link**: Direct URL to JIRA ticket
- **Latest Comment**: Most recent comment with timestamp and author

#### 4. Git Status Section
- **Base Branch**: Branch this was created from with divergence info
- **Upstream**: Remote tracking branch information
- **Position**: Commits ahead/behind upstream
- **Last Commit**: Most recent commit info (hash, message, author, timestamp)
- **Modified Files**: List of changed files with line change counts
- **Recent Commits**: Last 4-5 commits with condensed info

## Technical Requirements

### Dependencies

#### Required Libraries
- `github.com/charmbracelet/lipgloss` - For styling and layout (already in go.mod)
- External `jira` CLI tool - For JIRA integration (must be installed and configured)

#### Integration Points
- **JIRA CLI**: Use existing `internal/jira.go` functions and extend as needed
- **Git**: Leverage existing `internal/git.go` functions
- **Styling**: Use existing `internal/styles.go` patterns

### Data Sources

#### Git Information (Available)
```go
// From existing codebase
- Worktree path and creation info
- Current branch and upstream tracking
- Git status (ahead/behind, dirty state)
- Commit history and file changes
- Branch divergence information
```

#### JIRA Information (Via jira-cli)
```bash
# Available commands to leverage
jira issue view <key>           # Detailed ticket info
jira issue list -a$(jira me)    # User's tickets
jira issue comments <key>       # Ticket comments
```

#### File System Information
```go
// Need to implement
- Worktree creation timestamp (via os.Stat)
- Modified file analysis (git diff --stat)
```

### Implementation Strategy

#### 1. Command Structure
```go
// cmd/info.go
var infoCmd = &cobra.Command{
    Use:   "info <worktree-name>",
    Short: "Display detailed information about a worktree",
    Args:  cobra.ExactArgs(1),
    RunE:  runInfoCommand,
}

func runInfoCommand(cmd *cobra.Command, args []string) error {
    // Validation and data gathering
    // Render using lipgloss components
}
```

#### 2. Data Structures
```go
type WorktreeInfoData struct {
    // Worktree metadata
    Name         string
    Path         string
    Branch       string
    CreatedAt    time.Time
    GitStatus    *GitStatus
    
    // Git details
    BaseInfo     *BranchInfo
    Commits      []CommitInfo
    ModifiedFiles []FileChange
    
    // JIRA integration (optional)
    JiraTicket   *JiraTicketDetails
}

type JiraTicketDetails struct {
    Key          string
    Summary      string
    Status       string
    Assignee     string
    Priority     string
    Reporter     string
    Created      time.Time
    DueDate      *time.Time
    Epic         string
    URL          string
    LatestComment *Comment
}
```

#### 3. Rendering Components
```go
// Use lipgloss for consistent styling
func renderHeader(worktreeName string) string
func renderWorktreeSection(data *WorktreeInfoData) string
func renderJiraSection(jira *JiraTicketDetails) string
func renderGitSection(data *WorktreeInfoData) string
```

## Data Availability Assessment

### Readily Available (✅)
- Worktree name, path, current branch
- Basic Git status (dirty/clean, ahead/behind)
- Recent commits and commit messages
- Current file modifications

### Requires Implementation (🔨)
- **Worktree creation timestamp**: Use `os.Stat()` on worktree directory
- **Base branch detection**: Analyze `git log --graph` or use `git merge-base`
- **File change statistics**: Parse `git diff --stat HEAD~1` output

### External Dependencies (🔗)
- **JIRA ticket details**: Extend existing `internal/jira.go` with:
  ```go
  func GetJiraTicketDetails(key string) (*JiraTicketDetails, error)
  func GetJiraComments(key string) ([]Comment, error)
  ```

### Potentially Unavailable (❓)
- **Epic information**: Depends on JIRA configuration and permissions
- **Due dates**: May not be set on all tickets

## Implementation Plan

### Phase 1: Core Command Structure
1. Create `cmd/info.go` with basic command structure
2. Implement worktree validation and data gathering
3. Create basic lipgloss layouts for each section

### Phase 2: Git Information
1. Extend `internal/git.go` with detailed status functions
2. Implement file change analysis
3. Add branch relationship detection
4. Create Git status rendering components

### Phase 3: JIRA Integration
1. Extend `internal/jira.go` with detailed ticket fetching
2. Add comment retrieval functionality
3. Implement JIRA section rendering
4. Add error handling for missing JIRA CLI or permissions

### Phase 4: Styling and Polish
1. Refine lipgloss styling to match mockup aesthetics
2. Add responsive layout for different terminal widths
3. Implement proper error handling and fallbacks
4. Add comprehensive testing

## User Experience Considerations

### Success Cases
- **Standard worktree**: Shows all Git information cleanly
- **JIRA-linked worktree**: Displays comprehensive ticket details
- **No JIRA access**: Gracefully shows only Git information

### Error Handling
- **Invalid worktree name**: Clear error message with suggestions
- **JIRA CLI unavailable**: Show Git info only with informational note
- **Network issues**: Timeout gracefully, show cached/local data

### Performance
- Cache JIRA responses to avoid repeated API calls
- Lazy-load expensive operations (file diff analysis)
- Provide progress indication for slow operations

## Acceptance Criteria

1. ✅ Command displays comprehensive worktree information
2. ✅ JIRA integration works when CLI is available and configured
3. ✅ Graceful degradation when JIRA is unavailable
4. ✅ Visual layout matches mockup aesthetic and readability
5. ✅ Command completes within 2 seconds for standard cases
6. ✅ Error messages are helpful and actionable
7. ✅ Styling is consistent with existing CLI patterns

## Future Enhancements

- **GitHub/GitLab integration**: Automatic PR detection and status
- **Caching layer**: Store JIRA responses for offline access
- **Interactive mode**: Allow drilling down into specific sections
- **Export options**: JSON output for scripting integration
</file>

<file path="docs/jira_completion_claude_desktop.md">
This is a great enhancement! Let me think through a few approaches for integrating JIRA tickets into your COBRA CLI with good UX.

## Approach 1: Dynamic Shell Completions (Recommended)

COBRA supports dynamic completions that can call external commands. You can have your CLI fetch JIRA issues on-demand during tab completion:

```go
// In your add command setup
addCmd.RegisterFlagCompletionFunc("branch", func(cmd *cobra.Command, args []string, toComplete string) ([]string, cobra.ShellCompDirective) {
    if len(args) == 1 {
        // args[0] is the worktree name (JIRA key)
        return generateBranchSuggestions(args[0]), cobra.ShellCompDirectiveNoFileComp
    }
    return nil, cobra.ShellCompDirectiveNoFileComp
})

// For the positional argument (JIRA key)
addCmd.ValidArgsFunction = func(cmd *cobra.Command, args []string, toComplete string) ([]string, cobra.ShellCompDirective) {
    if len(args) == 0 {
        return getJiraKeys(), cobra.ShellCompDirectiveNoFileComp
    }
    return nil, cobra.ShellCompDirectiveNoFileComp
}

func getJiraKeys() []string {
    cmd := exec.Command("jira", "issue", "list", "-a$(jira me)", "--plain")
    output, err := cmd.Output()
    if err != nil {
        return nil
    }
    
    var keys []string
    lines := strings.Split(string(output), "\n")
    for _, line := range lines[1:] { // Skip header
        if line = strings.TrimSpace(line); line != "" {
            fields := strings.Fields(line)
            if len(fields) >= 2 {
                keys = append(keys, fields[1]) // The KEY column
            }
        }
    }
    return keys
}

func generateBranchSuggestions(jiraKey string) []string {
    // Fetch the specific issue details to get type and summary
    cmd := exec.Command("jira", "issue", "view", jiraKey, "--plain")
    output, err := cmd.Output()
    if err != nil {
        return nil
    }
    
    // Parse output to extract type and summary
    // Then format as: bug/INGSVC-5544_Zoom_Clips_-_New_Integration
    issueType, summary := parseJiraIssue(output)
    branchName := fmt.Sprintf("%s/%s_%s", 
        strings.ToLower(issueType), 
        jiraKey, 
        strings.ReplaceAll(summary, " ", "_"))
    
    return []string{branchName}
}
```

## Approach 2: Smart Default Behavior

Make the command work intuitively without requiring the `-b` flag when using JIRA keys:

```go
func runAddCommand(cmd *cobra.Command, args []string) error {
    worktreeName := args[0]
    branchName, _ := cmd.Flags().GetString("branch")
    
    // Check if worktree name looks like a JIRA key
    if isJiraKey(worktreeName) && branchName == "" {
        // Auto-generate branch name from JIRA
        generatedBranch, err := generateBranchFromJira(worktreeName)
        if err != nil {
            return fmt.Errorf("failed to fetch JIRA issue: %w", err)
        }
        branchName = generatedBranch
        fmt.Printf("Auto-detected JIRA issue, using branch: %s\n", branchName)
    }
    
    return createWorktree(worktreeName, branchName)
}

func isJiraKey(s string) bool {
    // Simple regex to match JIRA key pattern
    matched, _ := regexp.MatchString(`^[A-Z]+-\d+$`, s)
    return matched
}
```

## Approach 3: Interactive Selection

Add a `--interactive` or `--jira` flag that presents a nice selection interface:

```go
func runAddWithJira(cmd *cobra.Command, args []string) error {
    issues, err := fetchJiraIssues()
    if err != nil {
        return err
    }
    
    // Use a library like survey or bubbletea for nice selection
    selected := promptForIssue(issues)
    
    worktreeName := selected.Key
    branchName := generateBranchName(selected)
    
    return createWorktree(worktreeName, branchName)
}
```

## Implementation Details

For the JIRA parsing, you'll want something like:

```go
type JiraIssue struct {
    Type    string
    Key     string
    Summary string
    Status  string
}

func parseJiraList(output string) []JiraIssue {
    var issues []JiraIssue
    lines := strings.Split(output, "\n")
    
    for _, line := range lines[1:] { // Skip header
        if line = strings.TrimSpace(line); line != "" {
            fields := strings.Fields(line)
            if len(fields) >= 4 {
                issue := JiraIssue{
                    Type:    fields[0],
                    Key:     fields[1],
                    Summary: strings.Join(fields[2:len(fields)-1], " "),
                    Status:  fields[len(fields)-1],
                }
                issues = append(issues, issue)
            }
        }
    }
    return issues
}

func (j JiraIssue) BranchName() string {
    summary := strings.ReplaceAll(j.Summary, " ", "_")
    summary = strings.ReplaceAll(summary, "-", "_")
    return fmt.Sprintf("%s/%s_%s", strings.ToLower(j.Type), j.Key, summary)
}
```

## Recommended Combination

I'd suggest implementing **Approach 1 + Approach 2**: 
- Dynamic completions for great UX during typing
- Smart defaults so `gbm add INGSVC-5544` automatically generates the branch name
- Keep the `-b` flag for overrides

This gives you the best of both worlds - great discoverability through completions, but also quick usage for power users who know their JIRA keys.

Would you like me to elaborate on any of these approaches or help with the specific parsing logic?
</file>

<file path="docs/jira_list_raw.md">
# Command Prompt
```bash
  jira issue view INGSVC-4929 --raw
```

# OUTPUT
{
  "expand": "renderedFields,names,schema,operations,editmeta,changelog,versionedRepresentations,customfield_10303.requestTypePractice",
  "id": "45305",
  "self": "https://thetalake.atlassian.net/rest/api/3/issue/45305",
  "key": "INGSVC-4929",
  "fields": {
    "parent": {
      "id": "42813",
      "key": "EPIC-2327",
      "self": "https://thetalake.atlassian.net/rest/api/3/issue/42813",
      "fields": {
        "summary": "Enhanced: Webex Meetings eComms Archive supports WSMP Private and Breakout Room messages ",
        "status": {
          "self": "https://thetalake.atlassian.net/rest/api/3/status/10136",
          "description": "Enhancement is fully documented and explained to all stakeholders, ready to ship (or is already shipped).",
          "iconUrl": "https://thetalake.atlassian.net/images/icons/statuses/generic.png",
          "name": "PM Customer Ready",
          "id": "10136",
          "statusCategory": {
            "self": "https://thetalake.atlassian.net/rest/api/3/statuscategory/3",
            "id": 3,
            "key": "done",
            "colorName": "green",
            "name": "Done"
          }
        },
        "priority": {
          "self": "https://thetalake.atlassian.net/rest/api/3/priority/3",
          "iconUrl": "https://thetalake.atlassian.net/images/icons/priorities/medium_new.svg",
          "name": "Medium",
          "id": "3"
        },
        "issuetype": {
          "self": "https://thetalake.atlassian.net/rest/api/3/issuetype/10000",
          "id": "10000",
          "description": "A big user story that needs to be broken down. Created by JIRA Software - do not edit or delete.",
          "iconUrl": "https://thetalake.atlassian.net/images/icons/issuetypes/epic.svg",
          "name": "Epic",
          "subtask": false,
          "hierarchyLevel": 1
        }
      }
    },
    "statusCategory": {
      "self": "https://thetalake.atlassian.net/rest/api/3/statuscategory/3",
      "id": 3,
      "key": "done",
      "colorName": "green",
      "name": "Done"
    },
    "resolution": {
      "self": "https://thetalake.atlassian.net/rest/api/3/resolution/10000",
      "id": "10000",
      "description": "Work has been completed on this issue.",
      "name": "Done"
    },
    "customfield_10510": null,
    "customfield_10506": null,
    "customfield_10748": "1_*:*_2_*:*_2435222086_*|*_3_*:*_2_*:*_699425488_*|*_5_*:*_1_*:*_48545_*|*_10001_*:*_1_*:*_87826693",
    "customfield_10507": null,
    "customfield_10508": null,
    "lastViewed": null,
    "labels": [],
    "aggregatetimeoriginalestimate": null,
    "issuelinks": [],
    "assignee": null,
    "components": [],
    "customfield_10841": null,
    "customfield_10842": null,
    "subtasks": [],
    "reporter": {
      "self": "https://thetalake.atlassian.net/rest/api/3/user?accountId=6080b9dcb8927500729602d7",
      "accountId": "6080b9dcb8927500729602d7",
      "emailAddress": "kannan@thetalake.com",
      "avatarUrls": {
        "48x48": "https://secure.gravatar.com/avatar/2712d8f73af4dfe62dbcf561a1a5a7c7?d=https%3A%2F%2Favatar-management--avatars.us-west-2.prod.public.atl-paas.net%2Finitials%2FKA-3.png",
        "24x24": "https://secure.gravatar.com/avatar/2712d8f73af4dfe62dbcf561a1a5a7c7?d=https%3A%2F%2Favatar-management--avatars.us-west-2.prod.public.atl-paas.net%2Finitials%2FKA-3.png",
        "16x16": "https://secure.gravatar.com/avatar/2712d8f73af4dfe62dbcf561a1a5a7c7?d=https%3A%2F%2Favatar-management--avatars.us-west-2.prod.public.atl-paas.net%2Finitials%2FKA-3.png",
        "32x32": "https://secure.gravatar.com/avatar/2712d8f73af4dfe62dbcf561a1a5a7c7?d=https%3A%2F%2Favatar-management--avatars.us-west-2.prod.public.atl-paas.net%2Finitials%2FKA-3.png"
      },
      "displayName": "Kannan Appachi",
      "active": true,
      "timeZone": "America/Los_Angeles",
      "accountType": "atlassian"
    },
    "customfield_10840": null,
    "customfield_10837": null,
    "customfield_10838": null,
    "progress": {
      "progress": 0,
      "total": 0
    },
    "customfield_10839": null,
    "votes": {
      "self": "https://thetalake.atlassian.net/rest/api/3/issue/INGSVC-4929/votes",
      "votes": 0,
      "hasVoted": false
    },
    "worklog": {
      "startAt": 0,
      "maxResults": 20,
      "total": 0,
      "worklogs": []
    },
    "issuetype": {
      "self": "https://thetalake.atlassian.net/rest/api/3/issuetype/10105",
      "id": "10105",
      "description": "A user story. Created by JIRA Software - do not edit or delete.",
      "iconUrl": "https://thetalake.atlassian.net/images/icons/issuetypes/story.svg",
      "name": "Story",
      "subtask": false,
      "hierarchyLevel": 0
    },
    "project": {
      "self": "https://thetalake.atlassian.net/rest/api/3/project/10000",
      "id": "10000",
      "key": "INGSVC",
      "name": "Ingestion Service",
      "projectTypeKey": "software",
      "simplified": false,
      "avatarUrls": {
        "48x48": "https://thetalake.atlassian.net/rest/api/3/universal_avatar/view/type/project/avatar/10203",
        "24x24": "https://thetalake.atlassian.net/rest/api/3/universal_avatar/view/type/project/avatar/10203?size=small",
        "16x16": "https://thetalake.atlassian.net/rest/api/3/universal_avatar/view/type/project/avatar/10203?size=xsmall",
        "32x32": "https://thetalake.atlassian.net/rest/api/3/universal_avatar/view/type/project/avatar/10203?size=medium"
      }
    },
    "customfield_10396": null,
    "customfield_11365": null,
    "resolutiondate": "2025-03-28T16:17:01.144-0700",
    "watches": {
      "self": "https://thetalake.atlassian.net/rest/api/3/issue/INGSVC-4929/watchers",
      "watchCount": 2,
      "isWatching": false
    },
    "customfield_11470": null,
    "customfield_11472": null,
    "customfield_11471": null,
    "customfield_11473": null,
    "customfield_11596": null,
    "customfield_11469": null,
    "customfield_11468": null,
    "customfield_10936": null,
    "updated": "2025-04-15T11:06:23.544-0700",
    "customfield_11580": null,
    "customfield_10370": null,
    "timeoriginalestimate": null,
    "customfield_11582": null,
    "customfield_10371": null,
    "description": {
      "type": "doc",
      "version": 1,
      "content": [
        {
          "type": "paragraph",
          "content": [
            {
              "type": "text",
              "text": "More Details in the Epic"
            }
          ]
        }
      ]
    },
    "customfield_10372": null,
    "customfield_11581": null,
    "customfield_10373": null,
    "customfield_11584": null,
    "customfield_11583": null,
    "customfield_10374": null,
    "customfield_11586": null,
    "customfield_11465": null,
    "customfield_10375": null,
    "customfield_11464": null,
    "customfield_11585": null,
    "customfield_11467": null,
    "timetracking": {},
    "customfield_11466": null,
    "customfield_11579": null,
    "customfield_10369": null,
    "customfield_11578": null,
    "customfield_10006": "EPIC-2327",
    "summary": "Webex Meetings eComms Archive : Implement Changes Required to Support WSMP Private and Breakout Room Messages",
    "customfield_11571": null,
    "customfield_10360": null,
    "customfield_11570": null,
    "customfield_11573": null,
    "customfield_10000": "{pullrequest={dataType=pullrequest, state=MERGED, stateCount=4}, json={\"cachedValue\":{\"errors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":4,\"lastUpdated\":\"2025-03-28T10:45:12.568-0700\",\"stateCount\":4,\"state\":\"MERGED\",\"dataType\":\"pullrequest\",\"open\":false},\"byInstanceType\":{\"bitbucket\":{\"count\":4,\"name\":\"Bitbucket Cloud\"}}}}},\"isStale\":true}}",
    "customfield_11572": null,
    "customfield_11575": null,
    "customfield_10364": null,
    "customfield_10001": null,
    "customfield_11695": null,
    "customfield_10365": null,
    "customfield_10002": [],
    "customfield_11574": null,
    "customfield_11577": null,
    "customfield_10366": null,
    "customfield_11576": null,
    "customfield_10367": null,
    "customfield_11568": null,
    "customfield_10115": null,
    "customfield_10357": null,
    "customfield_11567": null,
    "customfield_10358": null,
    "environment": null,
    "customfield_10359": null,
    "customfield_11569": null,
    "duedate": null,
    "comment": {
      "comments": [
        {
          "self": "https://thetalake.atlassian.net/rest/api/3/issue/45305/comment/74547",
          "id": "74547",
          "author": {
            "self": "https://thetalake.atlassian.net/rest/api/3/user?accountId=614cd19ea995ad0073e155e9",
            "accountId": "614cd19ea995ad0073e155e9",
            "emailAddress": "aj@thetalake.com",
            "avatarUrls": {
              "48x48": "https://secure.gravatar.com/avatar/6d61d9cb98e6962d2865ba4fdb788da7?d=https%3A%2F%2Favatar-management--avatars.us-west-2.prod.public.atl-paas.net%2Finitials%2FAJ-2.png",
              "24x24": "https://secure.gravatar.com/avatar/6d61d9cb98e6962d2865ba4fdb788da7?d=https%3A%2F%2Favatar-management--avatars.us-west-2.prod.public.atl-paas.net%2Finitials%2FAJ-2.png",
              "16x16": "https://secure.gravatar.com/avatar/6d61d9cb98e6962d2865ba4fdb788da7?d=https%3A%2F%2Favatar-management--avatars.us-west-2.prod.public.atl-paas.net%2Finitials%2FAJ-2.png",
              "32x32": "https://secure.gravatar.com/avatar/6d61d9cb98e6962d2865ba4fdb788da7?d=https%3A%2F%2Favatar-management--avatars.us-west-2.prod.public.atl-paas.net%2Finitials%2FAJ-2.png"
            },
            "displayName": "Ardeshir Javaherchi",
            "active": true,
            "timeZone": "America/Los_Angeles",
            "accountType": "atlassian"
          },
          "body": {
            "type": "doc",
            "version": 1,
            "content": [
              {
                "type": "paragraph",
                "content": [
                  {
                    "type": "text",
                    "text": "Verified this on dev1 using datum 865931 which is the primary datum. Breakout room chats were captured in datums 865929 and 865930"
                  }
                ]
              }
            ]
          },
          "updateAuthor": {
            "self": "https://thetalake.atlassian.net/rest/api/3/user?accountId=614cd19ea995ad0073e155e9",
            "accountId": "614cd19ea995ad0073e155e9",
            "emailAddress": "aj@thetalake.com",
            "avatarUrls": {
              "48x48": "https://secure.gravatar.com/avatar/6d61d9cb98e6962d2865ba4fdb788da7?d=https%3A%2F%2Favatar-management--avatars.us-west-2.prod.public.atl-paas.net%2Finitials%2FAJ-2.png",
              "24x24": "https://secure.gravatar.com/avatar/6d61d9cb98e6962d2865ba4fdb788da7?d=https%3A%2F%2Favatar-management--avatars.us-west-2.prod.public.atl-paas.net%2Finitials%2FAJ-2.png",
              "16x16": "https://secure.gravatar.com/avatar/6d61d9cb98e6962d2865ba4fdb788da7?d=https%3A%2F%2Favatar-management--avatars.us-west-2.prod.public.atl-paas.net%2Finitials%2FAJ-2.png",
              "32x32": "https://secure.gravatar.com/avatar/6d61d9cb98e6962d2865ba4fdb788da7?d=https%3A%2F%2Favatar-management--avatars.us-west-2.prod.public.atl-paas.net%2Finitials%2FAJ-2.png"
            },
            "displayName": "Ardeshir Javaherchi",
            "active": true,
            "timeZone": "America/Los_Angeles",
            "accountType": "atlassian"
          },
          "created": "2025-04-15T11:06:19.762-0700",
          "updated": "2025-04-15T11:06:19.762-0700",
          "jsdPublic": true
        }
      ],
      "self": "https://thetalake.atlassian.net/rest/api/3/issue/45305/comment",
      "maxResults": 1,
      "total": 1,
      "startAt": 0
    },
    "statuscategorychangedate": "2025-03-28T16:17:01.193-0700",
    "customfield_10350": null,
    "customfield_10352": null,
    "fixVersions": [],
    "customfield_10353": null,
    "customfield_11564": null,
    "customfield_10354": null,
    "customfield_11563": null,
    "customfield_11566": null,
    "customfield_10355": null,
    "customfield_10356": null,
    "customfield_11565": null,
    "customfield_10346": null,
    "customfield_10104": "2|hzv5hb:",
    "customfield_10347": null,
    "customfield_10348": null,
    "customfield_10349": null,
    "customfield_10340": null,
    "customfield_10341": null,
    "customfield_10100": "2025-04-15T11:06:19.762-0700",
    "customfield_10342": null,
    "priority": {
      "self": "https://thetalake.atlassian.net/rest/api/3/priority/2",
      "iconUrl": "https://thetalake.atlassian.net/images/icons/priorities/high_new.svg",
      "name": "High",
      "id": "2"
    },
    "customfield_10101": "1_*:*_2_*:*_2435222086_*|*_3_*:*_2_*:*_699425488_*|*_5_*:*_1_*:*_48545_*|*_10001_*:*_1_*:*_87826693",
    "customfield_10343": [],
    "customfield_10102": null,
    "customfield_10344": null,
    "customfield_10103": [
      {
        "id": 824,
        "name": "Zombie - Sprint 59",
        "state": "closed",
        "boardId": 10,
        "goal": "",
        "startDate": "2025-02-17T16:56:45.400Z",
        "endDate": "2025-03-26T07:46:25.000Z",
        "completeDate": "2025-03-31T08:52:03.437Z"
      },
      {
        "id": 956,
        "name": "Arrival - Sprint 60",
        "state": "closed",
        "boardId": 10,
        "goal": "",
        "startDate": "2025-03-31T08:52:43.337Z",
        "endDate": "2025-05-08T21:44:27.000Z",
        "completeDate": "2025-05-12T09:57:11.726Z"
      }
    ],
    "customfield_10345": null,
    "customfield_10335": null,
    "customfield_10336": null,
    "customfield_10337": null,
    "customfield_10338": null,
    "customfield_10339": null,
    "timeestimate": null,
    "versions": [],
    "status": {
      "self": "https://thetalake.atlassian.net/rest/api/3/status/6",
      "description": "The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.",
      "iconUrl": "https://thetalake.atlassian.net/images/icons/statuses/closed.png",
      "name": "Issue Closed",
      "id": "6",
      "statusCategory": {
        "self": "https://thetalake.atlassian.net/rest/api/3/statuscategory/3",
        "id": 3,
        "key": "done",
        "colorName": "green",
        "name": "Done"
      }
    },
    "customfield_10330": null,
    "customfield_10452": null,
    "customfield_10331": null,
    "customfield_11663": null,
    "customfield_11662": null,
    "customfield_10453": null,
    "customfield_10332": null,
    "customfield_10333": null,
    "customfield_11664": null,
    "customfield_10334": null,
    "customfield_10324": null,
    "customfield_10445": null,
    "customfield_10325": null,
    "customfield_10446": null,
    "customfield_10326": null,
    "customfield_10447": null,
    "customfield_10448": null,
    "customfield_10327": null,
    "customfield_10328": null,
    "customfield_10449": null,
    "aggregatetimeestimate": null,
    "customfield_10329": null,
    "creator": {
      "self": "https://thetalake.atlassian.net/rest/api/3/user?accountId=6080b9dcb8927500729602d7",
      "accountId": "6080b9dcb8927500729602d7",
      "emailAddress": "kannan@thetalake.com",
      "avatarUrls": {
        "48x48": "https://secure.gravatar.com/avatar/2712d8f73af4dfe62dbcf561a1a5a7c7?d=https%3A%2F%2Favatar-management--avatars.us-west-2.prod.public.atl-paas.net%2Finitials%2FKA-3.png",
        "24x24": "https://secure.gravatar.com/avatar/2712d8f73af4dfe62dbcf561a1a5a7c7?d=https%3A%2F%2Favatar-management--avatars.us-west-2.prod.public.atl-paas.net%2Finitials%2FKA-3.png",
        "16x16": "https://secure.gravatar.com/avatar/2712d8f73af4dfe62dbcf561a1a5a7c7?d=https%3A%2F%2Favatar-management--avatars.us-west-2.prod.public.atl-paas.net%2Finitials%2FKA-3.png",
        "32x32": "https://secure.gravatar.com/avatar/2712d8f73af4dfe62dbcf561a1a5a7c7?d=https%3A%2F%2Favatar-management--avatars.us-west-2.prod.public.atl-paas.net%2Finitials%2FKA-3.png"
      },
      "displayName": "Kannan Appachi",
      "active": true,
      "timeZone": "America/Los_Angeles",
      "accountType": "atlassian"
    },
    "aggregateprogress": {
      "progress": 0,
      "total": 0
    },
    "customfield_10320": null,
    "customfield_10321": null,
    "customfield_10443": null,
    "customfield_10322": null,
    "customfield_10323": null,
    "customfield_10444": null,
    "customfield_10434": null,
    "customfield_10313": null,
    "customfield_10314": null,
    "customfield_10435": null,
    "customfield_10315": null,
    "customfield_10436": null,
    "customfield_10437": null,
    "customfield_10316": null,
    "customfield_10438": null,
    "customfield_10439": null,
    "customfield_10319": null,
    "timespent": null,
    "aggregatetimespent": null,
    "customfield_10673": null,
    "customfield_10310": null,
    "customfield_10311": null,
    "customfield_10432": null,
    "customfield_10302": null,
    "customfield_10303": null,
    "customfield_10304": [],
    "customfield_10305": null,
    "customfield_10427": null,
    "customfield_10306": null,
    "customfield_10307": null,
    "customfield_10428": null,
    "customfield_10308": null,
    "customfield_10309": null,
    "workratio": -1,
    "created": "2025-02-17T09:05:31.290-0800",
    "customfield_10540": null,
    "customfield_10301": null,
    "customfield_10771": null,
    "customfield_10772": null,
    "customfield_10773": null,
    "customfield_10522": null,
    "customfield_10523": null,
    "security": null,
    "customfield_10524": null,
    "customfield_10525": null,
    "attachment": [],
    "customfield_11299": null,
    "customfield_10511": null,
    "customfield_10514": null,
    "customfield_10517": null,
    "customfield_10518": null,
    "customfield_10639": null
  }
}
</file>

<file path="docs/jira_prompt.md">
> how about a different approach. can we use carapace to create the dynamic completions instead? see
  docs/libs/carapace_docs/ for documentation if you need it.

> no. we are off. I want the prompt to be updated in realtime. like other shell completions. not just output
  to stdout.

> looks like you need to give the <worktree-name> when you use the -j flag. the user might not know what to
  call the worktree before checking the jira tickets. could we make it just `gbm add -j` when using that
  flag? and then dynamically create the worktree names after the jira ticket number (KEY)?

> read docs/spec.md docs/todo.md and docs/libs/jira-cli_readme.md. i think
  what we want is
  ```sh
  jira add -j
  ```
  that or (jira add --jira) should execute `jira issue list -a$(jira me) --plain` and that create a search with a select with the options being the output from the `jira issue list -a$(jira me) --plain`. using the search should filter rows out.




> how about a different approach. can we use carapace to create the dynamic completions instead? see
  docs/libs/carapace_docs/ for documentation if you need it.

> no. we are off. I want the prompt to be updated in realtime. like other shell completions. not just output
  to stdout.

> looks like you need to give the <worktree-name> when you use the -j flag. the user might not know what to
  call the worktree before checking the jira tickets. could we make it just `gbm add -j` when using that
  flag? and then dynamically create the worktree names after the jira ticket number (KEY)?

> read docs/spec.md docs/todo.md, docs/libs/charmbracelet_huh_readme.md and docs/libs/jira-cli_readme.md. i think
  what we want is
  ```sh
  jira add -j
  ```
  that or (jira add --jira) should execute `jira issue list -a$(jira me) --plain` and that create a search with a
  select with the options being the output from the `jira issue list -a$(jira me) --plain`. using the search should
  filter rows out.
</file>

<file path="internal/scripts/git-bare-clone.sh">
#!/bin/bash
# Make directory for your git repository
repo=$(basename $1 .git)
mkdir "$repo"
pushd "$repo"
echo "Cloning bare repository to .git..."
git clone --bare $1 .git
pushd '.git' > /dev/null
echo "Adjusting origin fetch locations..."
# Explicitly sets the remote origin fetch so we can fetch remote branches
git config remote.origin.fetch "+refs/heads/*:refs/remotes/origin/*"
# Fetch all branches from remote
echo "Fetching all branches from remote..."
git fetch origin
popd > /dev/null
echo "Success."
</file>

<file path="internal/info_renderer.go">
package internal

import (
	"fmt"
	"os"
	"strings"
	"time"

	"github.com/charmbracelet/lipgloss"
	"golang.org/x/term"
)

type InfoRenderer struct {
	headerStyle     lipgloss.Style
	sectionStyle    lipgloss.Style
	keyStyle        lipgloss.Style
	valueStyle      lipgloss.Style
	borderStyle     lipgloss.Style
	separatorStyle  lipgloss.Style
	titleStyle      lipgloss.Style
	subtitleStyle   lipgloss.Style
	statusStyle     lipgloss.Style
	commitStyle     lipgloss.Style
	fileStyle       lipgloss.Style
	jiraStyle       lipgloss.Style
}

// getTerminalWidth returns the terminal width, with a fallback to 80
func getTerminalWidth() int {
	width, _, err := term.GetSize(int(os.Stdout.Fd()))
	if err != nil {
		return 80 // fallback width
	}
	return width
}

func NewInfoRenderer() *InfoRenderer {
	// Define adaptive colors for better light/dark theme support
	primaryColor := lipgloss.AdaptiveColor{Light: "#7D56F4", Dark: "#A78BFA"}
	secondaryColor := lipgloss.AdaptiveColor{Light: "#3B82F6", Dark: "#60A5FA"}
	textColor := lipgloss.AdaptiveColor{Light: "#1F2937", Dark: "#F9FAFB"}
	subtleColor := lipgloss.AdaptiveColor{Light: "#6B7280", Dark: "#9CA3AF"}
	successColor := lipgloss.AdaptiveColor{Light: "#059669", Dark: "#10B981"}
	warningColor := lipgloss.AdaptiveColor{Light: "#D97706", Dark: "#FCD34D"}

	termWidth := getTerminalWidth()
	contentWidth := termWidth - 10 // Account for borders and padding

	return &InfoRenderer{
		headerStyle: lipgloss.NewStyle().
			Bold(true).
			Foreground(primaryColor).
			Align(lipgloss.Center).
			Border(lipgloss.DoubleBorder()).
			BorderForeground(primaryColor).
			Padding(0, 2).
			Width(contentWidth),

		sectionStyle: lipgloss.NewStyle().
			Bold(true).
			Foreground(secondaryColor).
			Border(lipgloss.RoundedBorder()).
			BorderForeground(subtleColor).
			Padding(1, 2).
			Width(contentWidth),

		keyStyle: lipgloss.NewStyle().
			Bold(true).
			Foreground(textColor).
			Width(15),

		valueStyle: lipgloss.NewStyle().
			Foreground(textColor),

		borderStyle: lipgloss.NewStyle().
			Foreground(subtleColor),

		separatorStyle: lipgloss.NewStyle().
			Foreground(subtleColor),

		titleStyle: lipgloss.NewStyle().
			Bold(true).
			Foreground(textColor),

		subtitleStyle: lipgloss.NewStyle().
			Bold(true).
			Foreground(subtleColor),

		statusStyle: lipgloss.NewStyle().
			Bold(true).
			Foreground(successColor),

		commitStyle: lipgloss.NewStyle().
			Foreground(subtleColor),

		fileStyle: lipgloss.NewStyle().
			Foreground(warningColor),

		jiraStyle: lipgloss.NewStyle().
			Foreground(secondaryColor),
	}
}

func (r *InfoRenderer) RenderWorktreeInfo(data *WorktreeInfoData) string {
	var sections []string

	// Header
	header := r.headerStyle.Render(fmt.Sprintf("📋 WORKTREE INFO: %s", data.Name))
	sections = append(sections, header)

	// Worktree Section
	worktreeSection := r.renderWorktreeSection(data)
	sections = append(sections, worktreeSection)

	// JIRA Section (if available)
	if data.JiraTicket != nil {
		jiraSection := r.renderJiraSection(data.JiraTicket)
		sections = append(sections, jiraSection)
	}

	// Git Status Section
	gitSection := r.renderGitSection(data)
	sections = append(sections, gitSection)

	// Use lipgloss.JoinVertical with compact spacing
	result := lipgloss.JoinVertical(lipgloss.Left, sections...)
	return result + "\n"
}

func (r *InfoRenderer) renderWorktreeSection(data *WorktreeInfoData) string {
	var content strings.Builder

	content.WriteString("📁 WORKTREE\n")
	content.WriteString(r.renderKeyValue("Name", data.Name))
	content.WriteString(r.renderKeyValue("Path", data.Path))
	content.WriteString(r.renderKeyValue("Branch", data.Branch))

	if !data.CreatedAt.IsZero() {
		timeAgo := time.Since(data.CreatedAt)
		timeStr := fmt.Sprintf("%s (%s ago)",
			data.CreatedAt.Format("2006-01-02 15:04:05"),
			r.formatDuration(timeAgo))
		content.WriteString(r.renderKeyValue("Created", timeStr))
	}

	if data.GitStatus != nil {
		status := r.formatGitStatus(data.GitStatus)
		content.WriteString(r.renderKeyValue("Status", status))
	}

	return r.sectionStyle.Render(content.String())
}

func (r *InfoRenderer) renderJiraSection(jira *JiraTicketDetails) string {
	var content strings.Builder

	content.WriteString("🎫 JIRA TICKET\n")
	content.WriteString(r.renderKeyValue("Key", jira.Key))

	if jira.Summary != "" {
		termWidth := getTerminalWidth()
		summaryWidth := termWidth - 25 // Account for borders, padding, and key label
		if summaryWidth < 30 {
			summaryWidth = 30 // minimum width
		}
		wrappedSummary := r.wrapText(jira.Summary, summaryWidth)
		content.WriteString(r.renderKeyValue("Summary", wrappedSummary))
	}

	if jira.Status != "" {
		content.WriteString(r.renderKeyValue("Status", jira.Status))
	}

	if jira.Assignee != "" {
		content.WriteString(r.renderKeyValue("Assignee", jira.Assignee))
	}

	if jira.Priority != "" {
		priority := r.formatPriority(jira.Priority)
		content.WriteString(r.renderKeyValue("Priority", priority))
	}

	if jira.Reporter != "" {
		content.WriteString(r.renderKeyValue("Reporter", jira.Reporter))
	}

	if !jira.Created.IsZero() {
		content.WriteString(r.renderKeyValue("Created", jira.Created.Format("2006-01-02 15:04:05")))
	}

	if jira.DueDate != nil {
		content.WriteString(r.renderKeyValue("Due Date", jira.DueDate.Format("2006-01-02 15:04:05")))
	}

	if jira.Epic != "" {
		content.WriteString(r.renderKeyValue("Epic", jira.Epic))
	}

	if jira.URL != "" {
		content.WriteString(r.renderKeyValue("Link", jira.URL))
	}

	if jira.LatestComment != nil {
		timeAgo := time.Since(jira.LatestComment.Timestamp)
		commentHeader := fmt.Sprintf("💬 Latest Comment (%s ago):", r.formatDuration(timeAgo))
		content.WriteString(commentHeader + "\n")

		// Wrap the comment text to fit within borders
		termWidth := getTerminalWidth()
		commentWidth := termWidth - 30 // Account for borders, padding, and indentation
		if commentWidth < 40 {
			commentWidth = 40 // minimum width
		}
		wrappedComment := r.wrapText(jira.LatestComment.Content, commentWidth)
		for _, line := range strings.Split(wrappedComment, "\n") {
			content.WriteString(fmt.Sprintf("    %s\n", line))
		}
		content.WriteString(fmt.Sprintf("    - %s", jira.LatestComment.Author))
	}

	return r.sectionStyle.Render(content.String())
}

func (r *InfoRenderer) renderGitSection(data *WorktreeInfoData) string {
	var content strings.Builder

	content.WriteString("🌿 GIT STATUS\n")

	if data.BaseInfo != nil {
		if data.BaseInfo.Name != "" {
			content.WriteString(r.renderKeyValue("Base Branch", data.BaseInfo.Name))
		}
		if data.BaseInfo.Upstream != "" {
			content.WriteString(r.renderKeyValue("Upstream", data.BaseInfo.Upstream))
		}
		if data.BaseInfo.AheadBy > 0 || data.BaseInfo.BehindBy > 0 {
			position := fmt.Sprintf("↑ %d commits ahead, ↓ %d commits behind",
				data.BaseInfo.AheadBy, data.BaseInfo.BehindBy)
			content.WriteString(r.renderKeyValue("Position", position))
		}
	}

	// Recent commits
	if len(data.Commits) > 0 {
		latest := data.Commits[0]
		timeAgo := time.Since(latest.Timestamp)
		termWidth := getTerminalWidth()
		commitWidth := termWidth - 25 // Account for borders, padding, and key label
		if commitWidth < 30 {
			commitWidth = 30
		}
		wrappedMessage := r.wrapText(latest.Message, commitWidth-20) // Reserve space for hash and time
		lastCommit := fmt.Sprintf("%s (%s) - %s ago",
			wrappedMessage,
			latest.Hash[:7],
			r.formatDuration(timeAgo))
		content.WriteString(r.renderKeyValue("Last Commit", lastCommit))
		content.WriteString(r.renderKeyValue("Author", latest.Author))
	}

	// Modified files
	if len(data.ModifiedFiles) > 0 {
		content.WriteString("Modified Files:\n")
		termWidth := getTerminalWidth()
		filePathWidth := termWidth - 40 // Account for borders, status, and changes
		if filePathWidth < 20 {
			filePathWidth = 20
		}

		for _, file := range data.ModifiedFiles {
			statusIcon := r.getStatusIcon(file.Status)
			changes := fmt.Sprintf("(+%d, -%d)", file.Additions, file.Deletions)

			// Truncate long file paths intelligently
			displayPath := file.Path
			if len(displayPath) > filePathWidth {
				displayPath = "..." + displayPath[len(displayPath)-filePathWidth+3:]
			}

			// Use lipgloss for better formatting
			statusCol := lipgloss.NewStyle().Width(3).Render(statusIcon)
			pathCol := lipgloss.NewStyle().Width(filePathWidth).Render(displayPath)
			changesCol := r.fileStyle.Render(changes)

			line := lipgloss.JoinHorizontal(lipgloss.Top, "  ", statusCol, "  ", pathCol, " ", changesCol)
			content.WriteString(line + "\n")
		}
	}

	// Recent commits list
	if len(data.Commits) > 1 {
		content.WriteString("Recent Commits:\n")
		for i, commit := range data.Commits {
			if i == 0 {
				continue // Skip the first one as it's shown in "Last Commit"
			}
			timeAgo := time.Since(commit.Timestamp)
			line := fmt.Sprintf("  %s %-40s (%s ago)\n",
				commit.Hash[:7],
				commit.Message,
				r.formatDuration(timeAgo))
			content.WriteString(line)
		}
	}

	return r.sectionStyle.Render(content.String())
}

func (r *InfoRenderer) renderKeyValue(key, value string) string {
	keyColumn := r.keyStyle.Render(key + ":")
	valueColumn := r.valueStyle.Render(value)

	// Use lipgloss.JoinHorizontal for proper alignment
	return lipgloss.JoinHorizontal(lipgloss.Top, keyColumn, " ", valueColumn) + "\n"
}

func (r *InfoRenderer) formatGitStatus(status *GitStatus) string {
	if status == nil {
		return "🔴 Unknown"
	}

	if status.IsDirty {
		fileCount := status.Modified + status.Staged + status.Untracked
		return fmt.Sprintf("🟡 DIRTY (%d files modified)", fileCount)
	}

	if status.Ahead > 0 || status.Behind > 0 {
		return fmt.Sprintf("🟠 DIVERGED (↑%d ↓%d)", status.Ahead, status.Behind)
	}

	return "🟢 CLEAN"
}

func (r *InfoRenderer) formatDuration(d time.Duration) string {
	if d < time.Hour {
		return fmt.Sprintf("%d minutes", int(d.Minutes()))
	} else if d < 24*time.Hour {
		return fmt.Sprintf("%d hours", int(d.Hours()))
	} else {
		return fmt.Sprintf("%d days", int(d.Hours()/24))
	}
}

func (r *InfoRenderer) getStatusIcon(status string) string {
	switch status {
	case "A":
		return "A"
	case "M":
		return "M"
	case "D":
		return "D"
	default:
		return "?"
	}
}

func (r *InfoRenderer) formatPriority(priority string) string {
	lowercasePriority := strings.ToLower(priority)
	switch lowercasePriority {
	case "critical", "highest":
		return "🔴 Critical"
	case "high":
		return "🟠 High"
	case "medium":
		return "🟡 Medium"
	case "low":
		return "🟢 Low"
	case "lowest":
		return "🔵 Lowest"
	default:
		return priority
	}
}

func (r *InfoRenderer) wrapText(text string, width int) string {
	if width <= 0 {
		return text
	}

	if len(text) <= width {
		return text
	}

	var result strings.Builder
	words := strings.Fields(text)
	if len(words) == 0 {
		return text
	}

	currentLine := words[0]
	for _, word := range words[1:] {
		// If a single word is longer than width, just add it on its own line
		if len(word) > width {
			if currentLine != "" {
				result.WriteString(currentLine + "\n")
			}
			result.WriteString(word + "\n")
			currentLine = ""
			continue
		}

		if len(currentLine)+1+len(word) <= width {
			currentLine += " " + word
		} else {
			result.WriteString(currentLine + "\n")
			currentLine = word
		}
	}

	if currentLine != "" {
		result.WriteString(currentLine)
	}

	return result.String()
}
</file>

<file path="internal/jira.go">
package internal

import (
	"fmt"
	"os/exec"
	"regexp"
	"strings"
)

// JiraIssue represents a JIRA issue with its key, type, summary, and status
type JiraIssue struct {
	Type    string
	Key     string
	Summary string
	Status  string
}

// IsJiraKey checks if a string matches the JIRA key pattern (PROJECT-NUMBER)
func IsJiraKey(s string) bool {
	matched, _ := regexp.MatchString(`^[A-Z]+-\d+$`, s)
	return matched
}

// GetJiraKeys fetches all JIRA issue keys for the current user
func GetJiraKeys() ([]string, error) {
	// Get current user first
	meCmd := exec.Command("jira", "me")
	userOutput, err := meCmd.Output()
	if err != nil {
		return nil, fmt.Errorf("failed to get current JIRA user: %w", err)
	}
	user := strings.TrimSpace(string(userOutput))

	// Now list issues for the user
	cmd := exec.Command("jira", "issue", "list", "-a"+user, "--plain")
	output, err := cmd.Output()
	if err != nil {
		return nil, fmt.Errorf("failed to fetch JIRA issues: %w", err)
	}

	var keys []string
	lines := strings.Split(string(output), "\n")
	for _, line := range lines[1:] { // Skip header
		if line = strings.TrimSpace(line); line != "" {
			fields := strings.Split(line, "\t")
			// Find the field that matches JIRA key pattern
			for _, field := range fields {
				trimmedField := strings.TrimSpace(field)
				if IsJiraKey(trimmedField) {
					keys = append(keys, trimmedField)
					break // Only take the first JIRA key found in this line
				}
			}
		}
	}
	return keys, nil
}

// GetJiraIssues fetches all JIRA issues for the current user with full details
func GetJiraIssues() ([]JiraIssue, error) {
	// Get current user first
	meCmd := exec.Command("jira", "me")
	userOutput, err := meCmd.Output()
	if err != nil {
		return nil, fmt.Errorf("failed to get current JIRA user: %w", err)
	}
	user := strings.TrimSpace(string(userOutput))

	// Now list issues for the user
	cmd := exec.Command("jira", "issue", "list", "-a"+user, "--plain")
	output, err := cmd.Output()
	if err != nil {
		return nil, fmt.Errorf("failed to fetch JIRA issues: %w", err)
	}

	return ParseJiraList(string(output)), nil
}

// GetJiraIssue fetches detailed information for a specific JIRA issue
func GetJiraIssue(key string) (*JiraIssue, error) {
	// Get current user first
	meCmd := exec.Command("jira", "me")
	userOutput, err := meCmd.Output()
	if err != nil {
		return nil, fmt.Errorf("failed to get current JIRA user: %w", err)
	}
	user := strings.TrimSpace(string(userOutput))

	// Get the issue from the list command
	cmd := exec.Command("jira", "issue", "list", "-a"+user, "--plain")
	output, err := cmd.Output()
	if err != nil {
		return nil, fmt.Errorf("failed to fetch JIRA issues: %w", err)
	}

	// Parse the list output to find our specific issue
	lines := strings.Split(string(output), "\n")
	for _, line := range lines[1:] { // Skip header
		if line = strings.TrimSpace(line); line != "" {
			fields := strings.Split(line, "\t")
			if len(fields) >= 3 {
				// Find the JIRA key in this line
				var issueKey, issueType, summary, status string
				keyIndex := -1

				for i, field := range fields {
					trimmedField := strings.TrimSpace(field)
					if IsJiraKey(trimmedField) {
						issueKey = trimmedField
						keyIndex = i
						break
					}
				}

				if issueKey == key {
					// Type is usually the first field
					issueType = strings.TrimSpace(fields[0])

					// Summary is usually the field after the key
					if keyIndex+1 < len(fields) {
						summary = strings.TrimSpace(fields[keyIndex+1])
					}

					// Status is the last non-empty field
					for i := len(fields) - 1; i >= 0; i-- {
						if trimmed := strings.TrimSpace(fields[i]); trimmed != "" {
							status = trimmed
							break
						}
					}

					return &JiraIssue{
						Type:    issueType,
						Key:     issueKey,
						Summary: summary,
						Status:  status,
					}, nil
				}
			}
		}
	}

	return nil, fmt.Errorf("JIRA issue %s not found in your assigned issues", key)
}

// ParseJiraList parses the output of 'jira issue list' command
func ParseJiraList(output string) []JiraIssue {
	var issues []JiraIssue
	lines := strings.Split(output, "\n")

	for _, line := range lines[1:] { // Skip header
		if line = strings.TrimSpace(line); line != "" {
			fields := strings.Split(line, "\t")
			if len(fields) >= 3 {
				// Find the JIRA key in this line
				var issueKey, issueType, summary, status string
				keyIndex := -1

				for i, field := range fields {
					trimmedField := strings.TrimSpace(field)
					if IsJiraKey(trimmedField) {
						issueKey = trimmedField
						keyIndex = i
						break
					}
				}

				if issueKey != "" {
					// Type is usually the first field
					issueType = strings.TrimSpace(fields[0])

					// Summary is usually the field after the key
					if keyIndex+1 < len(fields) {
						summary = strings.TrimSpace(fields[keyIndex+1])
					}

					// Status is the last non-empty field
					for i := len(fields) - 1; i >= 0; i-- {
						if trimmed := strings.TrimSpace(fields[i]); trimmed != "" {
							status = trimmed
							break
						}
					}

					issue := JiraIssue{
						Type:    issueType,
						Key:     issueKey,
						Summary: summary,
						Status:  status,
					}
					issues = append(issues, issue)
				}
			}
		}
	}
	return issues
}

// BranchName generates a branch name from a JIRA issue
func (j *JiraIssue) BranchName() string {
	summary := strings.ReplaceAll(j.Summary, " ", "_")
	summary = strings.ReplaceAll(summary, "-", "_")
	// Remove special characters and make it filesystem-safe
	summary = regexp.MustCompile(`[^a-zA-Z0-9_]`).ReplaceAllString(summary, "_")
	// Clean up multiple underscores
	summary = regexp.MustCompile(`_+`).ReplaceAllString(summary, "_")
	summary = strings.Trim(summary, "_")

	issueType := strings.ToLower(j.Type)
	if issueType == "story" || issueType == "improvement" {
		issueType = "feature"
	}

	return fmt.Sprintf("%s/%s_%s", issueType, j.Key, summary)
}

// GenerateBranchFromJira fetches a JIRA issue and generates a branch name
func GenerateBranchFromJira(jiraKey string) (string, error) {
	issue, err := GetJiraIssue(jiraKey)
	if err != nil {
		return "", err
	}

	return issue.BranchName(), nil
}
</file>

<file path="tools/strip-whitespace.sh">
#!/bin/bash

# Strip trailing whitespace from a file
# Usage: strip-whitespace.sh <file>

set -euo pipefail

if [ $# -ne 1 ]; then
    echo "Usage: $0 <file>" >&2
    exit 1
fi

file="$1"

if [ ! -f "$file" ]; then
    echo "Error: File '$file' not found" >&2
    exit 1
fi

# Strip trailing whitespace and tabs from each line
# Handle macOS vs Linux sed differences
if [[ "$OSTYPE" == "darwin"* ]]; then
    # macOS requires empty string after -i
    sed -i '' 's/[[:space:]]*$//' "$file"
else
    # Linux sed
    sed -i 's/[[:space:]]*$//' "$file"
fi

echo "Stripped trailing whitespace from: $file"
</file>

<file path="cmd/pull.go">
package cmd

import (
	"fmt"
	"os"

	"gbm/internal"

	"github.com/spf13/cobra"
)

var (
	pullAll bool
)

var pullCmd = &cobra.Command{
	Use:   "pull [worktree-name]",
	Short: "Pull worktree changes from remote",
	Long: `Pull changes from the remote repository to a worktree.

Usage:
  gbm pull                    # Pull current worktree (if in a worktree)
  gbm pull <worktree-name>    # Pull specific worktree
  gbm pull --all              # Pull all worktrees`,
	Args: cobra.MaximumNArgs(1),
	RunE: func(cmd *cobra.Command, args []string) error {
		wd, err := os.Getwd()
		if err != nil {
			return fmt.Errorf("failed to get working directory: %w", err)
		}

		repoPath, err := internal.FindGitRoot(wd)
		if err != nil {
			return fmt.Errorf("not in a git repository: %w", err)
		}

		manager, err := internal.NewManager(repoPath)
		if err != nil {
			return fmt.Errorf("failed to create manager: %w", err)
		}

		if pullAll {
			return handlePullAll(manager)
		}

		if len(args) == 0 {
			return handlePullCurrent(manager, wd)
		}

		return handlePullNamed(manager, args[0])
	},
}

func handlePullAll(manager *internal.Manager) error {
	PrintInfo("Pulling all worktrees...")
	return manager.PullAllWorktrees()
}

func handlePullCurrent(manager *internal.Manager, currentPath string) error {
	// Check if we're in a worktree
	inWorktree, worktreeName, err := manager.IsInWorktree(currentPath)
	if err != nil {
		return fmt.Errorf("failed to check if in worktree: %w", err)
	}

	if !inWorktree {
		return fmt.Errorf("not currently in a worktree. Use 'gbm pull <worktree-name>' to pull a specific worktree")
	}

	PrintInfo("Pulling current worktree '%s'...", worktreeName)
	return manager.PullWorktree(worktreeName)
}

func handlePullNamed(manager *internal.Manager, worktreeName string) error {
	// Check if worktree exists
	worktrees, err := manager.GetAllWorktrees()
	if err != nil {
		return fmt.Errorf("failed to get worktrees: %w", err)
	}

	if _, exists := worktrees[worktreeName]; !exists {
		return fmt.Errorf("worktree '%s' does not exist", worktreeName)
	}

	PrintInfo("Pulling worktree '%s'...", worktreeName)
	return manager.PullWorktree(worktreeName)
}

func init() {
	rootCmd.AddCommand(pullCmd)
	pullCmd.Flags().BoolVar(&pullAll, "all", false, "Pull all worktrees")

	// Add completion for worktree names
	pullCmd.ValidArgsFunction = func(cmd *cobra.Command, args []string, toComplete string) ([]string, cobra.ShellCompDirective) {
		if len(args) != 0 {
			return nil, cobra.ShellCompDirectiveNoFileComp
		}
		return getWorktreeNames(), cobra.ShellCompDirectiveNoFileComp
	}
}
</file>

<file path="cmd/push.go">
package cmd

import (
	"fmt"
	"os"

	"gbm/internal"

	"github.com/spf13/cobra"
)

var (
	pushAll bool
)

var pushCmd = &cobra.Command{
	Use:   "push [worktree-name]",
	Short: "Push worktree changes to remote",
	Long: `Push changes from a worktree to the remote repository.

Usage:
  gbm push                    # Push current worktree (if in a worktree)
  gbm push <worktree-name>    # Push specific worktree
  gbm push --all              # Push all worktrees

The command will automatically set upstream (-u) if not already set.`,
	Args: cobra.MaximumNArgs(1),
	RunE: func(cmd *cobra.Command, args []string) error {
		wd, err := os.Getwd()
		if err != nil {
			return fmt.Errorf("failed to get working directory: %w", err)
		}

		repoPath, err := internal.FindGitRoot(wd)
		if err != nil {
			return fmt.Errorf("not in a git repository: %w", err)
		}

		manager, err := internal.NewManager(repoPath)
		if err != nil {
			return fmt.Errorf("failed to create manager: %w", err)
		}

		if pushAll {
			return handlePushAll(manager)
		}

		if len(args) == 0 {
			return handlePushCurrent(manager, wd)
		}

		return handlePushNamed(manager, args[0])
	},
}

func handlePushAll(manager *internal.Manager) error {
	PrintInfo("Pushing all worktrees...")
	return manager.PushAllWorktrees()
}

func handlePushCurrent(manager *internal.Manager, currentPath string) error {
	// Check if we're in a worktree
	inWorktree, worktreeName, err := manager.IsInWorktree(currentPath)
	if err != nil {
		return fmt.Errorf("failed to check if in worktree: %w", err)
	}

	if !inWorktree {
		return fmt.Errorf("not currently in a worktree. Use 'gbm push <worktree-name>' to push a specific worktree")
	}

	PrintInfo("Pushing current worktree '%s'...", worktreeName)
	return manager.PushWorktree(worktreeName)
}

func handlePushNamed(manager *internal.Manager, worktreeName string) error {
	// Check if worktree exists
	worktrees, err := manager.GetAllWorktrees()
	if err != nil {
		return fmt.Errorf("failed to get worktrees: %w", err)
	}

	if _, exists := worktrees[worktreeName]; !exists {
		return fmt.Errorf("worktree '%s' does not exist", worktreeName)
	}

	PrintInfo("Pushing worktree '%s'...", worktreeName)
	return manager.PushWorktree(worktreeName)
}

func init() {
	rootCmd.AddCommand(pushCmd)
	pushCmd.Flags().BoolVar(&pushAll, "all", false, "Push all worktrees")

	// Add completion for worktree names
	pushCmd.ValidArgsFunction = func(cmd *cobra.Command, args []string, toComplete string) ([]string, cobra.ShellCompDirective) {
		if len(args) != 0 {
			return nil, cobra.ShellCompDirectiveNoFileComp
		}
		return getWorktreeNames(), cobra.ShellCompDirectiveNoFileComp
	}
}
</file>

<file path="cmd/remove.go">
package cmd

import (
	"fmt"
	"os"
	"strings"

	"gbm/internal"

	"github.com/spf13/cobra"
)

var (
	force bool
)

var removeCmd = &cobra.Command{
	Use:   "remove <worktree-name>",
	Short: "Remove a worktree",
	Long: `Remove a worktree and clean up its directory.

This command removes the specified worktree and its associated directory.
If the worktree contains uncommitted changes, use --force to remove anyway.

Examples:
  gbm remove FEATURE-123
  gbm remove FEATURE-123 --force`,
	Args: cobra.ExactArgs(1),
	RunE: func(cmd *cobra.Command, args []string) error {
		worktreeName := args[0]

		// Find git repository root
		repoPath, err := internal.FindGitRoot(".")
		if err != nil {
			return fmt.Errorf("not in a git repository: %w", err)
		}

		// Create manager
		manager, err := internal.NewManager(repoPath)
		if err != nil {
			return fmt.Errorf("failed to create manager: %w", err)
		}

		// Check if worktree exists
		worktreePath, err := manager.GetWorktreePath(worktreeName)
		if err != nil {
			return fmt.Errorf("worktree '%s' not found: %w", worktreeName, err)
		}

		// Check if worktree has uncommitted changes (unless force is used)
		if !force {
			gitStatus, err := manager.GetWorktreeStatus(worktreePath)
			if err != nil {
				return fmt.Errorf("failed to check worktree status: %w", err)
			}

			if gitStatus.HasChanges() {
				return fmt.Errorf("worktree '%s' has uncommitted changes. Use --force to remove anyway", worktreeName)
			}
		}

		// Confirm removal (unless force is used)
		if !force {
			fmt.Printf("Are you sure you want to remove worktree '%s'? [y/N]: ", worktreeName)
			var response string
			fmt.Scanln(&response)
			if strings.ToLower(response) != "y" && strings.ToLower(response) != "yes" {
				PrintInfo("Removal cancelled")
				return nil
			}
		}

		// Remove the worktree
		if err := manager.RemoveWorktree(worktreeName); err != nil {
			return fmt.Errorf("failed to remove worktree: %w", err)
		}

		PrintInfo("Worktree '%s' removed successfully", worktreeName)
		return nil
	},
}

func init() {
	rootCmd.AddCommand(removeCmd)

	removeCmd.Flags().BoolVarP(&force, "force", "f", false, "Force removal even if worktree has uncommitted changes")

	// Add completion for worktree names
	removeCmd.ValidArgsFunction = func(cmd *cobra.Command, args []string, toComplete string) ([]string, cobra.ShellCompDirective) {
		if len(args) == 0 {
			// Get current working directory
			wd, err := os.Getwd()
			if err != nil {
				return nil, cobra.ShellCompDirectiveNoFileComp
			}

			// Find git repository root
			repoPath, err := internal.FindGitRoot(wd)
			if err != nil {
				return nil, cobra.ShellCompDirectiveNoFileComp
			}

			// Create manager
			manager, err := internal.NewManager(repoPath)
			if err != nil {
				return nil, cobra.ShellCompDirectiveNoFileComp
			}

			// Get all worktrees
			worktrees, err := manager.GetAllWorktrees()
			if err != nil {
				return nil, cobra.ShellCompDirectiveNoFileComp
			}

			var completions []string
			for worktreeName := range worktrees {
				completions = append(completions, worktreeName)
			}
			return completions, cobra.ShellCompDirectiveNoFileComp
		}
		return nil, cobra.ShellCompDirectiveNoFileComp
	}
}
</file>

<file path="docs/spec.md">
# Git Branch Manager CLI Design Specification

## Overview

A command-line tool that manages Git repository branches and worktrees based on environment variables defined in a `.envrc` file. The tool synchronizes local worktrees with branch definitions and provides notifications when configurations drift out of sync.

## Core Concept

The `.envrc` file serves as the source of truth for branch management, where each environment variable maps to a specific branch:

```bash
PROD=production/2025-05-1
PREVIEW=production/2025-06-1
MAIN=master
STAGING=feature/new-api
```

## Command Structure

### Primary Commands

**`gbm init`**
- Initializes the current Git repository for branch management
- Creates initial worktree structure based on `.envrc`
- Validates that the repository is a valid Git repo
- Creates `.gbm/` directory for metadata storage

**`gbm sync`**
- Synchronizes all worktrees with current `.envrc` definitions
- Creates missing worktrees for new environment variables
- Updates existing worktrees if branch references have changed
- Removes orphaned worktrees (no longer in `.envrc`)

**`gbm status`**
- Shows current sync status between `.envrc` and actual worktrees
- Displays which branches are out of sync
- Lists missing worktrees
- Shows orphaned worktrees

**`gbm check`**
- Runs automatically on shell prompt or can be called manually
- Quick check for drift between `.envrc` and worktrees
- Returns non-zero exit code if out of sync (useful for shell integration)

### Utility Commands

**`gbm list`**
- Lists all managed worktrees and their status
- Shows environment variable mappings
- Indicates sync status for each entry

**`gbm clean`**
- Removes orphaned worktrees (interactive by default)
- Option for force removal with `--force`

**`gbm validate`**
- Validates `.envrc` syntax and branch references
- Checks if referenced branches exist locally or remotely

## Configuration File Structure

**`.envrc`** - Primary configuration
```bash
# Long-living environment branches
PROD=production/2025-05-1
PREVIEW=production/2025-06-1
MAIN=master
STAGING=feature/new-api
```

**`.gbm/config.toml`** - Tool metadata (created automatically)
```toml
[settings]
worktree_prefix = "worktrees"
auto_fetch = true
create_missing_branches = false

[state]
last_sync = "2025-07-01T10:30:00Z"
tracked_vars = ["PROD", "PREVIEW", "MAIN", "STAGING"]
```

## Worktree Management

### Directory Structure
```
project-root/
├── .git/
├── .envrc
├── .gbm/
│   └── config.toml
├── worktrees/
│   ├── PROD/           # Contains production/2025-05-1 branch
│   ├── PREVIEW/        # Contains production/2025-06-1 branch
│   ├── MAIN/           # Contains master branch
│   └── STAGING/        # Contains feature/new-api branch
└── main-workspace/     # Original repository workspace
```

### Worktree Naming
- Worktrees are named after the environment variable (e.g., `PROD`, `PREVIEW`)
- Stored in `worktrees/` subdirectory by default
- Configurable via `.gbm/config.toml`

## Sync Detection and Notification

### Automatic Checking
Integration with shell prompt to show sync status:
```bash
# Example shell integration
export PS1="$(gbm check --format=prompt)$PS1"
```

### Sync Status Indicators
- ✅ All worktrees in sync
- ⚠️  Some worktrees out of sync
- ❌ Major configuration drift detected
- 🔄 Sync in progress

### Interactive Sync Resolution
When drift is detected, prompt user with options:
```
⚠️  Configuration drift detected:

Changes needed:
  • PROD: production/2025-05-1 → production/2025-07-1 (branch changed)
  • STAGING: worktree missing (new environment variable)
  • OLD_FEATURE: orphaned worktree (variable removed)

Actions:
  [s] Sync all changes
  [r] Review changes individually
  [i] Ignore for this session
  [q] Quit
```

## Command-Line Interface

### Flags and Options

**Global Flags:**
- `--config, -c`: Specify custom `.envrc` path
- `--worktree-dir, -w`: Override worktree directory location
- `--verbose, -v`: Enable verbose output
- `--quiet, -q`: Suppress non-error output

**Command-Specific Options:**

`gbm init`:
- `--force`: Initialize even if worktrees already exist
- `--fetch`: Fetch remote branches during initialization

`gbm sync`:
- `--dry-run`: Show what would be changed without making changes
- `--force`: Skip confirmation prompts
- `--fetch`: Update remote tracking before sync

`gbm check`:
- `--format=prompt|json|text`: Output format for integration
- `--exit-code`: Return status code only

## Error Handling

### Common Error Scenarios
1. **Not a Git repository**: Clear error message with suggestion to run `git init`
2. **Missing `.envrc`**: Prompt to create one or specify path
3. **Invalid branch references**: List invalid branches and suggest alternatives
4. **Permission issues**: Clear guidance on directory permissions
5. **Conflicting worktrees**: Handle existing worktree conflicts gracefully

### Recovery Mechanisms
- Backup worktree state before major operations
- Rollback capability for failed sync operations
- Repair mode for corrupted `.gbm/` metadata

## Integration Points

### Shell Integration
```bash
# Add to .bashrc/.zshrc for automatic checking
eval "$(gbm shell-integration)"
```

### Git Hooks Integration
- Optional pre-commit hook to validate `.envrc` changes
- Post-merge hook to check for sync requirements

### CI/CD Integration
- `gbm validate` can be used in CI pipelines
- JSON output format for programmatic consumption

## Implementation Considerations

### Dependencies
- Standard library only where possible
- Git command-line tool (shell out to `git` commands)
- TOML parsing library for configuration

### Performance
- Lazy loading of Git repository state
- Caching of branch existence checks
- Minimal filesystem operations during status checks

### Cross-Platform Support
- Windows, macOS, and Linux compatibility
- Handle path separators and permissions appropriately
- Shell integration for major shells (bash, zsh, fish)

## Future Enhancements

- **Remote branch creation**: Option to create missing branches remotely
- **Template support**: Branch naming templates and conventions
- **Multi-repository support**: Manage multiple repositories from single config
- **Plugin system**: Custom sync behaviors and integrations
- **Web interface**: Optional local web UI for visual management
</file>

<file path="internal/styles.go">
package internal

import (
	"github.com/charmbracelet/lipgloss"
)

// Global icon manager instance
var globalIconManager *IconManager

// IconManager manages configurable icons
type IconManager struct {
	config *Config
}

// NewIconManager creates a new icon manager with configuration
func NewIconManager(config *Config) *IconManager {
	return &IconManager{config: config}
}

// SetGlobalIconManager sets the global icon manager instance
func SetGlobalIconManager(manager *IconManager) {
	globalIconManager = manager
}

// GetGlobalIconManager returns the global icon manager instance
func GetGlobalIconManager() *IconManager {
	if globalIconManager == nil {
		// Return a default manager if none is set
		return NewIconManager(DefaultConfig())
	}
	return globalIconManager
}

// Icon getter methods
func (im *IconManager) Success() string     { return im.config.Icons.Success }
func (im *IconManager) Warning() string     { return im.config.Icons.Warning }
func (im *IconManager) Error() string       { return im.config.Icons.Error }
func (im *IconManager) Info() string        { return im.config.Icons.Info }
func (im *IconManager) Orphaned() string    { return im.config.Icons.Orphaned }
func (im *IconManager) DryRun() string      { return im.config.Icons.DryRun }
func (im *IconManager) Missing() string     { return im.config.Icons.Missing }
func (im *IconManager) Changes() string     { return im.config.Icons.Changes }
func (im *IconManager) GitClean() string    { return im.config.Icons.GitClean }
func (im *IconManager) GitDirty() string    { return im.config.Icons.GitDirty }
func (im *IconManager) GitAhead() string    { return im.config.Icons.GitAhead }
func (im *IconManager) GitBehind() string   { return im.config.Icons.GitBehind }
func (im *IconManager) GitDiverged() string { return im.config.Icons.GitDiverged }
func (im *IconManager) GitUnknown() string  { return im.config.Icons.GitUnknown }

var (
	// Colors
	primaryColor = lipgloss.Color("#7D56F4")
	successColor = lipgloss.Color("#04B575")
	warningColor = lipgloss.Color("#F59E0B")
	errorColor   = lipgloss.Color("#EF4444")
	infoColor    = lipgloss.Color("#3B82F6")
	subtleColor  = lipgloss.Color("#6B7280")

	// Base styles
	BaseStyle = lipgloss.NewStyle().
			MarginLeft(0).
			MarginRight(0)

	// Header styles
	HeaderStyle = lipgloss.NewStyle().
			Bold(true).
			Foreground(primaryColor).
			MarginBottom(1)

	SubHeaderStyle = lipgloss.NewStyle().
			Bold(true).
			Foreground(subtleColor)

	// Status styles
	SuccessStyle = lipgloss.NewStyle().
			Foreground(successColor).
			Bold(true)

	WarningStyle = lipgloss.NewStyle().
			Foreground(warningColor).
			Bold(true)

	ErrorStyle = lipgloss.NewStyle().
			Foreground(errorColor).
			Bold(true)

	InfoStyle = lipgloss.NewStyle().
			Foreground(infoColor)

	// Table styles
	TableHeaderStyle = lipgloss.NewStyle().
				Bold(true).
				Foreground(primaryColor).
				Align(lipgloss.Center)

	TableCellStyle = lipgloss.NewStyle().
			Padding(0, 1).
			Align(lipgloss.Left)

	TableBorderStyle = lipgloss.NewStyle().
				Foreground(subtleColor)

	// Status icon styles
	StatusOKStyle = lipgloss.NewStyle().
			Foreground(successColor)

	StatusWarningStyle = lipgloss.NewStyle().
				Foreground(warningColor)

	StatusErrorStyle = lipgloss.NewStyle().
				Foreground(errorColor)

	StatusInfoStyle = lipgloss.NewStyle().
			Foreground(infoColor)

	// Utility styles
	BoldStyle = lipgloss.NewStyle().
			Bold(true)

	SubtleStyle = lipgloss.NewStyle().
			Foreground(subtleColor)

	// Message styles
	VerboseStyle = lipgloss.NewStyle().
			Foreground(subtleColor).
			Italic(true)

	PromptStyle = lipgloss.NewStyle().
			Foreground(primaryColor).
			Bold(true)
)

func FormatVerbose(text string) string {
	return VerboseStyle.Render(text)
}

func FormatHeader(text string) string {
	return HeaderStyle.Render(text)
}

func FormatSubHeader(text string) string {
	return SubHeaderStyle.Render(text)
}

func FormatBold(text string) string {
	return BoldStyle.Render(text)
}

func FormatSubtle(text string) string {
	return SubtleStyle.Render(text)
}

func FormatPrompt(text string) string {
	return PromptStyle.Render(text)
}

// Status icon formatting with consistent styling
func FormatStatusIcon(icon, text string) string {
	iconManager := GetGlobalIconManager()

	switch icon {
	case iconManager.Success():
		return StatusOKStyle.Render(icon) + " " + text
	case iconManager.Warning():
		return StatusWarningStyle.Render(icon) + " " + text
	case iconManager.Error():
		return StatusErrorStyle.Render(icon) + " " + text
	case iconManager.Orphaned():
		return StatusErrorStyle.Render(icon) + " " + text
	case iconManager.Info():
		return StatusInfoStyle.Render(icon) + " " + text
	case iconManager.DryRun():
		return StatusInfoStyle.Render(icon) + " " + text
	case iconManager.Missing():
		return StatusWarningStyle.Render(icon) + " " + text
	case iconManager.Changes():
		return StatusWarningStyle.Render(icon) + " " + text
	default:
		return icon + " " + text
	}
}

// Helper functions for common icons
func FormatSuccess(text string) string {
	iconManager := GetGlobalIconManager()
	return FormatStatusIcon(iconManager.Success(), text)
}

func FormatWarning(text string) string {
	iconManager := GetGlobalIconManager()
	return FormatStatusIcon(iconManager.Warning(), text)
}

func FormatError(text string) string {
	iconManager := GetGlobalIconManager()
	return FormatStatusIcon(iconManager.Error(), text)
}

func FormatInfo(text string) string {
	iconManager := GetGlobalIconManager()
	return FormatStatusIcon(iconManager.Info(), text)
}

// Git status formatting
func FormatGitStatus(status *GitStatus) string {
	iconManager := GetGlobalIconManager()

	if status == nil {
		return StatusInfoStyle.Render(iconManager.GitUnknown())
	}

	if status.IsDirty {
		return StatusWarningStyle.Render(iconManager.GitDirty())
	}

	if status.Ahead > 0 && status.Behind > 0 {
		return StatusErrorStyle.Render(iconManager.GitDiverged())
	}

	if status.Ahead > 0 {
		return StatusInfoStyle.Render(iconManager.GitAhead())
	}

	if status.Behind > 0 {
		return StatusWarningStyle.Render(iconManager.GitBehind())
	}

	return StatusOKStyle.Render(iconManager.GitClean())
}
</file>

<file path=".envrc.example">
# Long-living environment branches
MAIN=main
</file>

<file path="CLAUDE.md">
# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Current State

This repository is in its initial state with minimal structure:
- `docs/spec.md` - Empty specification file

## Architecture

The repository appears to be intended for a worktree manager tool based on the name, but no implementation exists yet.

## Development Setup

No build system, dependencies, or development tooling has been configured yet. When development begins, standard practices should be established for the chosen technology stack.
</file>

<file path="cmd/completion.go">
package cmd

import (
	"os"

	"github.com/spf13/cobra"
)

var completionCmd = &cobra.Command{
	Use:   "completion [bash|zsh|fish|powershell]",
	Short: "Generate completion script",
	Long: `Generate completion script for your shell.

To load completions:

Bash:
  source <(gbm completion bash)

  # To load completions for each session, execute once:
  # Linux:
  gbm completion bash > /etc/bash_completion.d/gbm
  # macOS:
  gbm completion bash > /usr/local/etc/bash_completion.d/gbm

Zsh:
  # If shell completion is not already enabled in your environment,
  # you will need to enable it. You can execute the following once:
  echo "autoload -U compinit; compinit" >> ~/.zshrc

  # To load completions for each session, execute once:
  gbm completion zsh > "${fpath[1]}/_gbm"

  # You will need to start a new shell for this setup to take effect.

fish:
  gbm completion fish | source

  # To load completions for each session, execute once:
  gbm completion fish > ~/.config/fish/completions/gbm.fish

PowerShell:
  gbm completion powershell | Out-String | Invoke-Expression

  # To load completions for every new session, run:
  gbm completion powershell > gbm.ps1
  # and source this file from your PowerShell profile.
`,
	DisableFlagsInUseLine: true,
	ValidArgs:             []string{"bash", "zsh", "fish", "powershell"},
	Args:                  cobra.MatchAll(cobra.ExactArgs(1), cobra.OnlyValidArgs),
	RunE: func(cmd *cobra.Command, args []string) error {
		switch args[0] {
		case "bash":
			return cmd.Root().GenBashCompletion(os.Stdout)
		case "zsh":
			return cmd.Root().GenZshCompletion(os.Stdout)
		case "fish":
			return cmd.Root().GenFishCompletion(os.Stdout, true)
		case "powershell":
			return cmd.Root().GenPowerShellCompletion(os.Stdout)
		}
		return nil
	},
}

func init() {
	rootCmd.AddCommand(completionCmd)
}
</file>

<file path="go.mod">
module gbm

go 1.24.4

require (
	github.com/BurntSushi/toml v1.5.0
	github.com/charmbracelet/bubbletea v1.3.5
	github.com/charmbracelet/lipgloss v1.1.0
	github.com/go-git/go-git/v5 v5.16.2
	github.com/spf13/cobra v1.9.1
	golang.org/x/term v0.31.0
)

require (
	dario.cat/mergo v1.0.0 // indirect
	github.com/Microsoft/go-winio v0.6.2 // indirect
	github.com/ProtonMail/go-crypto v1.1.6 // indirect
	github.com/aymanbagabas/go-osc52/v2 v2.0.1 // indirect
	github.com/charmbracelet/colorprofile v0.2.3-0.20250311203215-f60798e515dc // indirect
	github.com/charmbracelet/x/ansi v0.8.0 // indirect
	github.com/charmbracelet/x/cellbuf v0.0.13-0.20250311204145-2c3ea96c31dd // indirect
	github.com/charmbracelet/x/term v0.2.1 // indirect
	github.com/cloudflare/circl v1.6.1 // indirect
	github.com/cyphar/filepath-securejoin v0.4.1 // indirect
	github.com/emirpasic/gods v1.18.1 // indirect
	github.com/erikgeiser/coninput v0.0.0-20211004153227-1c3628e74d0f // indirect
	github.com/go-git/gcfg v1.5.1-0.20230307220236-3a3c6141e376 // indirect
	github.com/go-git/go-billy/v5 v5.6.2 // indirect
	github.com/golang/groupcache v0.0.0-20241129210726-2c02b8208cf8 // indirect
	github.com/inconshreveable/mousetrap v1.1.0 // indirect
	github.com/jbenet/go-context v0.0.0-20150711004518-d14ea06fba99 // indirect
	github.com/kevinburke/ssh_config v1.2.0 // indirect
	github.com/lucasb-eyer/go-colorful v1.2.0 // indirect
	github.com/mattn/go-isatty v0.0.20 // indirect
	github.com/mattn/go-localereader v0.0.1 // indirect
	github.com/mattn/go-runewidth v0.0.16 // indirect
	github.com/muesli/ansi v0.0.0-20230316100256-276c6243b2f6 // indirect
	github.com/muesli/cancelreader v0.2.2 // indirect
	github.com/muesli/termenv v0.16.0 // indirect
	github.com/pjbgf/sha1cd v0.3.2 // indirect
	github.com/rivo/uniseg v0.4.7 // indirect
	github.com/sergi/go-diff v1.3.2-0.20230802210424-5b0b94c5c0d3 // indirect
	github.com/skeema/knownhosts v1.3.1 // indirect
	github.com/spf13/pflag v1.0.6 // indirect
	github.com/xanzy/ssh-agent v0.3.3 // indirect
	github.com/xo/terminfo v0.0.0-20220910002029-abceb7e1c41e // indirect
	golang.org/x/crypto v0.37.0 // indirect
	golang.org/x/net v0.39.0 // indirect
	golang.org/x/sync v0.13.0 // indirect
	golang.org/x/sys v0.32.0 // indirect
	golang.org/x/text v0.24.0 // indirect
	gopkg.in/warnings.v0 v0.1.2 // indirect
)
</file>

<file path="main.go">
package main

import (
	"os"

	"gbm/cmd"
)

func main() {
	defer cmd.CloseLogFile()

	if err := cmd.Execute(); err != nil {
		cmd.PrintError("Error: %v", err)
		os.Exit(1)
	}
}
</file>

<file path="README.md">
# Git Branch Manager (gbm)

A command-line tool that manages Git repository branches and worktrees based on environment variables defined in a `.envrc` file. The tool synchronizes local worktrees with branch definitions and provides notifications when configurations drift out of sync.

## Installation

```bash
go build -o gbm
```

## Quick Start

1. Create a `.envrc` file in your Git repository:
```bash
PROD=production/2025-05-1
PREVIEW=production/2025-06-1
MAIN=master
STAGING=feature/new-api
```

2. Initialize gbm:
```bash
./gbm init
```

3. Check status:
```bash
./gbm status
```

4. Sync worktrees:
```bash
./gbm sync
```

## Commands

### Core Commands

- `gbm init` - Initialize the repository for branch management
- `gbm sync` - Synchronize worktrees with .envrc definitions
- `gbm status` - Show current sync status
- `gbm check` - Quick check for drift (useful for automation)

### Utility Commands

- `gbm list` - List all managed worktrees
- `gbm clean` - Remove orphaned worktrees
- `gbm validate` - Validate .envrc syntax and branch references

### Ad-hoc Worktree Management

- `gbm add <worktree-name> [branch-name]` - Add a new worktree
  - `gbm add feature-work existing-branch` - Create worktree on existing branch
  - `gbm add feature-work new-branch -b` - Create worktree with new branch
  - `gbm add feature-work --interactive` - Interactive branch selection

### JIRA Integration

The `add` command includes intelligent JIRA integration when the `jira` CLI is available:

#### Tab Completion
- **First tab**: Shows JIRA keys with issue summaries for context
- **Second tab**: Suggests branch names based on JIRA issue details

```bash
$ gbm add <TAB>
INGSVC-5544    Zoom Clips - New Integration
INGSVC-5581    MsSharepoint - Authentication Error
INGSVC-3663    MONDAY.COM: handle error response

$ gbm add INGSVC-5544 <TAB>
feature/INGSVC-5544_Zoom_Clips_New_Integration
```

#### Smart Branch Generation
- **Stories** and **Improvements** → `feature/` prefix
- **Bugs** → `bug/` prefix
- Summary text cleaned and formatted for branch names
- Special characters replaced with underscores

#### Workflow Examples
```bash
# Two-tab completion workflow
$ gbm add INGSV<TAB>                    # Complete to INGSVC-5544
$ gbm add INGSVC-5544 <TAB>             # Complete to branch name
$ gbm add INGSVC-5544 feature/INGSVC-5544_Zoom_Clips_New_Integration -b

# Smart suggestion workflow
$ gbm add INGSVC-5544
Error: branch name required. Suggested: feature/INGSVC-5544_Zoom_Clips_New_Integration

Try: gbm add INGSVC-5544 feature/INGSVC-5544_Zoom_Clips_New_Integration -b
```

#### Requirements
- `jira` CLI tool installed and authenticated
- Gracefully falls back to basic completion when JIRA unavailable

### Shell Integration

#### Status Checking
Add automatic checking to your shell:

```bash
# Add to .bashrc/.zshrc
eval "$(gbm shell-integration)"
```

#### Tab Completion
Enable tab completion for enhanced JIRA integration:

```bash
# Bash
gbm completion bash > /etc/bash_completion.d/gbm
# Or for current session: source <(gbm completion bash)

# Zsh
gbm completion zsh > "${fpath[1]}/_gbm"

# Fish
gbm completion fish > ~/.config/fish/completions/gbm.fish
```

## Configuration

The tool creates a `.gbm/config.toml` file for metadata storage with default settings:

```toml
[settings]
worktree_prefix = "worktrees"
auto_fetch = true
create_missing_branches = false

[state]
last_sync = "2025-07-01T10:30:00Z"
tracked_vars = ["PROD", "PREVIEW", "MAIN", "STAGING"]
```

## Directory Structure

```
project-root/
├── .git/
├── .envrc
├── .gbm/
│   └── config.toml
├── worktrees/
│   ├── PROD/           # Contains production/2025-05-1 branch
│   ├── PREVIEW/        # Contains production/2025-06-1 branch
│   ├── MAIN/           # Contains master branch
│   └── STAGING/        # Contains feature/new-api branch
└── main-workspace/     # Original repository workspace
```

## Global Flags

- `--config, -c`: Specify custom .envrc path
- `--worktree-dir, -w`: Override worktree directory location
- `--verbose, -v`: Enable verbose output
- `--quiet, -q`: Suppress non-error output
</file>

<file path="cmd/clone.go">
package cmd

import (
	"fmt"
	"io"
	"os"
	"os/exec"
	"path/filepath"
	"strings"

	"gbm/internal"

	"github.com/spf13/cobra"
)

var cloneCmd = &cobra.Command{
	Use:   "clone <repository-url>",
	Short: "Clone a repository as a bare repo and create the main worktree",
	Long: `Clone a repository as a bare repository and create the main worktree
using the HEAD branch. This sets up the repository structure for
worktree-based development.`,
	Args: cobra.ExactArgs(1),
	RunE: func(cmd *cobra.Command, args []string) error {
		repoUrl := args[0]

		PrintInfo("Cloning repository using git-bare-clone.sh...")
		if err := runGitBareClone(repoUrl); err != nil {
			return fmt.Errorf("failed to clone repository: %w", err)
		}

		PrintInfo("Discovering default branch...")
		defaultBranch, err := getDefaultBranch()
		if err != nil {
			return fmt.Errorf("failed to discover default branch: %w", err)
		}
		PrintInfo("Default branch: %s", defaultBranch)

		PrintInfo("Creating main worktree...")
		if err := createMainWorktree(defaultBranch); err != nil {
			return fmt.Errorf("failed to create main worktree: %w", err)
		}

		PrintInfo("Setting up .envrc configuration...")
		if err := setupEnvrc(defaultBranch); err != nil {
			return fmt.Errorf("failed to setup .envrc: %w", err)
		}

		PrintInfo("Initializing worktree management...")
		if err := initializeWorktreeManagement(); err != nil {
			return fmt.Errorf("failed to initialize worktree management: %w", err)
		}

		PrintInfo("Repository cloned successfully!")
		return nil
	},
}

func runGitBareClone(repoUrl string) error {
	// Extract repository name from URL
	repo := extractRepoName(repoUrl)

	// Create directory for the repository
	if err := os.MkdirAll(repo, 0755); err != nil {
		return fmt.Errorf("failed to create directory %s: %w", repo, err)
	}

	// Change to the repository directory
	if err := os.Chdir(repo); err != nil {
		return fmt.Errorf("failed to change to directory %s: %w", repo, err)
	}

	PrintInfo("Cloning bare repository to .git...")
	// Clone bare repository to .git
	cmd := exec.Command("git", "clone", "--bare", repoUrl, ".git")
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr
	if err := cmd.Run(); err != nil {
		return fmt.Errorf("failed to clone bare repository: %w", err)
	}

	PrintInfo("Adjusting origin fetch locations...")
	// Change to .git directory and configure remote
	if err := os.Chdir(".git"); err != nil {
		return fmt.Errorf("failed to change to .git directory: %w", err)
	}

	// Set remote origin fetch configuration
	cmd = exec.Command("git", "config", "remote.origin.fetch", "+refs/heads/*:refs/remotes/origin/*")
	if err := cmd.Run(); err != nil {
		return fmt.Errorf("failed to configure remote origin fetch: %w", err)
	}

	PrintInfo("Fetching all branches from remote...")
	// Fetch all branches from remote
	cmd = exec.Command("git", "fetch", "origin")
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr
	if err := cmd.Run(); err != nil {
		return fmt.Errorf("failed to fetch from origin: %w", err)
	}

	// Change back to repository root
	if err := os.Chdir(".."); err != nil {
		return fmt.Errorf("failed to change back to repository root: %w", err)
	}

	return nil
}

func extractRepoName(repoUrl string) string {
	// Remove .git suffix if present
	url := strings.TrimSuffix(repoUrl, ".git")

	// Extract the last part of the URL (repository name)
	parts := strings.Split(url, "/")
	if len(parts) > 0 {
		return parts[len(parts)-1]
	}

	return "repository"
}

func getDefaultBranch() (string, error) {
	cmd := exec.Command("git", "symbolic-ref", "refs/remotes/origin/HEAD")
	output, err := cmd.Output()
	if err != nil {
		return "", fmt.Errorf("failed to get default branch: %w", err)
	}

	// Parse the output to extract branch name
	// Output format: refs/remotes/origin/main
	refPath := strings.TrimSpace(string(output))
	parts := strings.Split(refPath, "/")
	if len(parts) < 4 {
		return "", fmt.Errorf("unexpected symbolic-ref output format: %s", refPath)
	}

	return parts[len(parts)-1], nil
}

func createMainWorktree(defaultBranch string) error {
	// Create worktrees directory
	if err := os.MkdirAll("worktrees", 0755); err != nil {
		return fmt.Errorf("failed to create worktrees directory: %w", err)
	}

	// Create the main worktree
	cmd := exec.Command("git", "worktree", "add", "worktrees/MAIN", defaultBranch)
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr
	if err := cmd.Run(); err != nil {
		return fmt.Errorf("failed to create main worktree: %w", err)
	}

	return nil
}

func setupEnvrc(defaultBranch string) error {
	worktreeEnvrcPath := filepath.Join("worktrees", "MAIN", ".envrc")
	rootEnvrcPath := ".envrc"

	// Check if .envrc exists in the MAIN worktree
	if _, err := os.Stat(worktreeEnvrcPath); err == nil {
		PrintInfo("Found .envrc in MAIN worktree, copying to root...")
		if err := copyFile(worktreeEnvrcPath, rootEnvrcPath); err != nil {
			return fmt.Errorf("failed to copy .envrc from worktree: %w", err)
		}
	} else if os.IsNotExist(err) {
		PrintInfo("No .envrc found in MAIN worktree, creating new one...")
		if err := createDefaultEnvrc(rootEnvrcPath, defaultBranch); err != nil {
			return fmt.Errorf("failed to create default .envrc: %w", err)
		}
	} else {
		return fmt.Errorf("failed to check .envrc in worktree: %w", err)
	}

	return nil
}

func copyFile(src, dst string) error {
	srcFile, err := os.Open(src)
	if err != nil {
		return err
	}
	defer srcFile.Close()

	dstFile, err := os.Create(dst)
	if err != nil {
		return err
	}
	defer dstFile.Close()

	_, err = io.Copy(dstFile, srcFile)
	return err
}

func createDefaultEnvrc(path, defaultBranch string) error {
	content := fmt.Sprintf("# Git Branch Manager configuration\n# This file defines the mapping between environment variables and branches\n\nMAIN=%s\n", defaultBranch)

	return os.WriteFile(path, []byte(content), 0644)
}

func initializeWorktreeManagement() error {
	// Get current working directory (repository root)
	wd, err := os.Getwd()
	if err != nil {
		return fmt.Errorf("failed to get working directory: %w", err)
	}

	// Create manager
	manager, err := internal.NewManager(wd)
	if err != nil {
		return fmt.Errorf("failed to create manager: %w", err)
	}

	// Load .envrc configuration
	if err := manager.LoadEnvMapping(GetConfigPath()); err != nil {
		return fmt.Errorf("failed to load .envrc: %w", err)
	}

	// Initialize worktree management (force=false, fetch=false since we just cloned)
	if err := manager.Initialize(true, false); err != nil {
		return fmt.Errorf("failed to initialize manager: %w", err)
	}

	return nil
}

func init() {
	rootCmd.AddCommand(cloneCmd)
}
</file>

<file path="cmd/root.go">
package cmd

import (
	"fmt"
	"os"
	"runtime"
	"time"

	"gbm/internal"

	tea "github.com/charmbracelet/bubbletea"
	"github.com/spf13/cobra"
)

var (
	configPath  string
	worktreeDir string
	debug       bool
	logFile     *os.File
)

var rootCmd = &cobra.Command{
	Use:   "gbm",
	Short: "Git Branch Manager - Manage Git worktrees based on .envrc configuration",
	Long: `Git Branch Manager (gbm) is a CLI tool that manages Git repository branches
and worktrees based on environment variables defined in a .envrc file.

The tool synchronizes local worktrees with branch definitions and provides
notifications when configurations drift out of sync.`,
	PersistentPreRun: func(cmd *cobra.Command, args []string) {
		InitializeLogging()
	},
}

func Execute() error {
	return rootCmd.Execute()
}

func init() {
	rootCmd.PersistentFlags().StringVarP(&configPath, "config", "c", "", "specify custom .envrc path")
	rootCmd.PersistentFlags().StringVarP(&worktreeDir, "worktree-dir", "w", "", "override worktree directory location")
	rootCmd.PersistentFlags().BoolVarP(&debug, "debug", "d", false, "enable debug logging to ./gbm.log")
}

func GetConfigPath() string {
	if configPath != "" {
		return configPath
	}
	return ".envrc"
}

func GetWorktreeDir() string {
	if worktreeDir != "" {
		return worktreeDir
	}
	return "worktrees"
}

func InitializeLogging() {
	if debug {
		var err error
		logFile, err = tea.LogToFile("gbm.log", "gbm")
		if err != nil {
			PrintError("Failed to initialize log file: %v", err)
		}
	}
}

func PrintInfo(format string, args ...interface{}) {
	msg := fmt.Sprintf(format, args...)
	fmt.Fprintf(os.Stderr, "%s\n", internal.FormatInfo(msg))
	if logFile != nil {
		_, file, line, _ := runtime.Caller(1)
		timestamp := time.Now().Format("2006-01-02T15:04:05.000")
		fmt.Fprintf(logFile, "%s [INFO] %s:%d %s\n", timestamp, file, line, msg)
	}
}

func PrintVerbose(format string, args ...interface{}) {
	msg := fmt.Sprintf(format, args...)
	if debug {
		fmt.Fprintf(os.Stderr, "%s\n", internal.FormatVerbose(msg))
	}
	if logFile != nil {
		_, file, line, _ := runtime.Caller(1)
		timestamp := time.Now().Format("2006-01-02T15:04:05.000")
		fmt.Fprintf(logFile, "%s [DEBUG] %s:%d %s\n", timestamp, file, line, msg)
	}
}

func PrintError(format string, args ...interface{}) {
	msg := fmt.Sprintf(format, args...)
	fmt.Fprintf(os.Stderr, "%s\n", internal.FormatError("ERROR: "+msg))
	if logFile != nil {
		_, file, line, _ := runtime.Caller(1)
		timestamp := time.Now().Format("2006-01-02T15:04:05.000")
		fmt.Fprintf(logFile, "%s [ERROR] %s:%d %s\n", timestamp, file, line, msg)
	}
}

func CloseLogFile() {
	if logFile != nil {
		logFile.Close()
	}
}
</file>

<file path="cmd/switch.go">
package cmd

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"gbm/internal"

	"github.com/spf13/cobra"
)

var (
	printPath bool
)

var switchCmd = &cobra.Command{
	Use:   "switch [WORKTREE_NAME]",
	Short: "Switch to a different worktree",
	Long: `Switch to a different worktree by environment variable name.

If no worktree name is provided, lists all available worktrees.
Use with shell integration for automatic directory switching:

  gbm-switch() {
      local target_dir=$(gbm switch --print-path "$1")
      if [ $? -eq 0 ] && [ -n "$target_dir" ]; then
          cd "$target_dir"
      else
          gbm switch "$@"
      fi
  }

Examples:
  gbm switch PROD      # Show path to PROD worktree
  gbm switch STAGING   # Show path to STAGING worktree
  gbm switch -         # Switch to previous worktree
  gbm switch           # List all available worktrees`,
	RunE: func(cmd *cobra.Command, args []string) error {
		PrintVerbose("Running switch command")

		wd, err := os.Getwd()
		if err != nil {
			return fmt.Errorf("failed to get working directory: %w", err)
		}

		repoRoot, err := internal.FindGitRoot(wd)
		if err != nil {
			return fmt.Errorf("failed to find git repository root: %w", err)
		}
		PrintVerbose("Checking status from repository root: %s", repoRoot)

		manager, err := internal.NewManager(repoRoot)
		if err != nil {
			return err
		}

		// Load .envrc configuration for proper sorting
		if err := manager.LoadEnvMapping(GetConfigPath()); err != nil {
			PrintVerbose("No .envrc found or failed to load: %v", err)
		}

		if len(args) == 0 {
			return listWorktrees(manager)
		}

		worktreeName := args[0]

		// Handle special case of "-" to switch to previous worktree
		if worktreeName == "-" {
			previous := manager.GetPreviousWorktree()
			if previous == "" {
				return fmt.Errorf("no previous worktree available")
			}
			PrintInfo("Switching to previous worktree: %s", previous)
			worktreeName = previous
		} else {
			worktreeName = strings.ToUpper(worktreeName)
		}

		return switchToWorktree(manager, worktreeName)
	},
}

func switchToWorktree(manager *internal.Manager, worktreeName string) error {
	PrintVerbose("Switching to worktree: %s", worktreeName)

	// Try exact match first
	targetPath, err := manager.GetWorktreePath(worktreeName)
	if err != nil {
		// If exact match fails, try fuzzy matching
		PrintVerbose("Exact match failed, trying fuzzy matching")
		matchedName := findFuzzyMatch(manager, worktreeName)
		if matchedName != "" {
			PrintInfo("Fuzzy matched '%s' to '%s'", worktreeName, matchedName)
			targetPath, err = manager.GetWorktreePath(matchedName)
			if err != nil {
				return err
			}
			worktreeName = matchedName // Update for display
		} else {
			return err
		}
	}

	// Track this worktree switch
	if err := manager.SetCurrentWorktree(worktreeName); err != nil {
		PrintVerbose("Failed to track current worktree: %v", err)
	}

	if printPath {
		fmt.Print(targetPath)
		return nil
	}

	// Check if shell integration is available by looking for gbm-switch function
	if os.Getenv("GBM_SHELL_INTEGRATION") != "" {
		// If shell integration is available, output cd command
		fmt.Printf("cd %s\n", targetPath)
		return nil
	}

	fmt.Printf("%s\n", internal.FormatInfo(fmt.Sprintf("Worktree %s is located at: %s", worktreeName, targetPath)))
	fmt.Println(internal.FormatSubtle("Use shell integration 'gbm-switch' function to automatically change directory"))
	fmt.Println(internal.FormatSubtle("Or run: cd " + targetPath))
	return nil
}

func findFuzzyMatch(manager *internal.Manager, target string) string {
	worktrees, err := manager.GetAllWorktrees()
	if err != nil {
		return ""
	}

	target = strings.ToUpper(target)

	// Look for case-insensitive substring matches
	var matches []string
	for name := range worktrees {
		upperName := strings.ToUpper(name)
		if strings.Contains(upperName, target) {
			matches = append(matches, name)
		}
	}

	// If we have exactly one match, return it
	if len(matches) == 1 {
		return matches[0]
	}

	// If we have multiple matches, prefer the one that starts with the target
	for _, match := range matches {
		upperMatch := strings.ToUpper(match)
		if strings.HasPrefix(upperMatch, target) {
			return match
		}
	}

	// If no prefix match, return the first match (if any)
	if len(matches) > 0 {
		return matches[0]
	}

	return ""
}

func listWorktrees(manager *internal.Manager) error {
	PrintVerbose("Listing available worktrees")

	worktrees, err := manager.GetAllWorktrees()
	if err != nil {
		return err
	}

	if len(worktrees) == 0 {
		fmt.Println(internal.FormatInfo("No worktrees found. Run 'gbm init' to create worktrees."))
		return nil
	}

	fmt.Println(internal.FormatSubHeader("Available worktrees:"))

	// Get sorted worktree names (.envrc first, then ad hoc by creation time desc)
	names := manager.GetSortedWorktreeNames(worktrees)

	for _, name := range names {
		info := worktrees[name]
		status := "ready"
		if info.GitStatus != nil {
			status = manager.GetStatusIcon(info.GitStatus)
		}

		relPath, _ := filepath.Rel(".", info.Path)
		branchInfo := info.CurrentBranch
		if info.ExpectedBranch != info.CurrentBranch {
			branchInfo = fmt.Sprintf("%s -> %s", info.CurrentBranch, info.ExpectedBranch)
		}
		fmt.Printf("  %s %-12s %s (%s)\n", status, name, relPath, branchInfo)
	}

	return nil
}

func init() {
	rootCmd.AddCommand(switchCmd)
	switchCmd.Flags().BoolVar(&printPath, "print-path", false, "Print the worktree path only (for shell integration)")

	// Add completion for worktree names
	switchCmd.ValidArgsFunction = func(cmd *cobra.Command, args []string, toComplete string) ([]string, cobra.ShellCompDirective) {
		if len(args) != 0 {
			return nil, cobra.ShellCompDirectiveNoFileComp
		}
		return getWorktreeNames(), cobra.ShellCompDirectiveNoFileComp
	}
}

func getWorktreeNames() []string {
	wd, err := os.Getwd()
	if err != nil {
		return nil
	}

	repoRoot, err := internal.FindGitRoot(wd)
	if err != nil {
		return nil
	}

	manager, err := internal.NewManager(repoRoot)
	if err != nil {
		return nil
	}

	worktrees, err := manager.GetAllWorktrees()
	if err != nil {
		return nil
	}

	var names []string
	for name := range worktrees {
		names = append(names, name)
	}
	return names
}
</file>

<file path="internal/table.go">
package internal

import (
	"fmt"

	"github.com/charmbracelet/lipgloss"
	"github.com/charmbracelet/lipgloss/table"
)

type Table struct {
	table *table.Table
}

func NewTable(headers []string) *Table {
	t := table.New().
		Border(lipgloss.NormalBorder()).
		BorderStyle(TableBorderStyle).
		StyleFunc(func(row, col int) lipgloss.Style {
			if row == table.HeaderRow {
				return TableHeaderStyle
			}
			return TableCellStyle
		}).
		Headers(headers...)

	return &Table{
		table: t,
	}
}

func (t *Table) AddRow(row []string) {
	t.table.Row(row...)
}

func (t *Table) Print() {
	if t.table == nil {
		return
	}
	fmt.Println(t.table.String())
}

func (t *Table) String() string {
	if t.table == nil {
		return ""
	}
	return t.table.String()
}
</file>

<file path="cmd/init.go">
package cmd

import (
	"fmt"
	"os"

	"gbm/internal"

	"github.com/spf13/cobra"
)

var (
	initForce bool
	initFetch bool
)

var initCmd = &cobra.Command{
	Use:   "init",
	Short: "Initialize the current Git repository for branch management",
	Long: `Initialize the current Git repository for branch management.

Creates initial worktree structure based on .envrc file.
Validates that the repository is a valid Git repo and creates .gbm/ directory for metadata storage.`,
	RunE: func(cmd *cobra.Command, args []string) error {
		wd, err := os.Getwd()
		if err != nil {
			return fmt.Errorf("failed to get working directory: %w", err)
		}

		repoRoot, err := internal.FindGitRoot(wd)
		if err != nil {
			return fmt.Errorf("failed to find git repository root: %w", err)
		}

		manager, err := internal.NewManager(repoRoot)
		if err != nil {
			return err
		}

		PrintVerbose("Loading .envrc configuration from: %s", GetConfigPath())
		if err := manager.LoadEnvMapping(GetConfigPath()); err != nil {
			return fmt.Errorf("failed to load .envrc: %w", err)
		}

		PrintVerbose("Initializing worktree management (force=%v, fetch=%v)", initForce, initFetch)
		if err := manager.Initialize(initForce, initFetch); err != nil {
			return err
		}

		PrintInfo("%s", internal.FormatSuccess("Successfully initialized Git Branch Manager"))
		return nil
	},
}

func init() {
	rootCmd.AddCommand(initCmd)
	initCmd.Flags().BoolVar(&initForce, "force", false, "initialize even if worktrees already exist")
	initCmd.Flags().BoolVar(&initFetch, "fetch", false, "fetch remote branches during initialization")
}
</file>

<file path="cmd/shell-integration.go">
package cmd

import (
	"fmt"

	"github.com/spf13/cobra"
)

var shellIntegrationCmd = &cobra.Command{
	Use:   "shell-integration",
	Short: "Generate shell integration code for automatic checking",
	Long: `Generate shell integration code that can be evaluated in your shell to enable automatic checking.

This command outputs shell code that can be added to your .bashrc, .zshrc, or other shell configuration
to automatically check for worktree drift and display status in your prompt.

Example usage:
  eval "$(gbm shell-integration)"

Or add to your shell configuration:
  echo 'eval "$(gbm shell-integration)"' >> ~/.bashrc`,
	RunE: func(cmd *cobra.Command, args []string) error {
		PrintVerbose("Generating shell integration code")
		shellCode := `
# Git Branch Manager (gbm) shell integration
# Automatically check for worktree drift and display status

# Set environment variable to indicate shell integration is active
export GBM_SHELL_INTEGRATION=1

# Enable completion
if [ -n "$ZSH_VERSION" ]; then
    # For zsh, enable completion
    autoload -U compinit && compinit
    source <(gbm completion zsh)
elif [ -n "$BASH_VERSION" ]; then
    # For bash, enable completion
    source <(gbm completion bash)
fi

__gbm_prompt() {
    if [ -f ".envrc" ] && [ -d ".git" ]; then
        local gbm_status=$(gbm check --format=prompt 2>/dev/null)
        if [ $? -eq 0 ] && [ -n "$gbm_status" ]; then
            echo "$gbm_status"
        fi
    fi
}

# Add gbm status to PS1 for bash/zsh
if [ -n "$BASH_VERSION" ] || [ -n "$ZSH_VERSION" ]; then
    if [[ "$PS1" != *"__gbm_prompt"* ]]; then
        PS1='$(__gbm_prompt)'$PS1
    fi
fi

# Function to manually check gbm status
gbm-status() {
    gbm check --format=text
}

# Function to quickly sync worktrees
gbm-sync() {
    gbm sync "$@"
}

# Function to switch between worktrees
gbm-switch() {
    if [ $# -eq 0 ]; then
        gbm switch
        return
    fi

    local target_dir=$(gbm switch --print-path "$1" 2>/dev/null)
    if [ $? -eq 0 ] && [ -n "$target_dir" ]; then
        cd "$target_dir"
        echo "Switched to worktree: $1"
    else
        gbm switch "$@"
    fi
}

# Override gbm function to handle switch command specially
gbm() {
    if [ "$1" = "switch" ] && [ $# -gt 1 ]; then
        # For switch command with arguments, execute the cd command
        local cmd_output=$(command gbm "$@" 2>/dev/null)
        if [ $? -eq 0 ] && [[ "$cmd_output" =~ ^cd ]]; then
            eval "$cmd_output"
            echo "Switched to worktree: $2"
        else
            command gbm "$@"
        fi
    else
        # For all other commands, just pass through
        command gbm "$@"
    fi
}
`
		PrintVerbose("Outputting shell integration script")
		fmt.Print(shellCode)
		return nil
	},
}

func init() {
	rootCmd.AddCommand(shellIntegrationCmd)
}
</file>

<file path="cmd/sync.go">
package cmd

import (
	"fmt"
	"os"

	"gbm/internal"

	"github.com/spf13/cobra"
)

var (
	syncDryRun bool
	syncForce  bool
	syncFetch  bool
)

var syncCmd = &cobra.Command{
	Use:   "sync",
	Short: "Synchronize all worktrees with current .envrc definitions",
	Long: `Synchronize all worktrees with current .envrc definitions.

Creates missing worktrees for new environment variables, updates existing worktrees
if branch references have changed, and optionally removes orphaned worktrees.`,
	RunE: func(cmd *cobra.Command, args []string) error {
		wd, err := os.Getwd()
		if err != nil {
			return fmt.Errorf("failed to get working directory: %w", err)
		}

		repoRoot, err := internal.FindGitRoot(wd)
		if err != nil {
			return fmt.Errorf("failed to find git repository root: %w", err)
		}

		manager, err := internal.NewManager(repoRoot)
		if err != nil {
			return err
		}

		PrintVerbose("Loading .envrc configuration from: %s", GetConfigPath())
		if err := manager.LoadEnvMapping(GetConfigPath()); err != nil {
			return fmt.Errorf("failed to load .envrc: %w", err)
		}

		if syncDryRun {
			iconManager := internal.GetGlobalIconManager()
			PrintInfo("%s", internal.FormatStatusIcon(iconManager.DryRun(), "Dry run mode - showing what would be changed:"))
			status, err := manager.GetSyncStatus()
			if err != nil {
				return err
			}

			if status.InSync {
				PrintInfo("%s", internal.FormatSuccess("All worktrees are in sync"))
				return nil
			}

			if len(status.MissingWorktrees) > 0 {
				iconManager := internal.GetGlobalIconManager()
				PrintInfo("%s", internal.FormatStatusIcon(iconManager.Missing(), "Missing worktrees:"))
				for _, envVar := range status.MissingWorktrees {
					PrintInfo("  • %s", envVar)
				}
			}

			if len(status.BranchChanges) > 0 {
				iconManager := internal.GetGlobalIconManager()
				PrintInfo("%s", internal.FormatStatusIcon(iconManager.Changes(), "Branch changes needed:"))
				for envVar, change := range status.BranchChanges {
					PrintInfo("  • %s: %s → %s", envVar, change.OldBranch, change.NewBranch)
				}
			}

			if len(status.OrphanedWorktrees) > 0 {
				iconManager := internal.GetGlobalIconManager()
				PrintInfo("%s", internal.FormatStatusIcon(iconManager.Orphaned(), "Orphaned worktrees (use --force to remove):"))
				for _, envVar := range status.OrphanedWorktrees {
					PrintInfo("  • %s", envVar)
				}
			}

			return nil
		}

		PrintVerbose("Synchronizing worktrees (force=%v, fetch=%v)", syncForce, syncFetch)
		if err := manager.Sync(syncDryRun, syncForce, syncFetch); err != nil {
			return err
		}

		PrintInfo("%s", internal.FormatSuccess("Successfully synchronized worktrees"))
		return nil
	},
}

func init() {
	rootCmd.AddCommand(syncCmd)
	syncCmd.Flags().BoolVar(&syncDryRun, "dry-run", false, "show what would be changed without making changes")
	syncCmd.Flags().BoolVar(&syncForce, "force", false, "skip confirmation prompts and remove orphaned worktrees")
	syncCmd.Flags().BoolVar(&syncFetch, "fetch", false, "update remote tracking before sync")
}
</file>

<file path="cmd/validate.go">
package cmd

import (
	"fmt"
	"os"

	"gbm/internal"

	"github.com/spf13/cobra"
)

var validateCmd = &cobra.Command{
	Use:   "validate",
	Short: "Validate .envrc syntax and branch references",
	Long: `Validate .envrc syntax and branch references.

Checks if referenced branches exist locally or remotely. Useful for CI/CD integration
and ensuring configuration correctness before syncing.`,
	RunE: func(cmd *cobra.Command, args []string) error {
		wd, err := os.Getwd()
		if err != nil {
			return fmt.Errorf("failed to get working directory: %w", err)
		}

		repoRoot, err := internal.FindGitRoot(wd)
		if err != nil {
			return fmt.Errorf("failed to find git repository root: %w", err)
		}

		manager, err := internal.NewManager(repoRoot)
		if err != nil {
			return err
		}

		PrintVerbose("Loading .envrc configuration from: %s", GetConfigPath())
		if err := manager.LoadEnvMapping(GetConfigPath()); err != nil {
			return fmt.Errorf("failed to load .envrc: %w", err)
		}

		PrintVerbose("Validating branch references...")

		// Get the mapping to validate
		mapping, err := manager.GetEnvMapping()
		if err != nil {
			return err
		}

		// Create table for validation results
		table := internal.NewTable([]string{"ENV VARIABLE", "BRANCH", "STATUS"})

		allValid := true
		for envVar, branchName := range mapping {
			exists, err := manager.BranchExists(branchName)
			if err != nil {
				table.AddRow([]string{envVar, branchName, internal.FormatError("ERROR")})
				allValid = false
				continue
			}

			if exists {
				table.AddRow([]string{envVar, branchName, internal.FormatSuccess("VALID")})
			} else {
				table.AddRow([]string{envVar, branchName, internal.FormatError("NOT FOUND")})
				allValid = false
			}
		}

		// Display validation header
		if allValid {
			PrintInfo("%s", internal.FormatSuccess(".envrc validation passed"))
		} else {
			PrintError("%s", internal.FormatError(".envrc validation failed"))
		}

		fmt.Println()
		table.Print()

		if !allValid {
			return fmt.Errorf("validation failed - one or more branches do not exist")
		}

		return nil
	},
}

func init() {
	rootCmd.AddCommand(validateCmd)
}
</file>

<file path="internal/config.go">
package internal

import (
	"bufio"
	"fmt"
	"os"
	"path/filepath"
	"regexp"
	"strings"
	"time"

	"github.com/BurntSushi/toml"
)

type Config struct {
	Settings ConfigSettings `toml:"settings"`
	State    ConfigState    `toml:"state"`
	Icons    ConfigIcons    `toml:"icons"`
}

type ConfigSettings struct {
	WorktreePrefix        string `toml:"worktree_prefix"`
	AutoFetch             bool   `toml:"auto_fetch"`
	CreateMissingBranches bool   `toml:"create_missing_branches"`
}

type ConfigState struct {
	LastSync         time.Time `toml:"last_sync"`
	TrackedVars      []string  `toml:"tracked_vars"`
	AdHocWorktrees   []string  `toml:"ad_hoc_worktrees"`
	CurrentWorktree  string    `toml:"current_worktree"`
	PreviousWorktree string    `toml:"previous_worktree"`
}

type ConfigIcons struct {
	// Status icons
	Success  string `toml:"success"`
	Warning  string `toml:"warning"`
	Error    string `toml:"error"`
	Info     string `toml:"info"`
	Orphaned string `toml:"orphaned"`
	DryRun   string `toml:"dry_run"`
	Missing  string `toml:"missing"`
	Changes  string `toml:"changes"`

	// Git status icons
	GitClean    string `toml:"git_clean"`
	GitDirty    string `toml:"git_dirty"`
	GitAhead    string `toml:"git_ahead"`
	GitBehind   string `toml:"git_behind"`
	GitDiverged string `toml:"git_diverged"`
	GitUnknown  string `toml:"git_unknown"`
}

type EnvMapping struct {
	Variables map[string]string
}

func DefaultConfig() *Config {
	return &Config{
		Settings: ConfigSettings{
			WorktreePrefix:        "worktrees",
			AutoFetch:             true,
			CreateMissingBranches: false,
		},
		State: ConfigState{
			LastSync:         time.Time{},
			TrackedVars:      []string{},
			AdHocWorktrees:   []string{},
			CurrentWorktree:  "",
			PreviousWorktree: "",
		},
		Icons: ConfigIcons{
			// Status icons
			Success:  "✅",
			Warning:  "⚠️",
			Error:    "❌",
			Info:     "💡",
			Orphaned: "🗑️",
			DryRun:   "🔍",
			Missing:  "📁",
			Changes:  "🔄",

			// Git status icons
			GitClean:    "✓",
			GitDirty:    "~",
			GitAhead:    "↑",
			GitBehind:   "↓",
			GitDiverged: "⇕",
			GitUnknown:  "?",
		},
	}
}

func LoadConfig(gbmDir string) (*Config, error) {
	configPath := filepath.Join(gbmDir, "config.toml")

	if _, err := os.Stat(configPath); os.IsNotExist(err) {
		return DefaultConfig(), nil
	}

	var config Config
	if _, err := toml.DecodeFile(configPath, &config); err != nil {
		return nil, fmt.Errorf("failed to decode config file: %w", err)
	}

	return &config, nil
}

func (c *Config) Save(gbmDir string) error {
	if err := os.MkdirAll(gbmDir, 0755); err != nil {
		return fmt.Errorf("failed to create .gbm directory: %w", err)
	}

	configPath := filepath.Join(gbmDir, "config.toml")
	file, err := os.Create(configPath)
	if err != nil {
		return fmt.Errorf("failed to create config file: %w", err)
	}
	defer file.Close()

	encoder := toml.NewEncoder(file)
	if err := encoder.Encode(c); err != nil {
		return fmt.Errorf("failed to encode config: %w", err)
	}

	return nil
}

func ParseEnvrc(path string) (*EnvMapping, error) {
	file, err := os.Open(path)
	if err != nil {
		return nil, fmt.Errorf("failed to open .envrc file: %w", err)
	}
	defer file.Close()

	mapping := &EnvMapping{
		Variables: make(map[string]string),
	}

	scanner := bufio.NewScanner(file)
	envVarRegex := regexp.MustCompile(`^([A-Z_][A-Z0-9_]*)=(.+)$`)

	for scanner.Scan() {
		line := strings.TrimSpace(scanner.Text())

		if line == "" || strings.HasPrefix(line, "#") {
			continue
		}

		matches := envVarRegex.FindStringSubmatch(line)
		if len(matches) == 3 {
			varName := matches[1]
			branchName := strings.Trim(matches[2], "\"'")
			mapping.Variables[varName] = branchName
		}
	}

	if err := scanner.Err(); err != nil {
		return nil, fmt.Errorf("error reading .envrc file: %w", err)
	}

	return mapping, nil
}
</file>

<file path="cmd/add.go">
package cmd

import (
	"fmt"
	"strings"

	"gbm/internal"

	"github.com/spf13/cobra"
)

var (
	newBranch   bool
	baseBranch  string
	interactive bool
)

var addCmd = &cobra.Command{
	Use:   "add <worktree-name> [branch-name]",
	Short: "Add a new worktree",
	Long: `Add a new worktree with various options:
- Create on existing branch: gbm add INGSVC-5544 existing-branch-name
- Create on new branch: gbm add INGSVC-5544 feature/new-branch -b
- Interactive mode: gbm add INGSVC-5544 --interactive
- Tab completion: Shows JIRA keys with summaries, suggests branch names when needed`,
	Args: cobra.MinimumNArgs(1),
	RunE: func(cmd *cobra.Command, args []string) error {
		worktreeName := args[0]

		// Find git repository root
		repoPath, err := internal.FindGitRoot(".")
		if err != nil {
			return fmt.Errorf("not in a git repository: %w", err)
		}

		// Create manager
		manager, err := internal.NewManager(repoPath)
		if err != nil {
			return fmt.Errorf("failed to create manager: %w", err)
		}

		// Load .envrc configuration to check if worktree is tracked
		if err := manager.LoadEnvMapping(GetConfigPath()); err != nil {
			PrintVerbose("No .envrc found or failed to load, treating as ad hoc worktree: %v", err)
		}

		var branchName string

		if interactive {
			// Handle interactive mode
			branchName, err = handleInteractive(manager)
			if err != nil {
				return fmt.Errorf("failed to handle interactive mode: %w", err)
			}
		} else {
			// Handle direct specification
			if len(args) > 1 {
				branchName = args[1]
			} else if newBranch {
				// Generate branch name from worktree name
				branchName = generateBranchName(worktreeName)
			} else if internal.IsJiraKey(worktreeName) {
				// Auto-suggest branch name for JIRA keys
				suggestedBranch := generateBranchName(worktreeName)
				return fmt.Errorf("branch name required. Suggested: %s\n\nTry: gbm add %s %s -b", suggestedBranch, worktreeName, suggestedBranch)
			} else {
				return fmt.Errorf("branch name required when not creating new branch (use -b to create new branch)")
			}
		}

		PrintInfo("Adding worktree '%s' on branch '%s'", worktreeName, branchName)

		// Add the worktree
		if err := manager.AddWorktree(worktreeName, branchName, newBranch); err != nil {
			return fmt.Errorf("failed to add worktree: %w", err)
		}

		PrintInfo("Worktree '%s' added successfully", worktreeName)

		return nil
	},
}

func handleInteractive(manager *internal.Manager) (string, error) {
	// Get available branches
	branches, err := manager.GetRemoteBranches()
	if err != nil {
		return "", fmt.Errorf("failed to get remote branches: %w", err)
	}

	fmt.Println(internal.FormatSubHeader("Available branches:"))
	for i, branch := range branches {
		fmt.Printf("  %s\n", internal.FormatInfo(fmt.Sprintf("%d. %s", i+1, branch)))
	}
	fmt.Printf("  %s\n", internal.FormatInfo(fmt.Sprintf("%d. Create new branch", len(branches)+1)))

	var choice int
	fmt.Print(internal.FormatPrompt("Select a branch: "))
	if _, err := fmt.Scanln(&choice); err != nil {
		return "", fmt.Errorf("failed to read choice: %w", err)
	}

	if choice < 1 || choice > len(branches)+1 {
		return "", fmt.Errorf("invalid choice")
	}

	if choice == len(branches)+1 {
		// Create new branch
		newBranch = true
		fmt.Print(internal.FormatPrompt("Enter new branch name: "))
		var branchName string
		if _, err := fmt.Scanln(&branchName); err != nil {
			return "", fmt.Errorf("failed to read branch name: %w", err)
		}
		return branchName, nil
	} else {
		// Use existing branch
		newBranch = false
		return branches[choice-1], nil
	}
}

func generateBranchName(worktreeName string) string {
	// Check if this is a JIRA key first
	if internal.IsJiraKey(worktreeName) {
		branchName, err := internal.GenerateBranchFromJira(worktreeName)
		if err != nil {
			PrintVerbose("Failed to generate branch name from JIRA issue %s: %v", worktreeName, err)
			PrintInfo("Could not fetch JIRA issue details. Using default branch name format.")
			// Generate a basic branch name from the JIRA key
			return fmt.Sprintf("feature/%s", strings.ToLower(worktreeName))
		} else {
			PrintInfo("Auto-generated branch name from JIRA issue: %s", branchName)
			return branchName
		}
	}

	// Convert worktree name to a valid branch name
	branchName := strings.ReplaceAll(worktreeName, " ", "-")
	branchName = strings.ReplaceAll(branchName, "_", "-")
	branchName = strings.ToLower(branchName)

	// Add feature/ prefix if not already present
	if !strings.HasPrefix(branchName, "feature/") && !strings.HasPrefix(branchName, "bugfix/") && !strings.HasPrefix(branchName, "hotfix/") {
		branchName = "feature/" + branchName
	}

	return branchName
}

func init() {
	rootCmd.AddCommand(addCmd)

	addCmd.Flags().BoolVarP(&newBranch, "new-branch", "b", false, "Create a new branch for the worktree")
	addCmd.Flags().StringVar(&baseBranch, "base", "", "Base branch for new branch (default: current branch)")
	addCmd.Flags().BoolVarP(&interactive, "interactive", "i", false, "Interactive mode to select branch")

	// Add JIRA key completions for the first positional argument
	addCmd.ValidArgsFunction = func(cmd *cobra.Command, args []string, toComplete string) ([]string, cobra.ShellCompDirective) {
		if len(args) == 0 {
			// Complete JIRA keys with summaries for context
			jiraIssues, err := internal.GetJiraIssues()
			if err != nil {
				// If JIRA CLI is not available, fall back to no completions
				return nil, cobra.ShellCompDirectiveNoFileComp
			}

			var completions []string
			for _, issue := range jiraIssues {
				// Format: "KEY\tSummary" - clean completion of just the key with summary context
				completion := fmt.Sprintf("%s\t%s", issue.Key, issue.Summary)
				completions = append(completions, completion)
			}
			return completions, cobra.ShellCompDirectiveNoFileComp
		} else if len(args) == 1 {
			// Complete branch name based on the JIRA key
			worktreeName := args[0]
			if internal.IsJiraKey(worktreeName) {
				branchName, err := internal.GenerateBranchFromJira(worktreeName)
				if err != nil {
					// Fallback to default branch name generation
					branchName = fmt.Sprintf("feature/%s", strings.ToLower(worktreeName))
				}
				return []string{branchName}, cobra.ShellCompDirectiveNoFileComp
			}
			return nil, cobra.ShellCompDirectiveNoFileComp
		}
		return nil, cobra.ShellCompDirectiveNoFileComp
	}
}
</file>

<file path="cmd/clean.go">
package cmd

import (
	"fmt"
	"os"

	"gbm/internal"

	"github.com/spf13/cobra"
)

var (
	cleanForce bool
)

var cleanCmd = &cobra.Command{
	Use:   "clean",
	Short: "Remove orphaned worktrees (interactive by default)",
	Long: `Remove orphaned worktrees that are no longer defined in .envrc.

By default, this command is interactive and will prompt for confirmation before removing
each orphaned worktree. Use --force to skip confirmations.`,
	RunE: func(cmd *cobra.Command, args []string) error {
		wd, err := os.Getwd()
		if err != nil {
			return fmt.Errorf("failed to get working directory: %w", err)
		}

		repoRoot, err := internal.FindGitRoot(wd)
		if err != nil {
			return fmt.Errorf("failed to find git repository root: %w", err)
		}
		PrintVerbose("Starting cleanup from repository root: %s", repoRoot)

		manager, err := internal.NewManager(repoRoot)
		if err != nil {
			return err
		}

		PrintVerbose("Loading .envrc configuration from: %s", GetConfigPath())
		if err := manager.LoadEnvMapping(GetConfigPath()); err != nil {
			return fmt.Errorf("failed to load .envrc: %w", err)
		}

		PrintVerbose("Retrieving sync status to identify orphaned worktrees")
		status, err := manager.GetSyncStatus()
		if err != nil {
			return err
		}

		PrintVerbose("Found %d orphaned worktrees to process", len(status.OrphanedWorktrees))
		if len(status.OrphanedWorktrees) == 0 {
			PrintInfo("%s", internal.FormatSuccess("No orphaned worktrees found"))
			return nil
		}

		iconManager := internal.GetGlobalIconManager()
		PrintInfo("%s", internal.FormatStatusIcon(iconManager.Orphaned(), fmt.Sprintf("Found %d orphaned worktree(s):", len(status.OrphanedWorktrees))))
		for _, envVar := range status.OrphanedWorktrees {
			PrintInfo("  • %s", envVar)
		}
		fmt.Println()

		PrintVerbose("Cleanup mode: force=%v", cleanForce)
		if cleanForce {
			PrintInfo("%s", internal.FormatStatusIcon("🔥", "Force mode enabled - removing all orphaned worktrees..."))
		} else {
			PrintInfo("%s", internal.FormatInfo("Interactive mode - you will be prompted for each worktree"))
		}

		PrintVerbose("Initiating cleanup of orphaned worktrees")
		if err := manager.CleanOrphaned(cleanForce); err != nil {
			return err
		}

		PrintInfo("%s", internal.FormatSuccess("Orphaned worktree cleanup completed"))
		return nil
	},
}

func init() {
	rootCmd.AddCommand(cleanCmd)
	cleanCmd.Flags().BoolVar(&cleanForce, "force", false, "force removal without confirmation prompts")
}
</file>

<file path="cmd/check.go">
package cmd

import (
	"encoding/json"
	"fmt"
	"os"
	"slices"

	"gbm/internal"

	"github.com/spf13/cobra"
)

var (
	checkFormat   string
	checkExitCode bool
)

type CheckOutput struct {
	InSync    bool     `json:"in_sync"`
	Status    string   `json:"status"`
	Issues    []string `json:"issues,omitempty"`
	Indicator string   `json:"indicator"`
}

var checkCmd = &cobra.Command{
	Use:   "check",
	Short: "Quick check for drift between .envrc and worktrees",
	Long: `Quick check for drift between .envrc and worktrees.

Can be used for shell integration or automated checking. Returns non-zero exit code if out of sync.`,
	RunE: func(cmd *cobra.Command, args []string) error {
		wd, err := os.Getwd()
		if err != nil {
			return fmt.Errorf("failed to get working directory: %w", err)
		}

		repoRoot, err := internal.FindGitRoot(wd)
		if err != nil {
			return fmt.Errorf("failed to find git repository root: %w", err)
		}
		PrintVerbose("Performing check from repository root: %s", repoRoot)

		manager, err := internal.NewManager(repoRoot)
		if err != nil {
			if checkExitCode {
				os.Exit(1)
			}
			return err
		}

		PrintVerbose("Loading .envrc configuration from: %s", GetConfigPath())
		if err := manager.LoadEnvMapping(GetConfigPath()); err != nil {
			if checkExitCode {
				os.Exit(1)
			}
			return fmt.Errorf("failed to load .envrc: %w", err)
		}

		PrintVerbose("Retrieving sync status for check operation")
		status, err := manager.GetSyncStatus()
		if err != nil {
			if checkExitCode {
				os.Exit(1)
			}
			return err
		}

		output := CheckOutput{
			InSync: status.InSync,
			Issues: []string{},
		}

		iconManager := internal.GetGlobalIconManager()
		if status.InSync {
			output.Status = "in_sync"
			output.Indicator = iconManager.Success()
		} else {
			output.Status = "out_of_sync"
			output.Indicator = iconManager.Warning()

			for _, envVar := range status.MissingWorktrees {
				output.Issues = append(output.Issues, fmt.Sprintf("Missing worktree: %s", envVar))
			}

			for envVar, change := range status.BranchChanges {
				output.Issues = append(output.Issues, fmt.Sprintf("Branch change: %s (%s → %s)", envVar, change.OldBranch, change.NewBranch))
			}

			for _, envVar := range status.OrphanedWorktrees {
				output.Issues = append(output.Issues, fmt.Sprintf("Orphaned worktree: %s", envVar))
			}
		}

		PrintVerbose("Formatting output as: %s", checkFormat)
		switch checkFormat {
		case "json":
			encoder := json.NewEncoder(os.Stdout)
			encoder.SetIndent("", "  ")
			if err := encoder.Encode(output); err != nil {
				return fmt.Errorf("failed to encode JSON: %w", err)
			}
		case "prompt":
			if !status.InSync {
				fmt.Printf("[gbm:%s] ", output.Indicator)
			}
		case "table":
			// Get worktree information for table
			worktrees, err := manager.GetWorktreeList()
			if err != nil {
				return fmt.Errorf("failed to get worktree list: %w", err)
			}
			PrintVerbose("Generating table format for %d worktrees", len(worktrees))

			table := internal.NewTable([]string{"ENV VAR", "BRANCH", "STATUS", "ISSUES"})

			for envVar, info := range worktrees {
				statusText := "OK"
				issues := ""

				// Check for issues
				if slices.Contains(status.MissingWorktrees, envVar) {
					statusText = "MISSING"
					issues = "Worktree missing"
				}

				if change, exists := status.BranchChanges[envVar]; exists {
					statusText = "OUT_OF_SYNC"
					issues = fmt.Sprintf("%s → %s", change.OldBranch, change.NewBranch)
				}

				if slices.Contains(status.OrphanedWorktrees, envVar) {
					statusText = "ORPHANED"
					issues = "Variable removed"
				}

				table.AddRow([]string{envVar, info.ExpectedBranch, statusText, issues})
			}

			table.Print()
		case "text":
			fallthrough
		default:
			if status.InSync {
				PrintInfo("%s", internal.FormatStatusIcon(output.Indicator, "All worktrees in sync"))
			} else {
				PrintInfo("%s", internal.FormatStatusIcon(output.Indicator, fmt.Sprintf("%d issue(s) detected", len(output.Issues))))
				for _, issue := range output.Issues {
					PrintInfo("  • %s", issue)
				}
			}
		}

		if checkExitCode {
			if status.InSync {
				os.Exit(0)
			} else {
				os.Exit(1)
			}
		}

		return nil
	},
}

func init() {
	rootCmd.AddCommand(checkCmd)
	checkCmd.Flags().StringVar(&checkFormat, "format", "text", "output format (prompt|json|text|table)")
	checkCmd.Flags().BoolVar(&checkExitCode, "exit-code", false, "return status code only")
}
</file>

<file path="cmd/list.go">
package cmd

import (
	"fmt"
	"os"
	"slices"

	"gbm/internal"

	"github.com/spf13/cobra"
)

var listCmd = &cobra.Command{
	Use:   "list",
	Short: "List all managed worktrees and their status",
	Long: `List all managed worktrees and their status.

Shows environment variable mappings and indicates sync status for each entry.`,
	RunE: func(cmd *cobra.Command, args []string) error {
		wd, err := os.Getwd()
		if err != nil {
			return fmt.Errorf("failed to get working directory: %w", err)
		}

		repoRoot, err := internal.FindGitRoot(wd)
		if err != nil {
			return fmt.Errorf("failed to find git repository root: %w", err)
		}
		PrintVerbose("Listing worktrees from repository root: %s", repoRoot)

		manager, err := internal.NewManager(repoRoot)
		if err != nil {
			return err
		}

		PrintVerbose("Loading .envrc configuration from: %s", GetConfigPath())
		if err := manager.LoadEnvMapping(GetConfigPath()); err != nil {
			return fmt.Errorf("failed to load .envrc: %w", err)
		}

		PrintVerbose("Retrieving sync status for list operation")
		status, err := manager.GetSyncStatus()
		if err != nil {
			return err
		}

		PrintVerbose("Fetching detailed worktree information")
		// Get all worktrees (including those created with gbm add)
		worktrees, err := manager.GetAllWorktrees()
		if err != nil {
			return fmt.Errorf("failed to get worktree list: %w", err)
		}

		PrintVerbose("Found %d worktrees to display", len(worktrees))
		if len(worktrees) == 0 {
			return nil
		}

		PrintVerbose("Building worktree list table")
		table := internal.NewTable([]string{"WORKTREE", "BRANCH", "STATUS", "PATH"})

		iconManager := internal.GetGlobalIconManager()

		// Get sorted worktree names (.envrc first, then ad hoc by creation time desc)
		sortedNames := manager.GetSortedWorktreeNames(worktrees)

		for _, worktreeName := range sortedNames {
			info := worktrees[worktreeName]
			statusIcon := iconManager.Success()
			statusText := "OK"

			// Check if this worktree has issues
			if slices.Contains(status.MissingWorktrees, worktreeName) {
				statusIcon = iconManager.Error()
				statusText = "MISSING"
			}

			if change, exists := status.BranchChanges[worktreeName]; exists {
				statusIcon = iconManager.Warning()
				statusText = "OUT_OF_SYNC"
				info.CurrentBranch = change.OldBranch
			}

			if slices.Contains(status.OrphanedWorktrees, worktreeName) {
				statusIcon = iconManager.Orphaned()
				statusText = "UNTRACKED"
			}

			// For worktrees not in .envrc, mark as "UNTRACKED"
			if info.ExpectedBranch == info.CurrentBranch && info.ExpectedBranch != "" {
				// Check if this worktree is actually tracked in .envrc
				envMapping, err := manager.GetEnvMapping()
				if err == nil {
					if _, exists := envMapping[worktreeName]; !exists {
						statusIcon = iconManager.Info()
						statusText = "UNTRACKED"
					}
				}
			}

			branchDisplay := info.CurrentBranch
			if info.ExpectedBranch != "" && info.ExpectedBranch != info.CurrentBranch {
				branchDisplay = fmt.Sprintf("%s (expected: %s)", info.CurrentBranch, info.ExpectedBranch)
			}

			table.AddRow([]string{worktreeName, branchDisplay, internal.FormatStatusIcon(statusIcon, statusText), info.Path})
		}

		table.Print()

		fmt.Println()
		if !status.InSync {
			PrintInfo("%s", internal.FormatInfo("Run 'gbm status' for detailed information or 'gbm sync' to fix issues"))
		}

		return nil
	},
}

func init() {
	rootCmd.AddCommand(listCmd)
}
</file>

<file path="docs/todo.md">
# TODO
- [x] option to log to file
- [x] binary can be called anywhere inside the git repo
- [x] add clone verb
    - [x] clones a bare repo
    - [x] creates the MAIN worktree using the HEAD branch
    - [x] detects if the worktree has a .envrc
        * YES - use that as the .envrc for the repo
        * NO - tell user to create a .envrc file. suggest to user to generate one based on the initial worktree we created.
- [x] suport `add` verb to add worktree
    - [x] normal worktree on new branch
    - [x] normal worktree on existing branch
    - [x] worktree based on JIRA ticket (use `jira-cli` to select ticket)
        - [x] configure your own rules for parsing jira ticket for branch name
    - [x] https://github.com/ankitpokhrel/jira-cli/discussions/356
- [x] enhance `switch` command (future features)
    - [x] auto-completion for worktree names
    - [x] automatic directory switching with shell integration
    - [x] fuzzy matching (e.g., `gbm switch prod` matches `PROD`)
- [x] add `push` verb
    - [x] `gbm push` pushes worktree if in a worktree - otherwise error
    - [x] `gbm push <worktree_name>` pushes named worktree - no matter what directoy you are in
    - [x] `gbm push --all` pushes all managed worktrees
- [x] add `pull` verb
    - [x] `gbm pull` pulls worktree if in a worktree - otherwise error
    - [x] `gbm pull <worktree_name>` pulls named worktree - no matter what directoy you are in
    - [x] `gbm pull --all` pulls all managed worktrees
- [x] use lipgloss for tables and styling
- [x] fix `gbm pull`
```sh
󰀵 jschneider  ~/code/scratch/integrator/worktrees/MAIN   master  󰟓 v1.24.4
  gbm pull
Pulling current worktree 'MAIN'...
There is no tracking information for the current branch.
Please specify which branch you want to merge with.
See git-pull(1) for details.

    git pull <remote> <branch>

If you wish to set tracking information for this branch you can do so with:

    git branch --set-upstream-to=origin/<branch> master

Error: exit status 1
Usage:
  gbm pull [worktree-name] [flags]

Flags:
      --all    Pull all worktrees
  -h, --help   help for pull

Global Flags:
  -c, --config string         specify custom .envrc path
  -d, --debug                 enable debug logging to ./gbm.log
  -w, --worktree-dir string   override worktree directory location

ERROR: Error: exit status 1
```
- [x] add completion support (cobra built-in bash/zsh/fish/powershell)
- [x] add configuration for controlling the icons for git status, repo validations, etc
    - [x] ./.gbm/config.toml
- [x] track all worktrees created with `gbm` in the `list` and `status` commands
- [x]  add `remove` verb
- [x] support `gbm switch -` to go to previous worktree
- [x] sort branches by .envrc first, then worktree createdAt DESC
- [ ] add info verb (see info_prd.md and info_ascii_mockup.md)
- [ ] configuration for copying files into new worktrees (.env, anything not tracked by git)
- [ ] track merge backs... not sure how yet and how to prompt the user.
    - [ ] helper to create a merge worktree
- [ ] add carapace completion
- [x] jira-cli support
- [ ] control branch name JIRA through config file (use current as defaults)
- [ ] add jira me to config.toml
- [ ] replace confirmation with bubbltea confirmation (lipgloss?)
- [ ] combine list and status. they do the same thing.
    - [ ] use `list` and remove `status`
    - [ ] columns should be WORKTREE | BRANCH | GIT STATUS | SYNC STATUS | PATH (if not enough room in terminal, omit PATH)
- [ ] add `theme` verb with default themes
- [ ] support `JIRA_CONFIG_FILE` env var ( see https://github.com/ankitpokhrel/jira-cli?tab=readme-ov-file#multiple-projects)
- [ ] add https://github.com/swisscom/bitbucket-cli integration for PRs
- [ ] make output adaptive layout.
</file>

<file path="cmd/status.go">
package cmd

import (
	"fmt"
	"os"
	"slices"

	"gbm/internal"

	"github.com/spf13/cobra"
)

var statusCmd = &cobra.Command{
	Use:   "status",
	Short: "Show current sync status between .envrc and actual worktrees",
	Long: `Show current sync status between .envrc and actual worktrees.

Displays which branches are out of sync, lists missing worktrees, and shows orphaned worktrees.`,
	RunE: func(cmd *cobra.Command, args []string) error {
		wd, err := os.Getwd()
		if err != nil {
			return fmt.Errorf("failed to get working directory: %w", err)
		}

		repoRoot, err := internal.FindGitRoot(wd)
		if err != nil {
			return fmt.Errorf("failed to find git repository root: %w", err)
		}
		PrintVerbose("Checking status from repository root: %s", repoRoot)

		manager, err := internal.NewManager(repoRoot)
		if err != nil {
			return err
		}

		PrintVerbose("Loading .envrc configuration from: %s", GetConfigPath())
		if err := manager.LoadEnvMapping(GetConfigPath()); err != nil {
			return fmt.Errorf("failed to load .envrc: %w", err)
		}

		PrintVerbose("Retrieving sync status from manager")
		status, err := manager.GetSyncStatus()
		if err != nil {
			return err
		}

		PrintVerbose("Fetching worktree list for status display")
		// Get all worktrees (including those created with gbm add)
		worktrees, err := manager.GetAllWorktrees()
		if err != nil {
			return fmt.Errorf("failed to get worktree list: %w", err)
		}

		PrintVerbose("Building status table with %d worktrees", len(worktrees))
		table := internal.NewTable([]string{"WORKTREE", "BRANCH", "GIT STATUS", "SYNC STATUS"})

		// Get sorted worktree names (.envrc first, then ad hoc by creation time desc)
		sortedNames := manager.GetSortedWorktreeNames(worktrees)

		// Add rows for each worktree
		for _, worktreeName := range sortedNames {
			info := worktrees[worktreeName]
			var syncStatus string

			// Check for missing worktrees
			if slices.Contains(status.MissingWorktrees, worktreeName) {
				syncStatus = "MISSING"
			}

			// Check for branch changes
			if change, exists := status.BranchChanges[worktreeName]; exists {
				syncStatus = fmt.Sprintf("OUT_OF_SYNC (%s → %s)", change.OldBranch, change.NewBranch)
			}

			// Check for orphaned worktrees
			if slices.Contains(status.OrphanedWorktrees, worktreeName) {
				syncStatus = "UNTRACKED"
			}

			// Check if this is an untracked worktree (not in .envrc)
			if syncStatus == "" {
				envMapping, err := manager.GetEnvMapping()
				if err == nil {
					if _, exists := envMapping[worktreeName]; !exists {
						syncStatus = internal.FormatInfo("UNTRACKED")
					} else {
						syncStatus = internal.FormatSuccess("IN_SYNC")
					}
				} else {
					syncStatus = internal.FormatSuccess("IN_SYNC")
				}
			}

			// Get git status icon
			gitStatusIcon := internal.FormatGitStatus(info.GitStatus)

			branchDisplay := info.CurrentBranch
			if info.ExpectedBranch != "" && info.ExpectedBranch != info.CurrentBranch {
				branchDisplay = fmt.Sprintf("%s (expected: %s)", info.CurrentBranch, info.ExpectedBranch)
			}

			table.AddRow([]string{worktreeName, branchDisplay, gitStatusIcon, syncStatus})
		}

		table.Print()

		if !status.InSync {
			fmt.Println()
			PrintInfo("%s", internal.FormatInfo("Run 'gbm sync' to synchronize changes"))
		}
		return nil
	},
}

func init() {
	rootCmd.AddCommand(statusCmd)
}
</file>

<file path="internal/manager.go">
package internal

import (
	"errors"
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"time"
)

type Manager struct {
	config     *Config
	gitManager *GitManager
	envMapping *EnvMapping
	repoPath   string
	gbmDir     string
}

type WorktreeListInfo struct {
	Path           string
	ExpectedBranch string
	CurrentBranch  string
	GitStatus      *GitStatus
}

type SyncStatus struct {
	InSync            bool
	MissingWorktrees  []string
	OrphanedWorktrees []string
	BranchChanges     map[string]BranchChange
}

type BranchChange struct {
	OldBranch string
	NewBranch string
}

func NewManager(repoPath string) (*Manager, error) {
	gitManager, err := NewGitManager(repoPath)
	if err != nil {
		return nil, err
	}

	gbmDir := filepath.Join(repoPath, ".gbm")
	config, err := LoadConfig(gbmDir)
	if err != nil {
		return nil, fmt.Errorf("failed to load config: %w", err)
	}

	// Initialize the global icon manager with the loaded config
	iconManager := NewIconManager(config)
	SetGlobalIconManager(iconManager)

	return &Manager{
		config:     config,
		gitManager: gitManager,
		repoPath:   repoPath,
		gbmDir:     gbmDir,
	}, nil
}

func (m *Manager) LoadEnvMapping(envrcPath string) error {
	if envrcPath == "" {
		envrcPath = filepath.Join(m.repoPath, ".envrc")
	}

	if !filepath.IsAbs(envrcPath) {
		envrcPath = filepath.Join(m.repoPath, envrcPath)
	}

	mapping, err := ParseEnvrc(envrcPath)
	if err != nil {
		return err
	}

	m.envMapping = mapping
	return nil
}

func (m *Manager) Initialize(force, fetch bool) error {
	if !m.gitManager.IsGitRepository() {
		return fmt.Errorf("not a git repository")
	}

	if m.envMapping == nil {
		return fmt.Errorf("no .envrc mapping loaded")
	}

	if fetch {
		if err := m.gitManager.FetchAll(); err != nil {
			return fmt.Errorf("failed to fetch: %w", err)
		}
	}

	worktreeDir := filepath.Join(m.repoPath, m.config.Settings.WorktreePrefix)
	if !force {
		if _, err := os.Stat(worktreeDir); !os.IsNotExist(err) {
			return fmt.Errorf("worktree directory already exists, use --force to override")
		}
	}

	for envVar, branchName := range m.envMapping.Variables {
		err := m.gitManager.CreateWorktree(envVar, branchName, m.config.Settings.WorktreePrefix)
		if err != nil {
			if errors.Is(err, ErrWorktreeDirectoryExists) {
				continue // Skip if worktree already exists
			}
			return fmt.Errorf("failed to create worktree for %s: %w", envVar, err)
		}
	}

	var trackedVars []string
	for envVar := range m.envMapping.Variables {
		trackedVars = append(trackedVars, envVar)
	}
	m.config.State.TrackedVars = trackedVars
	m.config.State.LastSync = time.Now()

	return m.config.Save(m.gbmDir)
}

func (m *Manager) GetSyncStatus() (*SyncStatus, error) {
	if m.envMapping == nil {
		return nil, fmt.Errorf("no .envrc mapping loaded")
	}

	status := &SyncStatus{
		InSync:            true,
		MissingWorktrees:  []string{},
		OrphanedWorktrees: []string{},
		BranchChanges:     make(map[string]BranchChange),
	}

	worktrees, err := m.gitManager.GetWorktrees()
	if err != nil {
		return nil, fmt.Errorf("failed to get worktrees: %w", err)
	}

	worktreeMap := make(map[string]*WorktreeInfo)
	for _, wt := range worktrees {
		if strings.HasPrefix(wt.Path, filepath.Join(m.repoPath, m.config.Settings.WorktreePrefix)) {
			worktreeMap[wt.Name] = wt
		}
	}

	for envVar, expectedBranch := range m.envMapping.Variables {
		if wt, exists := worktreeMap[envVar]; exists {
			if wt.Branch != expectedBranch {
				status.BranchChanges[envVar] = BranchChange{
					OldBranch: wt.Branch,
					NewBranch: expectedBranch,
				}
				status.InSync = false
			}
			delete(worktreeMap, envVar)
		} else {
			status.MissingWorktrees = append(status.MissingWorktrees, envVar)
			status.InSync = false
		}
	}

	for envVar := range worktreeMap {
		status.OrphanedWorktrees = append(status.OrphanedWorktrees, envVar)
		status.InSync = false
	}

	return status, nil
}

func (m *Manager) Sync(dryRun, force, fetch bool) error {
	if m.envMapping == nil {
		return fmt.Errorf("no .envrc mapping loaded")
	}

	if fetch {
		if err := m.gitManager.FetchAll(); err != nil {
			return fmt.Errorf("failed to fetch: %w", err)
		}
	}

	status, err := m.GetSyncStatus()
	if err != nil {
		return err
	}

	if status.InSync {
		return nil
	}

	if dryRun {
		return nil
	}

	for _, envVar := range status.MissingWorktrees {
		branchName := m.envMapping.Variables[envVar]
		err := m.gitManager.CreateWorktree(envVar, branchName, m.config.Settings.WorktreePrefix)
		if err != nil {
			return fmt.Errorf("failed to create worktree for %s: %w", envVar, err)
		}
	}

	for envVar, change := range status.BranchChanges {
		worktreePath := filepath.Join(m.repoPath, m.config.Settings.WorktreePrefix, envVar)
		err := m.gitManager.UpdateWorktree(worktreePath, change.NewBranch)
		if err != nil {
			return fmt.Errorf("failed to update worktree for %s: %w", envVar, err)
		}
	}

	if force {
		for _, envVar := range status.OrphanedWorktrees {
			worktreePath := filepath.Join(m.repoPath, m.config.Settings.WorktreePrefix, envVar)
			err := m.gitManager.RemoveWorktree(worktreePath)
			if err != nil {
				return fmt.Errorf("failed to remove orphaned worktree %s: %w", envVar, err)
			}
		}
	}

	var trackedVars []string
	for envVar := range m.envMapping.Variables {
		trackedVars = append(trackedVars, envVar)
	}
	m.config.State.TrackedVars = trackedVars
	m.config.State.LastSync = time.Now()

	return m.config.Save(m.gbmDir)
}

func (m *Manager) ValidateEnvrc() error {
	if m.envMapping == nil {
		return fmt.Errorf("no .envrc mapping loaded")
	}

	for envVar, branchName := range m.envMapping.Variables {
		exists, err := m.gitManager.BranchExists(branchName)
		if err != nil {
			return fmt.Errorf("failed to check branch %s for %s: %w", branchName, envVar, err)
		}
		if !exists {
			return fmt.Errorf("branch '%s' for environment variable '%s' does not exist", branchName, envVar)
		}
	}

	return nil
}

func (m *Manager) CleanOrphaned(force bool) error {
	status, err := m.GetSyncStatus()
	if err != nil {
		return err
	}

	for _, envVar := range status.OrphanedWorktrees {
		worktreePath := filepath.Join(m.repoPath, m.config.Settings.WorktreePrefix, envVar)

		if !force {
			fmt.Printf("Remove orphaned worktree %s? [y/N]: ", envVar)
			var response string
			fmt.Scanln(&response)
			if strings.ToLower(response) != "y" && strings.ToLower(response) != "yes" {
				continue
			}
		}

		err := m.gitManager.RemoveWorktree(worktreePath)
		if err != nil {
			return fmt.Errorf("failed to remove orphaned worktree %s: %w", envVar, err)
		}
	}

	return nil
}

func (m *Manager) GetEnvMapping() (map[string]string, error) {
	if m.envMapping == nil {
		return nil, fmt.Errorf("no .envrc mapping loaded")
	}
	return m.envMapping.Variables, nil
}

func (m *Manager) BranchExists(branchName string) (bool, error) {
	return m.gitManager.BranchExists(branchName)
}

func (m *Manager) GetWorktreeList() (map[string]*WorktreeListInfo, error) {
	if m.envMapping == nil {
		return nil, fmt.Errorf("no .envrc mapping loaded")
	}

	result := make(map[string]*WorktreeListInfo)

	for envVar, expectedBranch := range m.envMapping.Variables {
		worktreePath := filepath.Join(m.repoPath, m.config.Settings.WorktreePrefix, envVar)

		info := &WorktreeListInfo{
			Path:           worktreePath,
			ExpectedBranch: expectedBranch,
			CurrentBranch:  "",
		}

		if _, err := os.Stat(worktreePath); err == nil {
			worktrees, err := m.gitManager.GetWorktrees()
			if err == nil {
				for _, wt := range worktrees {
					if wt.Path == worktreePath {
						info.CurrentBranch = wt.Branch
						break
					}
				}
			}

			// Get git status for the worktree
			if gitStatus, err := m.gitManager.GetWorktreeStatus(worktreePath); err == nil {
				info.GitStatus = gitStatus
			}
		}

		result[envVar] = info
	}

	return result, nil
}

func (m *Manager) GetStatusIcon(gitStatus *GitStatus) string {
	return m.gitManager.GetStatusIcon(gitStatus)
}

func (m *Manager) GetWorktreePath(worktreeName string) (string, error) {
	worktreePath := filepath.Join(m.repoPath, m.config.Settings.WorktreePrefix, worktreeName)

	if _, err := os.Stat(worktreePath); os.IsNotExist(err) {
		return "", fmt.Errorf("worktree directory '%s' does not exist", worktreeName)
	}

	return worktreePath, nil
}

func (m *Manager) GetAllWorktrees() (map[string]*WorktreeListInfo, error) {
	result := make(map[string]*WorktreeListInfo)

	// Get all actual worktrees from git
	worktrees, err := m.gitManager.GetWorktrees()
	if err != nil {
		return nil, fmt.Errorf("failed to get worktrees: %w", err)
	}

	worktreePrefix := filepath.Join(m.repoPath, m.config.Settings.WorktreePrefix)

	for _, wt := range worktrees {
		if strings.HasPrefix(wt.Path, worktreePrefix) {
			// Extract worktree name from path
			worktreeName := filepath.Base(wt.Path)

			info := &WorktreeListInfo{
				Path:          wt.Path,
				CurrentBranch: wt.Branch,
			}

			// Set expected branch if it's tracked in .envrc
			if m.envMapping != nil {
				if expectedBranch, exists := m.envMapping.Variables[worktreeName]; exists {
					info.ExpectedBranch = expectedBranch
				} else {
					info.ExpectedBranch = wt.Branch // Use current branch as expected for ad hoc worktrees
				}
			} else {
				info.ExpectedBranch = wt.Branch
			}

			// Get git status for the worktree
			if gitStatus, err := m.gitManager.GetWorktreeStatus(wt.Path); err == nil {
				info.GitStatus = gitStatus
			}

			result[worktreeName] = info
		}
	}

	return result, nil
}

func (m *Manager) AddWorktree(worktreeName, branchName string, createBranch bool) error {
	err := m.gitManager.AddWorktree(worktreeName, branchName, createBranch)
	if err != nil {
		return err
	}

	// Track this worktree as ad hoc if it's not in .envrc
	if m.envMapping != nil {
		if _, exists := m.envMapping.Variables[worktreeName]; !exists {
			// Add to ad hoc worktrees list if not already there
			if !contains(m.config.State.AdHocWorktrees, worktreeName) {
				m.config.State.AdHocWorktrees = append(m.config.State.AdHocWorktrees, worktreeName)
				// Save the updated config
				if saveErr := m.config.Save(m.gbmDir); saveErr != nil {
					// Log warning but don't fail the operation
					fmt.Printf("Warning: failed to save config: %v\n", saveErr)
				}
			}
		}
	}

	return nil
}

// Helper function to check if a slice contains a string
func contains(slice []string, item string) bool {
	for _, s := range slice {
		if s == item {
			return true
		}
	}
	return false
}

func (m *Manager) GetRemoteBranches() ([]string, error) {
	return m.gitManager.GetRemoteBranches()
}

func (m *Manager) GetCurrentBranch() (string, error) {
	return m.gitManager.GetCurrentBranch()
}

func (m *Manager) PushWorktree(worktreeName string) error {
	worktreePath := filepath.Join(m.repoPath, m.config.Settings.WorktreePrefix, worktreeName)
	return m.gitManager.PushWorktree(worktreePath)
}

func (m *Manager) PullWorktree(worktreeName string) error {
	worktreePath := filepath.Join(m.repoPath, m.config.Settings.WorktreePrefix, worktreeName)
	return m.gitManager.PullWorktree(worktreePath)
}

func (m *Manager) IsInWorktree(currentPath string) (bool, string, error) {
	return m.gitManager.IsInWorktree(currentPath)
}

func (m *Manager) PushAllWorktrees() error {
	worktrees, err := m.GetAllWorktrees()
	if err != nil {
		return fmt.Errorf("failed to get worktrees: %w", err)
	}

	for name, info := range worktrees {
		fmt.Printf("Pushing worktree '%s'...\n", name)
		if err := m.gitManager.PushWorktree(info.Path); err != nil {
			fmt.Printf("Failed to push worktree '%s': %v\n", name, err)
			continue
		}
		fmt.Printf("Successfully pushed worktree '%s'\n", name)
	}

	return nil
}

func (m *Manager) PullAllWorktrees() error {
	worktrees, err := m.GetAllWorktrees()
	if err != nil {
		return fmt.Errorf("failed to get worktrees: %w", err)
	}

	for name, info := range worktrees {
		fmt.Printf("Pulling worktree '%s'...\n", name)
		if err := m.gitManager.PullWorktree(info.Path); err != nil {
			fmt.Printf("Failed to pull worktree '%s': %v\n", name, err)
			continue
		}
		fmt.Printf("Successfully pulled worktree '%s'\n", name)
	}

	return nil
}

func (m *Manager) RemoveWorktree(worktreeName string) error {
	worktreePath := filepath.Join(m.repoPath, m.config.Settings.WorktreePrefix, worktreeName)

	// Remove the worktree using git
	if err := m.gitManager.RemoveWorktree(worktreePath); err != nil {
		return fmt.Errorf("failed to remove worktree: %w", err)
	}

	// Remove from ad hoc worktrees list if it exists there
	for i, name := range m.config.State.AdHocWorktrees {
		if name == worktreeName {
			m.config.State.AdHocWorktrees = append(m.config.State.AdHocWorktrees[:i], m.config.State.AdHocWorktrees[i+1:]...)
			break
		}
	}

	// Save the updated config
	if err := m.config.Save(m.gbmDir); err != nil {
		// Log warning but don't fail the operation
		fmt.Printf("Warning: failed to save config: %v\n", err)
	}

	return nil
}

func (m *Manager) GetWorktreeStatus(worktreePath string) (*GitStatus, error) {
	return m.gitManager.GetWorktreeStatus(worktreePath)
}

func (m *Manager) SetCurrentWorktree(worktreeName string) error {
	// Update previous worktree before changing current
	if m.config.State.CurrentWorktree != "" && m.config.State.CurrentWorktree != worktreeName {
		m.config.State.PreviousWorktree = m.config.State.CurrentWorktree
	}
	m.config.State.CurrentWorktree = worktreeName
	return m.config.Save(m.gbmDir)
}

func (m *Manager) GetPreviousWorktree() string {
	return m.config.State.PreviousWorktree
}

func (m *Manager) GetCurrentWorktree() string {
	return m.config.State.CurrentWorktree
}

func (m *Manager) GetSortedWorktreeNames(worktrees map[string]*WorktreeListInfo) []string {
	var envrcNames []string
	var adHocNames []string

	// Get .envrc mapping if available
	envMapping := make(map[string]string)
	if m.envMapping != nil {
		envMapping = m.envMapping.Variables
	}

	// Separate worktrees into .envrc tracked and ad hoc
	for name := range worktrees {
		if _, exists := envMapping[name]; exists {
			envrcNames = append(envrcNames, name)
		} else {
			adHocNames = append(adHocNames, name)
		}
	}

	// Sort .envrc names alphabetically
	sort.Strings(envrcNames)

	// Sort ad hoc names by creation time (directory modification time) descending
	sort.Slice(adHocNames, func(i, j int) bool {
		pathI := worktrees[adHocNames[i]].Path
		pathJ := worktrees[adHocNames[j]].Path

		statI, errI := os.Stat(pathI)
		statJ, errJ := os.Stat(pathJ)

		// If we can't get stats, fall back to alphabetical
		if errI != nil || errJ != nil {
			return adHocNames[i] < adHocNames[j]
		}

		// Sort by modification time descending (newer first)
		return statI.ModTime().After(statJ.ModTime())
	})

	// Return .envrc worktrees first, then ad hoc worktrees
	result := make([]string, 0, len(envrcNames)+len(adHocNames))
	result = append(result, envrcNames...)
	result = append(result, adHocNames...)

	return result
}
</file>

<file path="internal/git.go">
package internal

import (
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"time"

	"github.com/go-git/go-git/v5"
	"github.com/go-git/go-git/v5/plumbing"
	"github.com/go-git/go-git/v5/plumbing/storer"
)

type GitManager struct {
	repo     *git.Repository
	repoPath string
}

type WorktreeInfo struct {
	Name       string
	Path       string
	Branch     string
	IsOrphaned bool
	NeedsSync  bool
	GitStatus  *GitStatus
}

type GitStatus struct {
	IsDirty   bool
	Ahead     int
	Behind    int
	Untracked int
	Modified  int
	Staged    int
}

func (gs *GitStatus) HasChanges() bool {
	return gs.IsDirty || gs.Untracked > 0 || gs.Modified > 0 || gs.Staged > 0
}

// execCommand executes a command with debug output
func execCommand(cmd *exec.Cmd) ([]byte, error) {
	output, err := cmd.Output()
	return output, err
}

// execCommandRun executes a command using Run() instead of Output() with debug output
func execCommandRun(cmd *exec.Cmd) error {
	err := cmd.Run()
	return err
}

// FindGitRoot finds the root directory of the git repository
func FindGitRoot(startPath string) (string, error) {
	// First, try direct git commands from the current directory
	cmd := exec.Command("git", "rev-parse", "--git-dir")
	cmd.Dir = startPath
	gitDirOutput, err := cmd.Output()
	if err == nil {
		gitDir := strings.TrimSpace(string(gitDirOutput))

		// If .git-dir contains "worktrees", we're in a worktree
		if strings.Contains(gitDir, "worktrees") {
			// Extract the main repository path from the worktree git dir
			// Format: /path/to/main/repo/.git/worktrees/worktree-name
			parts := strings.Split(gitDir, "/.git/worktrees/")
			if len(parts) >= 2 {
				return parts[0], nil
			}
		}

		// Check if this is a bare repository
		cmd = exec.Command("git", "rev-parse", "--is-bare-repository")
		cmd.Dir = startPath
		output, err := cmd.Output()
		if err == nil && strings.TrimSpace(string(output)) == "true" {
			// For bare repositories, the git directory is the repository root
			if filepath.IsAbs(gitDir) {
				return filepath.Dir(gitDir), nil
			} else {
				// gitDir is relative (e.g., ".git"), so repository root is startPath
				return startPath, nil
			}
		}

		// Standard git root detection if we're in a regular repo
		cmd = exec.Command("git", "rev-parse", "--show-toplevel")
		cmd.Dir = startPath
		output, err = cmd.Output()
		if err == nil {
			return strings.TrimSpace(string(output)), nil
		}

		// If show-toplevel failed, try alternative detection methods
		// Check if we have a .git directory or file
		gitPath := filepath.Join(startPath, ".git")
		if _, err := os.Stat(gitPath); err == nil {
			// We have a .git entry, so this is likely the repository root
			return startPath, nil
		}

		// If gitDir is absolute, we can derive the repository root
		if filepath.IsAbs(gitDir) {
			// Remove .git suffix to get repository root
			if strings.HasSuffix(gitDir, ".git") {
				return strings.TrimSuffix(gitDir, ".git"), nil
			}
			return filepath.Dir(gitDir), nil
		}
	}

	// If we're not in a git repository, check for git repositories in subdirectories
	// This handles the case where we're in a directory that contains worktrees
	// but isn't itself a git repository
	entries, err := os.ReadDir(startPath)
	if err == nil {
		var foundRepos []string

		for _, entry := range entries {
			if entry.IsDir() {
				subPath := filepath.Join(startPath, entry.Name())

				// Check if this subdirectory is a git repository
				cmd := exec.Command("git", "rev-parse", "--git-dir")
				cmd.Dir = subPath
				gitDirOutput, err := cmd.Output()
				if err == nil {
					gitDir := strings.TrimSpace(string(gitDirOutput))

					// If this is a worktree, get the main repository path
					if strings.Contains(gitDir, "worktrees") {
						parts := strings.Split(gitDir, "/.git/worktrees/")
						if len(parts) >= 2 {
							foundRepos = append(foundRepos, parts[0])
						}
					} else {
						// Check if this is a bare repository
						cmd = exec.Command("git", "rev-parse", "--is-bare-repository")
						cmd.Dir = subPath
						output, err := cmd.Output()
						if err == nil && strings.TrimSpace(string(output)) == "true" {
							// For bare repositories, the git directory is the repository root
							if filepath.IsAbs(gitDir) {
								foundRepos = append(foundRepos, filepath.Dir(gitDir))
							} else {
								// gitDir is relative (e.g., ".git"), so repository root is subPath
								foundRepos = append(foundRepos, subPath)
							}
						} else {
							// If this is a regular git repository, return its root
							cmd = exec.Command("git", "rev-parse", "--show-toplevel")
							cmd.Dir = subPath
							output, err := cmd.Output()
							if err == nil {
								foundRepos = append(foundRepos, strings.TrimSpace(string(output)))
							}
						}
					}
				}
			}
		}

		// If we found repositories in subdirectories, use the first one
		if len(foundRepos) > 0 {
			return foundRepos[0], nil
		}
	}

	return "", fmt.Errorf("not in a git repository and no git repositories found in subdirectories")
}

func NewGitManager(repoPath string) (*GitManager, error) {
	repo, err := git.PlainOpen(repoPath)
	if err != nil {
		return nil, fmt.Errorf("not a git repository: %w", err)
	}

	return &GitManager{
		repo:     repo,
		repoPath: repoPath,
	}, nil
}

func (gm *GitManager) IsGitRepository() bool {
	_, err := git.PlainOpen(gm.repoPath)
	return err == nil
}

func (gm *GitManager) BranchExists(branchName string) (bool, error) {
	refs, err := gm.repo.References()
	if err != nil {
		return false, err
	}

	var found bool
	err = refs.ForEach(func(ref *plumbing.Reference) error {
		if ref.Name().IsBranch() {
			if ref.Name().Short() == branchName {
				found = true
				return storer.ErrStop
			}
		}
		return nil
	})

	if err != nil && err != storer.ErrStop {
		return false, err
	}

	return found, nil
}

func (gm *GitManager) GetWorktrees() ([]*WorktreeInfo, error) {
	cmd := exec.Command("git", "worktree", "list", "--porcelain")
	cmd.Dir = gm.repoPath
	output, err := execCommand(cmd)
	if err != nil {
		return nil, fmt.Errorf("failed to get worktrees: %w", err)
	}

	var infos []*WorktreeInfo
	lines := strings.Split(string(output), "\n")

	var currentWorktree *WorktreeInfo
	for _, line := range lines {
		line = strings.TrimSpace(line)
		if line == "" {
			if currentWorktree != nil {
				infos = append(infos, currentWorktree)
				currentWorktree = nil
			}
			continue
		}

		if strings.HasPrefix(line, "worktree ") {
			path := strings.TrimPrefix(line, "worktree ")
			currentWorktree = &WorktreeInfo{
				Name: filepath.Base(path),
				Path: path,
			}
		} else if strings.HasPrefix(line, "branch ") && currentWorktree != nil {
			branch := strings.TrimPrefix(line, "branch ")
			branch = strings.TrimPrefix(branch, "refs/heads/")
			currentWorktree.Branch = branch
		}
	}

	if currentWorktree != nil {
		infos = append(infos, currentWorktree)
	}

	return infos, nil
}

var ErrWorktreeDirectoryExists = fmt.Errorf("worktree directory already exists")

func (gm *GitManager) CreateWorktree(envVar, branchName, worktreeDir string) error {
	worktreePath := filepath.Join(gm.repoPath, worktreeDir, envVar)

	if _, err := os.Stat(worktreePath); !os.IsNotExist(err) {
		return fmt.Errorf("%w: %s", ErrWorktreeDirectoryExists, worktreePath)
	}

	branchExists, err := gm.BranchExists(branchName)
	if err != nil {
		return fmt.Errorf("failed to check if branch exists: %w", err)
	}

	if !branchExists {
		return fmt.Errorf("branch '%s' does not exist", branchName)
	}

	// Check if remote tracking branch exists
	remoteBranch := fmt.Sprintf("origin/%s", branchName)
	cmd := exec.Command("git", "rev-parse", "--verify", remoteBranch)
	cmd.Dir = gm.repoPath
	_, err = execCommand(cmd)

	if err == nil {
		// Remote tracking branch exists, use --track
		cmd = exec.Command("git", "worktree", "add", "--track", "-b", branchName, worktreePath, remoteBranch)
	} else {
		cmd = exec.Command("git", "worktree", "add", worktreePath, branchName)
	}

	cmd.Dir = gm.repoPath
	if err := execCommandRun(cmd); err != nil {
		return fmt.Errorf("failed to create worktree: %w", err)
	}

	return nil
}

func (gm *GitManager) RemoveWorktree(worktreePath string) error {
	cmd := exec.Command("git", "worktree", "remove", worktreePath, "--force")
	cmd.Dir = gm.repoPath
	if err := execCommandRun(cmd); err != nil {
		return fmt.Errorf("failed to remove worktree: %w", err)
	}

	return nil
}

func (gm *GitManager) UpdateWorktree(worktreePath, newBranch string) error {
	if err := gm.RemoveWorktree(worktreePath); err != nil {
		return fmt.Errorf("failed to remove old worktree: %w", err)
	}

	worktreeDir := filepath.Dir(worktreePath)
	envVar := filepath.Base(worktreePath)
	relativeWorktreeDir := strings.TrimPrefix(worktreeDir, gm.repoPath+string(filepath.Separator))

	return gm.CreateWorktree(envVar, newBranch, relativeWorktreeDir)
}

func (gm *GitManager) FetchAll() error {
	remote, err := gm.repo.Remote("origin")
	if err != nil {
		return fmt.Errorf("failed to get origin remote: %w", err)
	}

	err = remote.Fetch(&git.FetchOptions{})
	if err != nil && err != git.NoErrAlreadyUpToDate {
		return fmt.Errorf("failed to fetch from remote: %w", err)
	}

	return nil
}

func (gm *GitManager) GetWorktreeStatus(worktreePath string) (*GitStatus, error) {
	if _, err := os.Stat(worktreePath); os.IsNotExist(err) {
		return nil, fmt.Errorf("worktree path does not exist: %s", worktreePath)
	}

	status := &GitStatus{}

	// Get git status
	cmd := exec.Command("git", "status", "--porcelain", "--ahead-behind")
	cmd.Dir = worktreePath
	output, err := execCommand(cmd)
	if err != nil {
		return nil, fmt.Errorf("failed to get git status: %w", err)
	}

	statusLines := strings.Split(string(output), "\n")
	for _, line := range statusLines {
		line = strings.TrimSpace(line)
		if line == "" {
			continue
		}

		status.IsDirty = true

		// Parse git status output
		if len(line) >= 2 {
			indexStatus := line[0]
			worktreeStatus := line[1]

			switch indexStatus {
			case 'A', 'M', 'D', 'R', 'C':
				status.Staged++
			}

			switch worktreeStatus {
			case 'M', 'D':
				status.Modified++
			}

			if indexStatus == '?' && worktreeStatus == '?' {
				status.Untracked++
			}
		}
	}

	// Get ahead/behind info
	cmd = exec.Command("git", "rev-list", "--left-right", "--count", "HEAD...@{upstream}")
	cmd.Dir = worktreePath
	output, err = execCommand(cmd)
	if err == nil {
		parts := strings.Fields(string(output))
		if len(parts) == 2 {
			if _, err := fmt.Sscanf(parts[0], "%d", &status.Ahead); err == nil {
				fmt.Sscanf(parts[1], "%d", &status.Behind)
			}
		}
	}

	return status, nil
}

func (gm *GitManager) GetStatusIcon(gitStatus *GitStatus) string {
	iconManager := GetGlobalIconManager()

	if gitStatus == nil {
		return iconManager.Error()
	}

	var icons []string

	// Check ahead/behind first
	if gitStatus.Ahead > 0 && gitStatus.Behind > 0 {
		icons = append(icons, iconManager.GitDiverged())
	} else if gitStatus.Ahead > 0 {
		icons = append(icons, iconManager.GitAhead())
	} else if gitStatus.Behind > 0 {
		icons = append(icons, iconManager.GitBehind())
	}

	// Check dirty status
	if gitStatus.IsDirty {
		if gitStatus.Staged > 0 {
			icons = append(icons, "●")
		}
		if gitStatus.Modified > 0 {
			icons = append(icons, "✚")
		}
		if gitStatus.Untracked > 0 {
			icons = append(icons, "?")
		}
	}

	if len(icons) == 0 {
		return iconManager.Success()
	}

	return strings.Join(icons, "")
}

func (gm *GitManager) CreateBranch(branchName, baseBranch string) error {
	if baseBranch == "" {
		baseBranch = "HEAD"
	}

	cmd := exec.Command("git", "branch", branchName, baseBranch)
	cmd.Dir = gm.repoPath
	if err := execCommandRun(cmd); err != nil {
		return fmt.Errorf("failed to create branch: %w", err)
	}

	return nil
}

func (gm *GitManager) AddWorktree(worktreeName, branchName string, createBranch bool) error {
	worktreeDir := filepath.Join(gm.repoPath, "worktrees")
	worktreePath := filepath.Join(worktreeDir, worktreeName)

	// Check if worktree already exists
	if _, err := os.Stat(worktreePath); !os.IsNotExist(err) {
		return fmt.Errorf("worktree '%s' already exists", worktreeName)
	}

	// Create worktrees directory if it doesn't exist
	if err := os.MkdirAll(worktreeDir, 0755); err != nil {
		return fmt.Errorf("failed to create worktrees directory: %w", err)
	}

	var cmd *exec.Cmd
	if createBranch {
		// Check if branch already exists
		branchExists, err := gm.BranchExists(branchName)
		if err != nil {
			return fmt.Errorf("failed to check if branch exists: %w", err)
		}

		if branchExists {
			// Branch exists, create worktree on existing branch
			cmd = exec.Command("git", "worktree", "add", worktreePath, branchName)
		} else {
			// Create new branch and worktree
			cmd = exec.Command("git", "worktree", "add", "-b", branchName, worktreePath)
		}
	} else {
		// Create worktree on existing branch
		branchExists, err := gm.BranchExists(branchName)
		if err != nil {
			return fmt.Errorf("failed to check if branch exists: %w", err)
		}

		if !branchExists {
			return fmt.Errorf("branch '%s' does not exist", branchName)
		}

		// Check if remote tracking branch exists
		remoteBranch := fmt.Sprintf("origin/%s", branchName)
		checkCmd := exec.Command("git", "rev-parse", "--verify", remoteBranch)
		checkCmd.Dir = gm.repoPath
		_, err = execCommand(checkCmd)

		if err == nil {
			// Remote tracking branch exists, use --track
			cmd = exec.Command("git", "worktree", "add", "--track", "-b", branchName, worktreePath, remoteBranch)
		} else {
			// No remote tracking branch, create worktree without tracking
			cmd = exec.Command("git", "worktree", "add", worktreePath, branchName)
		}
	}

	cmd.Dir = gm.repoPath
	if err := execCommandRun(cmd); err != nil {
		return fmt.Errorf("failed to add worktree (command: %s): %w", strings.Join(cmd.Args, " "), err)
	}

	return nil
}

func (gm *GitManager) GetCurrentBranch() (string, error) {
	cmd := exec.Command("git", "rev-parse", "--abbrev-ref", "HEAD")
	cmd.Dir = gm.repoPath
	output, err := execCommand(cmd)
	if err != nil {
		return "", fmt.Errorf("failed to get current branch: %w", err)
	}

	return strings.TrimSpace(string(output)), nil
}

func (gm *GitManager) GetRemoteBranches() ([]string, error) {
	cmd := exec.Command("git", "branch", "-r")
	cmd.Dir = gm.repoPath
	output, err := execCommand(cmd)
	if err != nil {
		return nil, fmt.Errorf("failed to get remote branches: %w", err)
	}

	var branches []string
	lines := strings.Split(string(output), "\n")
	for _, line := range lines {
		line = strings.TrimSpace(line)
		if line == "" || strings.Contains(line, "HEAD") {
			continue
		}

		// Remove "origin/" prefix
		if strings.HasPrefix(line, "origin/") {
			branch := strings.TrimPrefix(line, "origin/")
			branches = append(branches, branch)
		}
	}

	return branches, nil
}

func (gm *GitManager) PushWorktree(worktreePath string) error {
	if _, err := os.Stat(worktreePath); os.IsNotExist(err) {
		return fmt.Errorf("worktree path does not exist: %s", worktreePath)
	}

	// Get the current branch
	cmd := exec.Command("git", "rev-parse", "--abbrev-ref", "HEAD")
	cmd.Dir = worktreePath
	output, err := execCommand(cmd)
	if err != nil {
		return fmt.Errorf("failed to get current branch: %w", err)
	}

	currentBranch := strings.TrimSpace(string(output))

	// Check if upstream is set
	cmd = exec.Command("git", "rev-parse", "--abbrev-ref", "@{upstream}")
	cmd.Dir = worktreePath
	_, err = execCommand(cmd)

	if err != nil {
		// No upstream set, push with -u flag
		cmd = exec.Command("git", "push", "-u", "origin", currentBranch)
	} else {
		// Upstream is set, simple push
		cmd = exec.Command("git", "push")
	}

	cmd.Dir = worktreePath
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr

	return cmd.Run()
}

func (gm *GitManager) PullWorktree(worktreePath string) error {
	if _, err := os.Stat(worktreePath); os.IsNotExist(err) {
		return fmt.Errorf("worktree path does not exist: %s", worktreePath)
	}

	// Get the current branch
	cmd := exec.Command("git", "rev-parse", "--abbrev-ref", "HEAD")
	cmd.Dir = worktreePath
	output, err := execCommand(cmd)
	if err != nil {
		return fmt.Errorf("failed to get current branch: %w", err)
	}

	currentBranch := strings.TrimSpace(string(output))

	// Check if upstream is set
	cmd = exec.Command("git", "rev-parse", "--abbrev-ref", "@{upstream}")
	cmd.Dir = worktreePath
	_, err = execCommand(cmd)

	if err != nil {
		// No upstream set, try to set it and pull
		remoteBranch := fmt.Sprintf("origin/%s", currentBranch)

		// Check if remote branch exists
		cmd = exec.Command("git", "rev-parse", "--verify", remoteBranch)
		cmd.Dir = worktreePath
		_, err = execCommand(cmd)

		if err == nil {
			// Remote branch exists, set upstream and pull
			cmd = exec.Command("git", "branch", "--set-upstream-to", remoteBranch)
			cmd.Dir = worktreePath
			if err := execCommandRun(cmd); err != nil {
				return fmt.Errorf("failed to set upstream: %w", err)
			}

			// Now pull
			cmd = exec.Command("git", "pull")
		} else {
			// Remote branch doesn't exist, try to pull with explicit remote and branch
			cmd = exec.Command("git", "pull", "origin", currentBranch)
		}
	} else {
		// Upstream is set, simple pull
		cmd = exec.Command("git", "pull")
	}

	cmd.Dir = worktreePath
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr

	return cmd.Run()
}

func (gm *GitManager) IsInWorktree(currentPath string) (bool, string, error) {
	// Check if we're in a worktree
	cmd := exec.Command("git", "rev-parse", "--show-toplevel")
	cmd.Dir = currentPath
	output, err := execCommand(cmd)
	if err != nil {
		return false, "", fmt.Errorf("not in a git repository: %w", err)
	}

	worktreePath := strings.TrimSpace(string(output))

	// Check if this is a worktree by checking if it's under the worktrees directory
	worktreePrefix := filepath.Join(gm.repoPath, "worktrees")
	if strings.HasPrefix(worktreePath, worktreePrefix) {
		worktreeName := filepath.Base(worktreePath)
		return true, worktreeName, nil
	}

	return false, "", nil
}

// WorktreeInfoData represents comprehensive information about a worktree
type WorktreeInfoData struct {
	Name          string
	Path          string
	Branch        string
	CreatedAt     time.Time
	GitStatus     *GitStatus
	BaseInfo      *BranchInfo
	Commits       []CommitInfo
	ModifiedFiles []FileChange
	JiraTicket    *JiraTicketDetails
}

// BranchInfo represents information about the base branch
type BranchInfo struct {
	Name       string
	DivergedAt string
	DaysAgo    int
	Upstream   string
	AheadBy    int
	BehindBy   int
}

// CommitInfo represents information about a commit
type CommitInfo struct {
	Hash      string
	Message   string
	Author    string
	Timestamp time.Time
}

// FileChange represents a modified file
type FileChange struct {
	Path      string
	Status    string
	Additions int
	Deletions int
}

// JiraTicketDetails represents detailed JIRA ticket information
type JiraTicketDetails struct {
	Key           string
	Summary       string
	Status        string
	Assignee      string
	Priority      string
	Reporter      string
	Created       time.Time
	DueDate       *time.Time
	Epic          string
	URL           string
	LatestComment *Comment
}

// Comment represents a JIRA comment
type Comment struct {
	Author    string
	Content   string
	Timestamp time.Time
}
</file>

</files>
