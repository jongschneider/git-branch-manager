// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package cmd

import (
	"gbm/internal"
	"sync"
)

// Ensure, that worktreePusherMock does implement worktreePusher.
// If this is not the case, regenerate this file with moq.
var _ worktreePusher = &worktreePusherMock{}

// worktreePusherMock is a mock implementation of worktreePusher.
//
//	func TestSomethingThatUsesworktreePusher(t *testing.T) {
//
//		// make and configure a mocked worktreePusher
//		mockedworktreePusher := &worktreePusherMock{
//			GetAllWorktreesFunc: func() (map[string]*internal.WorktreeListInfo, error) {
//				panic("mock out the GetAllWorktrees method")
//			},
//			IsInWorktreeFunc: func(currentPath string) (bool, string, error) {
//				panic("mock out the IsInWorktree method")
//			},
//			PushAllWorktreesFunc: func() error {
//				panic("mock out the PushAllWorktrees method")
//			},
//			PushWorktreeFunc: func(worktreeName string) error {
//				panic("mock out the PushWorktree method")
//			},
//		}
//
//		// use mockedworktreePusher in code that requires worktreePusher
//		// and then make assertions.
//
//	}
type worktreePusherMock struct {
	// GetAllWorktreesFunc mocks the GetAllWorktrees method.
	GetAllWorktreesFunc func() (map[string]*internal.WorktreeListInfo, error)

	// IsInWorktreeFunc mocks the IsInWorktree method.
	IsInWorktreeFunc func(currentPath string) (bool, string, error)

	// PushAllWorktreesFunc mocks the PushAllWorktrees method.
	PushAllWorktreesFunc func() error

	// PushWorktreeFunc mocks the PushWorktree method.
	PushWorktreeFunc func(worktreeName string) error

	// calls tracks calls to the methods.
	calls struct {
		// GetAllWorktrees holds details about calls to the GetAllWorktrees method.
		GetAllWorktrees []struct {
		}
		// IsInWorktree holds details about calls to the IsInWorktree method.
		IsInWorktree []struct {
			// CurrentPath is the currentPath argument value.
			CurrentPath string
		}
		// PushAllWorktrees holds details about calls to the PushAllWorktrees method.
		PushAllWorktrees []struct {
		}
		// PushWorktree holds details about calls to the PushWorktree method.
		PushWorktree []struct {
			// WorktreeName is the worktreeName argument value.
			WorktreeName string
		}
	}
	lockGetAllWorktrees  sync.RWMutex
	lockIsInWorktree     sync.RWMutex
	lockPushAllWorktrees sync.RWMutex
	lockPushWorktree     sync.RWMutex
}

// GetAllWorktrees calls GetAllWorktreesFunc.
func (mock *worktreePusherMock) GetAllWorktrees() (map[string]*internal.WorktreeListInfo, error) {
	if mock.GetAllWorktreesFunc == nil {
		panic("worktreePusherMock.GetAllWorktreesFunc: method is nil but worktreePusher.GetAllWorktrees was just called")
	}
	callInfo := struct {
	}{}
	mock.lockGetAllWorktrees.Lock()
	mock.calls.GetAllWorktrees = append(mock.calls.GetAllWorktrees, callInfo)
	mock.lockGetAllWorktrees.Unlock()
	return mock.GetAllWorktreesFunc()
}

// GetAllWorktreesCalls gets all the calls that were made to GetAllWorktrees.
// Check the length with:
//
//	len(mockedworktreePusher.GetAllWorktreesCalls())
func (mock *worktreePusherMock) GetAllWorktreesCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockGetAllWorktrees.RLock()
	calls = mock.calls.GetAllWorktrees
	mock.lockGetAllWorktrees.RUnlock()
	return calls
}

// IsInWorktree calls IsInWorktreeFunc.
func (mock *worktreePusherMock) IsInWorktree(currentPath string) (bool, string, error) {
	if mock.IsInWorktreeFunc == nil {
		panic("worktreePusherMock.IsInWorktreeFunc: method is nil but worktreePusher.IsInWorktree was just called")
	}
	callInfo := struct {
		CurrentPath string
	}{
		CurrentPath: currentPath,
	}
	mock.lockIsInWorktree.Lock()
	mock.calls.IsInWorktree = append(mock.calls.IsInWorktree, callInfo)
	mock.lockIsInWorktree.Unlock()
	return mock.IsInWorktreeFunc(currentPath)
}

// IsInWorktreeCalls gets all the calls that were made to IsInWorktree.
// Check the length with:
//
//	len(mockedworktreePusher.IsInWorktreeCalls())
func (mock *worktreePusherMock) IsInWorktreeCalls() []struct {
	CurrentPath string
} {
	var calls []struct {
		CurrentPath string
	}
	mock.lockIsInWorktree.RLock()
	calls = mock.calls.IsInWorktree
	mock.lockIsInWorktree.RUnlock()
	return calls
}

// PushAllWorktrees calls PushAllWorktreesFunc.
func (mock *worktreePusherMock) PushAllWorktrees() error {
	if mock.PushAllWorktreesFunc == nil {
		panic("worktreePusherMock.PushAllWorktreesFunc: method is nil but worktreePusher.PushAllWorktrees was just called")
	}
	callInfo := struct {
	}{}
	mock.lockPushAllWorktrees.Lock()
	mock.calls.PushAllWorktrees = append(mock.calls.PushAllWorktrees, callInfo)
	mock.lockPushAllWorktrees.Unlock()
	return mock.PushAllWorktreesFunc()
}

// PushAllWorktreesCalls gets all the calls that were made to PushAllWorktrees.
// Check the length with:
//
//	len(mockedworktreePusher.PushAllWorktreesCalls())
func (mock *worktreePusherMock) PushAllWorktreesCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockPushAllWorktrees.RLock()
	calls = mock.calls.PushAllWorktrees
	mock.lockPushAllWorktrees.RUnlock()
	return calls
}

// PushWorktree calls PushWorktreeFunc.
func (mock *worktreePusherMock) PushWorktree(worktreeName string) error {
	if mock.PushWorktreeFunc == nil {
		panic("worktreePusherMock.PushWorktreeFunc: method is nil but worktreePusher.PushWorktree was just called")
	}
	callInfo := struct {
		WorktreeName string
	}{
		WorktreeName: worktreeName,
	}
	mock.lockPushWorktree.Lock()
	mock.calls.PushWorktree = append(mock.calls.PushWorktree, callInfo)
	mock.lockPushWorktree.Unlock()
	return mock.PushWorktreeFunc(worktreeName)
}

// PushWorktreeCalls gets all the calls that were made to PushWorktree.
// Check the length with:
//
//	len(mockedworktreePusher.PushWorktreeCalls())
func (mock *worktreePusherMock) PushWorktreeCalls() []struct {
	WorktreeName string
} {
	var calls []struct {
		WorktreeName string
	}
	mock.lockPushWorktree.RLock()
	calls = mock.calls.PushWorktree
	mock.lockPushWorktree.RUnlock()
	return calls
}
