// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package cmd

import (
	"sync"
)

// Ensure, that worktreeValidatorMock does implement worktreeValidator.
// If this is not the case, regenerate this file with moq.
var _ worktreeValidator = &worktreeValidatorMock{}

// worktreeValidatorMock is a mock implementation of worktreeValidator.
//
//	func TestSomethingThatUsesworktreeValidator(t *testing.T) {
//
//		// make and configure a mocked worktreeValidator
//		mockedworktreeValidator := &worktreeValidatorMock{
//			BranchExistsFunc: func(branch string) (bool, error) {
//				panic("mock out the BranchExists method")
//			},
//			GetWorktreeMappingFunc: func() (map[string]string, error) {
//				panic("mock out the GetWorktreeMapping method")
//			},
//		}
//
//		// use mockedworktreeValidator in code that requires worktreeValidator
//		// and then make assertions.
//
//	}
type worktreeValidatorMock struct {
	// BranchExistsFunc mocks the BranchExists method.
	BranchExistsFunc func(branch string) (bool, error)

	// GetWorktreeMappingFunc mocks the GetWorktreeMapping method.
	GetWorktreeMappingFunc func() (map[string]string, error)

	// calls tracks calls to the methods.
	calls struct {
		// BranchExists holds details about calls to the BranchExists method.
		BranchExists []struct {
			// Branch is the branch argument value.
			Branch string
		}
		// GetWorktreeMapping holds details about calls to the GetWorktreeMapping method.
		GetWorktreeMapping []struct {
		}
	}
	lockBranchExists       sync.RWMutex
	lockGetWorktreeMapping sync.RWMutex
}

// BranchExists calls BranchExistsFunc.
func (mock *worktreeValidatorMock) BranchExists(branch string) (bool, error) {
	if mock.BranchExistsFunc == nil {
		panic("worktreeValidatorMock.BranchExistsFunc: method is nil but worktreeValidator.BranchExists was just called")
	}
	callInfo := struct {
		Branch string
	}{
		Branch: branch,
	}
	mock.lockBranchExists.Lock()
	mock.calls.BranchExists = append(mock.calls.BranchExists, callInfo)
	mock.lockBranchExists.Unlock()
	return mock.BranchExistsFunc(branch)
}

// BranchExistsCalls gets all the calls that were made to BranchExists.
// Check the length with:
//
//	len(mockedworktreeValidator.BranchExistsCalls())
func (mock *worktreeValidatorMock) BranchExistsCalls() []struct {
	Branch string
} {
	var calls []struct {
		Branch string
	}
	mock.lockBranchExists.RLock()
	calls = mock.calls.BranchExists
	mock.lockBranchExists.RUnlock()
	return calls
}

// GetWorktreeMapping calls GetWorktreeMappingFunc.
func (mock *worktreeValidatorMock) GetWorktreeMapping() (map[string]string, error) {
	if mock.GetWorktreeMappingFunc == nil {
		panic("worktreeValidatorMock.GetWorktreeMappingFunc: method is nil but worktreeValidator.GetWorktreeMapping was just called")
	}
	callInfo := struct {
	}{}
	mock.lockGetWorktreeMapping.Lock()
	mock.calls.GetWorktreeMapping = append(mock.calls.GetWorktreeMapping, callInfo)
	mock.lockGetWorktreeMapping.Unlock()
	return mock.GetWorktreeMappingFunc()
}

// GetWorktreeMappingCalls gets all the calls that were made to GetWorktreeMapping.
// Check the length with:
//
//	len(mockedworktreeValidator.GetWorktreeMappingCalls())
func (mock *worktreeValidatorMock) GetWorktreeMappingCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockGetWorktreeMapping.RLock()
	calls = mock.calls.GetWorktreeMapping
	mock.lockGetWorktreeMapping.RUnlock()
	return calls
}
