// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package cmd

import (
	"gbm/internal"
	"sync"
)

// Ensure, that worktreeAdderMock does implement worktreeAdder.
// If this is not the case, regenerate this file with moq.
var _ worktreeAdder = &worktreeAdderMock{}

// worktreeAdderMock is a mock implementation of worktreeAdder.
//
//	func TestSomethingThatUsesworktreeAdder(t *testing.T) {
//
//		// make and configure a mocked worktreeAdder
//		mockedworktreeAdder := &worktreeAdderMock{
//			AddWorktreeFunc: func(worktreeName string, branchName string, newBranch bool, baseBranch string) error {
//				panic("mock out the AddWorktree method")
//			},
//			BranchExistsFunc: func(branch string) (bool, error) {
//				panic("mock out the BranchExists method")
//			},
//			GenerateBranchFromJiraFunc: func(jiraKey string) (string, error) {
//				panic("mock out the GenerateBranchFromJira method")
//			},
//			GetDefaultBranchFunc: func() (string, error) {
//				panic("mock out the GetDefaultBranch method")
//			},
//			GetJiraIssuesFunc: func() ([]internal.JiraIssue, error) {
//				panic("mock out the GetJiraIssues method")
//			},
//		}
//
//		// use mockedworktreeAdder in code that requires worktreeAdder
//		// and then make assertions.
//
//	}
type worktreeAdderMock struct {
	// AddWorktreeFunc mocks the AddWorktree method.
	AddWorktreeFunc func(worktreeName string, branchName string, newBranch bool, baseBranch string) error

	// BranchExistsFunc mocks the BranchExists method.
	BranchExistsFunc func(branch string) (bool, error)

	// GenerateBranchFromJiraFunc mocks the GenerateBranchFromJira method.
	GenerateBranchFromJiraFunc func(jiraKey string) (string, error)

	// GetDefaultBranchFunc mocks the GetDefaultBranch method.
	GetDefaultBranchFunc func() (string, error)

	// GetJiraIssuesFunc mocks the GetJiraIssues method.
	GetJiraIssuesFunc func() ([]internal.JiraIssue, error)

	// calls tracks calls to the methods.
	calls struct {
		// AddWorktree holds details about calls to the AddWorktree method.
		AddWorktree []struct {
			// WorktreeName is the worktreeName argument value.
			WorktreeName string
			// BranchName is the branchName argument value.
			BranchName string
			// NewBranch is the newBranch argument value.
			NewBranch bool
			// BaseBranch is the baseBranch argument value.
			BaseBranch string
		}
		// BranchExists holds details about calls to the BranchExists method.
		BranchExists []struct {
			// Branch is the branch argument value.
			Branch string
		}
		// GenerateBranchFromJira holds details about calls to the GenerateBranchFromJira method.
		GenerateBranchFromJira []struct {
			// JiraKey is the jiraKey argument value.
			JiraKey string
		}
		// GetDefaultBranch holds details about calls to the GetDefaultBranch method.
		GetDefaultBranch []struct {
		}
		// GetJiraIssues holds details about calls to the GetJiraIssues method.
		GetJiraIssues []struct {
		}
	}
	lockAddWorktree            sync.RWMutex
	lockBranchExists           sync.RWMutex
	lockGenerateBranchFromJira sync.RWMutex
	lockGetDefaultBranch       sync.RWMutex
	lockGetJiraIssues          sync.RWMutex
}

// AddWorktree calls AddWorktreeFunc.
func (mock *worktreeAdderMock) AddWorktree(worktreeName string, branchName string, newBranch bool, baseBranch string) error {
	if mock.AddWorktreeFunc == nil {
		panic("worktreeAdderMock.AddWorktreeFunc: method is nil but worktreeAdder.AddWorktree was just called")
	}
	callInfo := struct {
		WorktreeName string
		BranchName   string
		NewBranch    bool
		BaseBranch   string
	}{
		WorktreeName: worktreeName,
		BranchName:   branchName,
		NewBranch:    newBranch,
		BaseBranch:   baseBranch,
	}
	mock.lockAddWorktree.Lock()
	mock.calls.AddWorktree = append(mock.calls.AddWorktree, callInfo)
	mock.lockAddWorktree.Unlock()
	return mock.AddWorktreeFunc(worktreeName, branchName, newBranch, baseBranch)
}

// AddWorktreeCalls gets all the calls that were made to AddWorktree.
// Check the length with:
//
//	len(mockedworktreeAdder.AddWorktreeCalls())
func (mock *worktreeAdderMock) AddWorktreeCalls() []struct {
	WorktreeName string
	BranchName   string
	NewBranch    bool
	BaseBranch   string
} {
	var calls []struct {
		WorktreeName string
		BranchName   string
		NewBranch    bool
		BaseBranch   string
	}
	mock.lockAddWorktree.RLock()
	calls = mock.calls.AddWorktree
	mock.lockAddWorktree.RUnlock()
	return calls
}

// BranchExists calls BranchExistsFunc.
func (mock *worktreeAdderMock) BranchExists(branch string) (bool, error) {
	if mock.BranchExistsFunc == nil {
		panic("worktreeAdderMock.BranchExistsFunc: method is nil but worktreeAdder.BranchExists was just called")
	}
	callInfo := struct {
		Branch string
	}{
		Branch: branch,
	}
	mock.lockBranchExists.Lock()
	mock.calls.BranchExists = append(mock.calls.BranchExists, callInfo)
	mock.lockBranchExists.Unlock()
	return mock.BranchExistsFunc(branch)
}

// BranchExistsCalls gets all the calls that were made to BranchExists.
// Check the length with:
//
//	len(mockedworktreeAdder.BranchExistsCalls())
func (mock *worktreeAdderMock) BranchExistsCalls() []struct {
	Branch string
} {
	var calls []struct {
		Branch string
	}
	mock.lockBranchExists.RLock()
	calls = mock.calls.BranchExists
	mock.lockBranchExists.RUnlock()
	return calls
}

// GenerateBranchFromJira calls GenerateBranchFromJiraFunc.
func (mock *worktreeAdderMock) GenerateBranchFromJira(jiraKey string) (string, error) {
	if mock.GenerateBranchFromJiraFunc == nil {
		panic("worktreeAdderMock.GenerateBranchFromJiraFunc: method is nil but worktreeAdder.GenerateBranchFromJira was just called")
	}
	callInfo := struct {
		JiraKey string
	}{
		JiraKey: jiraKey,
	}
	mock.lockGenerateBranchFromJira.Lock()
	mock.calls.GenerateBranchFromJira = append(mock.calls.GenerateBranchFromJira, callInfo)
	mock.lockGenerateBranchFromJira.Unlock()
	return mock.GenerateBranchFromJiraFunc(jiraKey)
}

// GenerateBranchFromJiraCalls gets all the calls that were made to GenerateBranchFromJira.
// Check the length with:
//
//	len(mockedworktreeAdder.GenerateBranchFromJiraCalls())
func (mock *worktreeAdderMock) GenerateBranchFromJiraCalls() []struct {
	JiraKey string
} {
	var calls []struct {
		JiraKey string
	}
	mock.lockGenerateBranchFromJira.RLock()
	calls = mock.calls.GenerateBranchFromJira
	mock.lockGenerateBranchFromJira.RUnlock()
	return calls
}

// GetDefaultBranch calls GetDefaultBranchFunc.
func (mock *worktreeAdderMock) GetDefaultBranch() (string, error) {
	if mock.GetDefaultBranchFunc == nil {
		panic("worktreeAdderMock.GetDefaultBranchFunc: method is nil but worktreeAdder.GetDefaultBranch was just called")
	}
	callInfo := struct {
	}{}
	mock.lockGetDefaultBranch.Lock()
	mock.calls.GetDefaultBranch = append(mock.calls.GetDefaultBranch, callInfo)
	mock.lockGetDefaultBranch.Unlock()
	return mock.GetDefaultBranchFunc()
}

// GetDefaultBranchCalls gets all the calls that were made to GetDefaultBranch.
// Check the length with:
//
//	len(mockedworktreeAdder.GetDefaultBranchCalls())
func (mock *worktreeAdderMock) GetDefaultBranchCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockGetDefaultBranch.RLock()
	calls = mock.calls.GetDefaultBranch
	mock.lockGetDefaultBranch.RUnlock()
	return calls
}

// GetJiraIssues calls GetJiraIssuesFunc.
func (mock *worktreeAdderMock) GetJiraIssues() ([]internal.JiraIssue, error) {
	if mock.GetJiraIssuesFunc == nil {
		panic("worktreeAdderMock.GetJiraIssuesFunc: method is nil but worktreeAdder.GetJiraIssues was just called")
	}
	callInfo := struct {
	}{}
	mock.lockGetJiraIssues.Lock()
	mock.calls.GetJiraIssues = append(mock.calls.GetJiraIssues, callInfo)
	mock.lockGetJiraIssues.Unlock()
	return mock.GetJiraIssuesFunc()
}

// GetJiraIssuesCalls gets all the calls that were made to GetJiraIssues.
// Check the length with:
//
//	len(mockedworktreeAdder.GetJiraIssuesCalls())
func (mock *worktreeAdderMock) GetJiraIssuesCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockGetJiraIssues.RLock()
	calls = mock.calls.GetJiraIssues
	mock.lockGetJiraIssues.RUnlock()
	return calls
}
